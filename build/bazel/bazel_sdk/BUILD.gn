# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/bazel/bazel_action.gni")
import("//build/bazel/bazel_fuchsia_sdk.gni")
import("//build/bazel/bazel_inputs.gni")
import("//build/bazel/generate_prebuilt_dir_content_hash.gni")
import("//build/bazel/logging.gni")
import("//build/bazel/remote_services.gni")
import("//build/config/fuchsia/platform_version.gni")
import("//build/config/fuchsia/target_api_level.gni")
import("//build/sdk/config.gni")
import("//build/sdk/idk.gni")
import("//build/sdk/sdk_collection.gni")

# The list of target cpu architectures supported by @fuchsia_sdk.
if (bazel_fuchsia_sdk_all_cpus) {
  _fuchsia_sdk_target_cpus = idk_target_cpus
} else {
  _fuchsia_sdk_target_cpus = [ target_cpu ]
}

# Ensure that the //build/bazel/bazel_sdk:idk target
# populates `$OUTPUT_DIR/sdk/exported/bazel_fuchsia_sdk_idk`.
idk("idk") {
  output_name = "bazel_fuchsia_sdk_idk"
  sdk_collection_label = "//sdk:core"

  # Ensure sub-builds are shared with the Core IDK (https://fxbug.dev/342695881)
  # since they use the same set of atoms, but for different sets of
  # (target_cpu, api_level) combos.
  idk_subbuilds_label = "//sdk:core_idk_subbuilds"

  target_cpus = _fuchsia_sdk_target_cpus

  api_levels = []
  if (bazel_fuchsia_sdk_all_api_levels) {
    api_levels = platform_version.idk_buildable_api_levels
  }

  # TODO(https://fxbug.dev/306723826): Deal with the fact that the mac builders
  # are too slow to enable this setting, and therefore the mac IDK won't have
  # per-api-level prebuilts.
  if (host_os == "mac") {
    api_levels = []
  }
}

# Generate a Bazel SDK directly from the content of :idk and verify that
# it matches the content of @fuchsia_sdk. Doing this ensures that there are
# no differences between the Starlark and Python executions of
# generated_sdk_build_rules.{bzl,py}.
bazel_input_directory("idk.bazel_input") {
  generator = ":idk"
  output_directory = "$root_build_dir/sdk/exported/bazel_fuchsia_sdk_idk"
}

bazel_action("verify_fuchsia_sdk_repository") {
  command = "build"
  bazel_targets = [ ":verify_fuchsia_sdk_repository" ]
  deps = [ ":idk.bazel_input" ]
  copy_outputs = [
    {
      bazel = "{{BAZEL_TARGET_OUT_DIR}}/{{BAZEL_TARGET_NAME}}"
      ninja = "$target_name.verified"
    },
  ]
}

foreach(cpu, _fuchsia_sdk_target_cpus) {
  # Run the test suite against the internal IDK used to populate
  # @fuchsia_sdk, for the current target cpu only.
  run_fuchsia_bazel_sdk_tests("bazel_sdk_tests_${cpu}") {
    target_cpu = cpu
  }
}

# Run the test suite against hte internal IDK used to populate
# @fuchsia_sdk, once per supported target CPU architecture, if
# bazel_fuchsia_sdk_all_cpus is set, otherwise only against
# the current target_cpu value.
group("bazel_sdk_tests") {
  testonly = true
  deps = []
  foreach(cpu, _fuchsia_sdk_target_cpus) {
    deps += [ ":bazel_sdk_tests_${cpu}" ]
  }
}

foreach(cpu, idk_target_cpus) {
  # This target runs the test suite against a locally-generated IDK
  # (which includes support for all target architectures), but only
  # for target_cpu. E.g. `bazel_sdk_tests_arm64` will run the
  # test suite with a build configuration that generates Fuchsia/arm64
  # binaries.
  #
  # Note that the IDK does _not_ contain //sdk:driver atoms.
  # (see //sdk:final_fuchsia_idk definition for details).
  run_fuchsia_bazel_sdk_tests("bazel_sdk_tests_idk_${cpu}") {
    target_cpu = cpu
    idk_exported_path = "$root_build_dir/sdk/exported/fuchsia_idk"
    idk_exported_target = "//sdk:final_fuchsia_idk.exported"
  }
}

# This target runs the test suite against each target architecture
# supported by the IDK. Currently, this runs multiple instances of
# the test suite, one per target cpu.
group("bazel_sdk_tests_idk") {
  testonly = true
  deps = []
  foreach(cpu, idk_target_cpus) {
    deps += [ ":bazel_sdk_tests_idk_${cpu}" ]
  }
}

group("tests") {
  testonly = true
  deps = [ ":bazel_sdk_tests" ]
}
