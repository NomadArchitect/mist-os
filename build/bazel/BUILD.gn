# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/developer_overrides.gni")
import("//build/assembly/sshd_config.gni")
import("//build/bazel/bazel_inputs.gni")
import("//build/bazel/bazel_workspace.gni")
import("//build/bazel/generate_prebuilt_dir_content_hash.gni")
import("//build/bazel/legacy_ninja_build_outputs.gni")
import("//build/bazel/remote_services.gni")
import("//build/config/clang/clang.gni")
import("//build/images/vbmeta.gni")
import("//build/info/info.gni")
import("//build/product.gni")
import("//build/toolchain/rbe.gni")
import("//src/connectivity/policy/netcfg/delegated_network_provisioning.gni")

assert(
    current_toolchain == default_toolchain,
    "This BUILD.gn file should only be parsed in the default toolchain, to prevent generating Bazel workspace multiple times.")

action("generate_main_workspace") {
  script = "//build/bazel/scripts/update_workspace.py"

  # The update script tracks the file and directory entries of FUCHSIA_DIR
  # and will update the workspace if they change (i.e. if a file or
  # directory is added to / removed from FUCHSIA_DIR itself). However,
  # there is no way for Ninja to track these changes, and thus no way
  # to enforce the action to be run when this happens, even though these
  # are rare occurences, that could happen in the following cases:
  #
  # - A developer manually adds or removes a file to/from FUCHSIA_DIR.
  #   In this case, manually calling the script is needed, and this
  #   can be done by invoking any `fx bazel ...` command (even
  #   `fx bazel version`) or `fx build bazel_workspace`.
  #
  # - A `jiri update` modifies the content of FUCHSIA_DIR. Depend on
  #   the top-level //.git/index file to detect this. Note that the
  #   script will not necessarily update the workspace in this case,
  #   this simply ensures that it is run to do its checks.
  #
  # - A manual `git checkout HEAD^ -- .` command will modify the local
  #   workspace without modifying the index, so also depend on
  #   //.git/HEAD to detect this.
  #
  inputs = [
    "//.git/index",
    "//.git/HEAD",

    # The bazel prebuilt is an implicit input for the script.
    "//prebuilt/third_party/bazel/${host_os}-${host_cpu}/bazel",

    # The script expands these templates
    "//build/bazel/templates/template.bazel.sh",
    "//build/bazel/templates/template.bazelrc",
    "//build/bazel/templates/template.remote_services.bazelrc",
    "//build/bazel/templates/template.platform_mappings",

    # The script reads this configuration file
    "//build/bazel/config/main_workspace_top_dir",

    # The script imports these python files
    "//build/bazel/scripts/check_ninja_build_plan.py",
    "//build/bazel/scripts/compute_content_hash.py",

    # The script reads RBE configs
    rewrapper_config_file,
    reproxy_config_file,
  ]

  # This dependency is needed to properly populate the @fuchsia_sdk repository.
  deps = [ "//build/bazel/bazel_sdk:idk" ]

  # This dependency is needed to properly populate the @internal_sdk repository
  # used experimentally to migrate non-SDK GN targets to Bazel
  # (see https://fxbug.dev/42063353).
  deps += [ "//sdk:platform" ]

  depfile = "${target_gen_dir}/${target_name}.d"

  outputs = [
    # LINT.IfChange
    "${bazel_main_top_dir}/bazel",
    "${bazel_main_top_dir}/download_config_file",
    "${bazel_main_top_dir}/generated-info.json",
    "${bazel_main_top_dir}/workspace/.bazelrc",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/args.json",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/git",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/jiri_snapshot.xml",

    # The list of content hash files
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/bazel_rules_fuchsia.hash",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/boringssl.hash",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/com_google_googletest.hash",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/fuchsia_clang.hash",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/fuchsia_sdk.hash",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/internal_sdk.hash",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/prebuilt_clang.hash",
    "${bazel_main_top_dir}/workspace/fuchsia_build_generated/prebuilt_python.hash",

    # Other files.
    "${bazel_main_top_dir}/workspace/platform_mappings",
    "${bazel_main_top_dir}/workspace/WORKSPACE.bazel",

    # LINT.ThenChange(scripts/update_workspace.py)
  ]

  args = [
    "--gn_output_dir",
    rebase_path(root_build_dir, root_build_dir),
    "--target_arch",
    target_cpu,
    "--depfile",
    rebase_path(depfile, root_build_dir),
    "--remote_download_outputs",
    bazel_rbe_download_outputs,
  ]

  # The generated wrapper includes the absolute path of the Ninja output
  # directory, which will be read by Bazel repository rules during workspace
  # setup.
  no_output_dir_leaks = false
}

# Generate a symlink to the @fuchsia_sdk repository, after ensuring it was
# properly populated by Bazel. The symlink has a stable path of
# $BAZEL_TOPDIR/fuchsia_sdk while the actual location of the repository
# depends on Bazel internals (e.g. whether BzlMod is enabled or not).
action("generate_fuchsia_sdk_repository") {
  script = "//build/bazel/scripts/generate-fuchsia-sdk-symlink.py"
  outputs = [ "$bazel_main_top_dir/fuchsia_sdk" ]
  deps = [
    ":generate_main_workspace",
    "//build/bazel/bazel_sdk:verify_fuchsia_sdk_repository",
  ]
  inputs = get_target_outputs(deps[0])
  args = [
    "--bazel-launcher",
    rebase_path(inputs[0], root_build_dir),
    "--output-symlink",
    rebase_path(outputs[0], root_build_dir),
  ]
  metadata = {
    # Used by the //:bazel_sdk_info build API module target.
    bazel_sdk_info = [
      {
        location = rebase_path(outputs[0], root_build_dir)
      },
    ]
  }

  # This script invokes Bazel directly. Use console pool to prevent
  # concurrent bazel invocations.
  pool = "//:console($default_toolchain)"

  # This cannot be hermetic as well since it creates a ton of
  # files in the output base that cannot be listed in advance.
  hermetic_deps = false
}

# Generate content hash files for python and Clang toolchains.
#
# These will be used to trigger new runs of the bazel_sdk_test_xxx targets
# if the content of these directory changes. And the
# //build/bazel_sdk/tests/script/bazel_test.py script will ensure that their
# values are passed to the test workspace.
#
generate_prebuilt_dir_content_hash(prebuilt_content_hash_targets.python) {
  source_dir = "//prebuilt/third_party/python3/${host_os}-${host_cpu}"
  output = prebuilt_content_hash_files.python
  cipd_name = "cpython3"
  exclude_suffixes = [ ".pyc" ]
}

generate_prebuilt_dir_content_hash(prebuilt_content_hash_targets.clang) {
  # clang_prefix points to the "bin" directory in clang toolchain, so go one
  # level up to get the clang root dir.
  source_dir = get_path_info(clang_prefix, "dir")
  output = prebuilt_content_hash_files.clang
  cipd_name = "clang"
}

# Generate remote service configs into a bazelrc.
action("remote_services_bazelrc") {
  script = "//build/bazel/scripts/generate_services_bazelrc.py"
  _output = "$target_out_dir/remote_services.bazelrc"
  outputs = [ _output ]
  _template = "//build/bazel/templates/template.remote_services.bazelrc"
  _configs = [
    "//build/rbe/fuchsia-reproxy.cfg",
    "//build/rbe/fuchsia-rewrapper.cfg",
  ]
  inputs = [ _template ] + _configs
  args = [
           "--template",
           rebase_path(_template, root_build_dir),
           "--output",
           rebase_path(_output, root_build_dir),
           "--remote_download_outputs",
           bazel_rbe_download_outputs,
           "--cfgs",
         ] + rebase_path(_configs, root_build_dir)
}

# Pass the map of which developer overrides to use with which assembly label to
# Bazel.
generated_file("assembly_developer_overrides") {
  outputs = [ "${root_gen_dir}/assembly_developer_overrides.json" ]
  contents = product_assembly_overrides
  output_conversion = "json"
}

group("tests") {
  testonly = true
  deps = [
    "bazel_sdk:tests",
    "scripts:tests",
  ]
}
