# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""The gn_targets_repository() repository rule."""

def _gn_targets_repository_impl(repo_ctx):
    # The files generated by //build/bazel/scripts/bazel_action.py.
    # Note that these attributes are strings, not labels, because the files
    # will _not_ necessarily exist, due to the following contraints:
    #
    # - These files are modified by several distinct Ninja actions
    #   (each one corresponding to a single GN bazel_action() target), as
    #   such, they cannot be listed as outputs of any Ninja target, as this
    #   would ruin Ninja no-op checks.
    #
    # - These files may not exist in certain cases, for example, starting
    #   with a clean build, then doing `fx build bazel_workspace`, then
    #   `fx bazel query @gn_targets//:*` would force this repository rule
    #   to run without them.
    #
    #   Using a label attribute would fail to run the repository run entirely
    #   because Bazel would complain about missing files. The error message
    #   is extremely confusing, so instead, do a soft-detect in the rule
    #   with a better error message.
    #
    # - This repository rule should still be run every time the content of
    #   this file changes, hence the need to track them, by calling
    #   repo_ctx.path(Label("@//:<path>")), which appends their path and
    #   content hash to `$OUTPUT_BASE/external/@gn_targets.marker`, the
    #   file used by Bazel to track such content.
    #
    #
    # - These files are re-generated with different content by Ninja build
    #   actions of GN bazel_action() targets. I.e. they are mo
    #
    # - Due to this, they cannot be listed as
    #
    # These files may not exist,
    # Path to the files generated by //build/bazel/scripts/bazel_action.py
    # for each bazel_action() GN target. Note that these are string attributes
    # because the files may not exist when setting up the Bazel workspace!
    inputs_manifest_str = repo_ctx.attr.inputs_manifest
    all_licenses_spdx_json_str = repo_ctx.attr.all_licenses_spdx_json

    inputs_manifest_path = repo_ctx.workspace_root.get_child(inputs_manifest_str)
    all_licenses_spdx_path = repo_ctx.workspace_root.get_child(all_licenses_spdx_json_str)

    # The file may not exist if this rule is run manually before any
    if not inputs_manifest_path.exists:
        fail("Missing generated file: %s" % inputs_manifest_path)
    if not all_licenses_spdx_path.exists:
        fail("Missing generated file: %s" % all_licenses_spdx_path)

    # Ensure that this repository rule is re-run every time the content of
    # these files changes.
    repo_ctx.path(Label("@//:" + inputs_manifest_str))
    repo_ctx.path(Label("@//:" + all_licenses_spdx_json_str))

    # The Ninja output directory is passed by the launcher script at
    # $BAZEL_TOPDIR/bazel as an environment variable.
    #
    # This is the root directory for all source entries in the manifest.
    # Create a //:ninja_output symlink in the repository to point to it.
    ninja_output_dir = repo_ctx.os.environ["BAZEL_FUCHSIA_NINJA_OUTPUT_DIR"]
    source_prefix = ninja_output_dir + "/"

    # The top-level directory that will contain symlinks to all Ninja output
    # files. For example //_ninja_build_dir:obj/src/foo/foo.cc.o
    build_dir_name = "_files"

    all_files = []

    # Build a { bazel_package -> { gn_target_name -> entry } } map.
    package_map = {}
    for entry in json.decode(repo_ctx.read(inputs_manifest_path)):
        bazel_package = entry["bazel_package"]
        bazel_name = entry["bazel_name"]
        name_map = package_map.setdefault(bazel_package, {})
        name_map[bazel_name] = entry

    # Create the //targets/{gn_dir}/BUILD.bazel file for each GN directory.
    # Every target defined in {gn_dir}/BUILD.gn that is part of the manifest
    # will have its own filegroup() entry with the corresponding target name.
    for bazel_package, name_map in package_map.items():
        content = """# AUTO-GENERATED - DO NOT EDIT

package(
    default_applicable_licenses = ["//:all_licenses_spdx_json"],
    default_visibility = ["//visibility:public"],
)

"""
        for bazel_name, entry in name_map.items():
            file_links = entry.get("output_files", [])
            for file in file_links:
                target_path = source_prefix + file
                link_path = "%s/%s" % (build_dir_name, file)

                # Create //_files/{ninja_path} as a symlink to the Ninja output location.
                repo_ctx.symlink(target_path, link_path)
                all_files.append(file)

                content += '''
# From GN target: {label}
filegroup(
    name = "{name}",
    srcs = '''.format(label = entry["generator_label"], name = bazel_name)
                if len(file_links) == 1:
                    content += '["_files/%s"],\n' % file_links[0]
                else:
                    content += "[\n"
                    for file in file_links:
                        content += '        "_files/%s",\n' % file
                    content += "    ],\n"
                content += ")\n"

            dir_link = entry.get("output_directory", "")
            if dir_link:
                target_path = source_prefix + dir_link
                link_path = "%s/%s" % (build_dir_name, dir_link)

                content += '''
# From GN target: {label}
filegroup(
    name = "{name}",
    srcs = glob(["{ninja_path}/**"], exclude_directories=1),
)
alias(
    name = "{name}.directory",
    actual = "{ninja_path}",
)
'''.format(label = entry["generator_label"], name = bazel_name, ninja_path = link_path)

                # Create //_files/{ninja_path} as a symlink to the real path.
                repo_ctx.symlink(target_path, link_path)

                # Create //{gn_dir}/{bazel_name}.directory as a symlink to //_files/{ninja_path}
                repo_ctx.symlink(link_path, "%s/%s.directory" % (bazel_package, bazel_name))

        repo_ctx.file("%s/BUILD.bazel" % bazel_package, content, executable = False)
        repo_ctx.symlink(build_dir_name, "%s/_files" % bazel_package)

    # The symlink for the special all_licenses_spdx.json file.
    # IMPORTANT: This must end in `.spdx.json` for license classification to work correctly!
    repo_ctx.symlink(all_licenses_spdx_path, "all_licenses.spdx.json")

    # The content of BUILD.bazel
    build_content = '''# AUTO-GENERATED - DO NOT EDIT
load("@rules_license//rules:license.bzl", "license")

# This contains information about all the licenses of all
# Ninja outputs exposed in this repository.
# IMPORTANT: package_name *must* be "Legacy Ninja Build Outputs"
# as several license pipeline exception files hard-code this under //vendor/...
license(
    name = "all_licenses_spdx_json",
    package_name = "Legacy Ninja Build Outputs",
    license_text = "all_licenses.spdx.json",
    visibility = ["//visibility:public"]
)

'''
    repo_ctx.file("BUILD.bazel", build_content)

    # Workspace declaration (required but unused in practice)
    repo_ctx.file("WORKSPACE.bazel", 'workspace(name = "{name}\n")'.format(name = repo_ctx.attr.name))
    repo_ctx.file("MODULE.bazel", 'module(name = "{name}", version = "1"),\n'.format(name = repo_ctx.attr.name))

gn_targets_repository = repository_rule(
    implementation = _gn_targets_repository_impl,
    doc = "A repository exposing Ninja outputs with Bazel filegroups.",
    attrs = {
        "inputs_manifest": attr.string(
            mandatory = True,
            doc = "Path to input manifest file, relative to workspace root.",
        ),
        "all_licenses_spdx_json": attr.string(
            mandatory = True,
            doc = "Path to SPDX file containing all license information, relative to workspace root.",
        ),
    },
)
