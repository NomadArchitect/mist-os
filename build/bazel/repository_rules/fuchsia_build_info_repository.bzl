# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

def _generate_args_bzl_content(repo_ctx, args, variables_list_path):
    """Generate an args.bzl file that defines values extracted from GN's args.gn.

    Args:
      repo_ctx: Repository context.
      args: The GN args.json file as a JSON dictionary.
      variables_list_path: Path value pointing to the file describing which
         values to extract, and how to translate that into corresponding
         Starlark values. See //build/bazel/gn_args.txt for details.
    Returns:
      The content of the generated args.bzl file.
    """

    # Parse the list file to generate the content of args.bzl
    source_path = str(variables_list_path).replace(str(repo_ctx.workspace_root), "/")
    args_contents = """# AUTO-GENERATED BY fuchsia_build_info_repository() RULE - DO NOT EDIT
# Variables listed from {source_path}

""".format(source_path = source_path)

    # Avoid Gerrit warnings by constructing the linting prefixes with string concatenation.
    lint_change_if_prefix = "LINT." + "IfChange("
    lint_change_then_prefix = "LINT." + "ThenChange("
    lint_change_if_start_line = -1
    pending_lines = ""
    line_count = 0
    for line in repo_ctx.read(variables_list_path).splitlines():
        line_count += 1
        line = line.strip()

        if not line:  # Ignore empty lines
            continue

        if line[0] == "#":
            comment = line[1:].lstrip()
            if comment.startswith(lint_change_if_prefix):
                if pending_lines:
                    fail("{}:{}: Previous {} at line {} was never closed!".format(
                        variables_list_path,
                        line_count,
                        lint_change_if_prefix,
                        lint_change_if_start_line,
                    ))
                lint_change_if_start_line = line_count
                continue

            if comment.startswith(lint_change_then_prefix):
                source_start = len(lint_change_then_prefix)
                source_end = comment.find(")", source_start)
                if source_end < 0:
                    fail("{}:{}: Unterminated {} line: {}".format(
                        variables_list_path,
                        line_count,
                        lint_change_then_prefix,
                        line,
                    ))
                source_path = comment[source_start:source_end]
                args_contents += "# From {}\n".format(source_path) + pending_lines + "\n"
                pending_lines = ""
                continue

            # Skip other comment lines.
            continue

        name_end = line.find(":")
        if name_end < 0:
            fail("{}:{}: Missing colon separator: {}".format(variables_list_path, line_count, line))

        varname = line[0:name_end]
        vartype = line[name_end + 1:].strip()
        if vartype == "bool":
            value = args.get(varname, False)
            pending_lines += "{} = {}\n".format(varname, value)
        elif vartype == "string":
            value = args.get(varname, "")
            pending_lines += "{} = \"{}\"\n".format(varname, value)
        elif vartype == "string_or_false":
            if not args.get(varname):
                value = ""
            else:
                value = args[varname]
            pending_lines += "{} = \"{}\"\n".format(varname, value)
        else:
            fail("{}:{}: Unknown type name '{}': {}".format(
                variables_list_path,
                line_count,
                vartype,
                line,
            ))

    if pending_lines:
        fail("{}:{}: {} statement was never closed!".format(
            variables_list_path,
            line_count,
            lint_change_if_prefix,
            lint_change_if_start_line,
        ))

    return args_contents

def _fuchsia_build_info_repository_impl(repo_ctx):
    # Extract labels as soon as possible.
    file_path = repo_ctx.path(repo_ctx.attr._gn_build_args_txt)
    args_json_path = repo_ctx.path(repo_ctx.attr.args)

    # Read args.json
    args = json.decode(repo_ctx.read(args_json_path))

    args_contents = _generate_args_bzl_content(repo_ctx, args, file_path)

    repo_ctx.file("WORKSPACE.bazel", "workspace(name = {})\n".format(repo_ctx.name))
    repo_ctx.file("BUILD.bazel", "")
    repo_ctx.file("args.bzl", args_contents)

    # Allow //vendor/$VENDOR/build/bazel/gn_build_args.txt to list extra
    # args.gn variables to be extracted. They will be written to
    # @<repo_name>//:vendor_$VENDOR_args.bzl
    for vendor in ["google"]:
        vendor_gn_path = repo_ctx.workspace_root.get_child("vendor", vendor, "build", "bazel", "gn_build_args.txt")
        if vendor_gn_path.exists:
            # This line ensures that Bazel will rerun this repository rule if the
            # file content's changes. The Label() call fails at runtime if the file
            # does not exist.
            repo_ctx.path(Label("@//vendor/%s/build/bazel:gn_build_args.txt" % vendor))

            vendor_defs = _generate_args_bzl_content(repo_ctx, args, vendor_gn_path)
            repo_ctx.file("vendor_%s_args.bzl" % vendor, vendor_defs)

fuchsia_build_info_repository = repository_rule(
    implementation = _fuchsia_build_info_repository_impl,
    doc = "A repository holding information about the current Fuchsia build configuration.",
    attrs = {
        "args": attr.label(
            doc = "args.json source file label.",
            allow_single_file = True,
            mandatory = True,
        ),
        "_gn_build_args_txt": attr.label(
            doc = "Input file used to list all imported GN build arguments.",
            allow_single_file = True,
            default = "//:build/bazel/gn_build_args.txt",
        ),
    },
)
