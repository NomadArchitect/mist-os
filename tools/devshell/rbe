#!/bin/bash
# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

#### CATEGORY=Build
### check remote build configuration

## usage:
##  fx rbe auth [options...]
##      Verify authentication to RBE services through reclient and bazel.
##      Options:
##        -f,--force: Always request a fresh authentication token.
##
##  fx rbe cleanlogs
##      Clean up reproxy log dirs (from using fuchsia-reproxy-wrap.sh).
##

set -e

source "$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"/lib/vars.sh || exit $?
source "${FUCHSIA_DIR}/tools/devshell/lib/style.sh" || exit $?

# This sets up and shuts down reproxy automatically.
readonly reproxy_wrap="$FUCHSIA_DIR/build/rbe/fuchsia-reproxy-wrap.sh"

readonly python="$PREBUILT_PYTHON3"

# remote_action.py exercises rewrapper
readonly remote_action="$FUCHSIA_DIR/build/rbe/remote_action.py"

reproxy_wrap_cmd=( "$reproxy_wrap" )
# Propagate tracing option from `fx -x rbe ...` to the wrapper script.
# This is less invasive than re-exporting SHELLOPTS.
if [[ -o xtrace ]]; then
  reproxy_wrap_cmd=( "$SHELL" -x "${reproxy_wrap_cmd[@]}" )
fi

# A single command that tests RBE end-to-end through reclient.
reclient_auth_test_cmd=(
  env
  --unset=FX_BUILD_RBE_STATS
  FX_REMOTE_BUILD_METRICS=0
  # Let the wrapper use a default --logdir and --tmpdir.
  "${reproxy_wrap_cmd[@]}" --
  "$python" -S "$remote_action" --
  echo "greetings from a remote RBE worker"
)

function usage() {
  fx-command-help
}

fx-standard-switches "$@"
set -- "${FX_ARGV[@]}"

if [[ $# -lt 1 ]]; then
  fx-error Invalid syntax
  fx-command-help
  exit 1
fi

action="$1"
shift
action_args=("$@")

function is_googler() {
  which gcert > /dev/null 2>&1
}

gcloud=

function ensure_gcloud() {
  # go/gcloud-cli#getting-started
  gcloud="$(which gcloud)" || {
    echo "gcloud not found."
    if is_googler
    then
      _cmd=(sudo apt install -y google-cloud-cli)
      echo "Install gcloud with the following command?: ${_cmd[@]}"
      select yn in "y" "n" "Y" "N"
      do
        case "$yn" in
          [yY] ) "${_cmd[@]}" && gcloud="$(which gcloud)" ; return "$?" ;;
          [nN] ) echo "Follow the instructions at go/gcloud-cli#getting-started"
            ;;
        esac
      done
    else
      echo "Follow the instructions at https://cloud.google.com/sdk/docs/install"
    fi
    return 1
  }
}

readonly gcloud_auth_args=(auth login --update-adc)
function gcloud_auth() {
  ensure_gcloud &&
    echo "running: gcloud ${gcloud_auth_args[@]}" &&
    echo "If you see a warning about running on a \"Google Compute Engine virtual machine\", hit 'Y' to continue to use a personal account." &&
    "$gcloud" "${gcloud_auth_args[@]}"
}

function reclient_auth() {
  echo  # blank line
  # Coerce the working directory to match the exec-root ($FUCHSIA_DIR), so the
  # remote environment does not try to run in a nonexistent subdir.
  # Normally subdirs are created automatically based on remote inputs and
  # outputs, but this test command (echo) has neither inputs nor outputs.
  # b/376105913 is an example of failing to execute remotely for this reason.
  cd "$FUCHSIA_DIR"
  until "${reclient_auth_test_cmd[@]}"
  do
    # gcert only works in environments that get unrestricted LOAS credentials
    # whereas gcloud auth will always work.
    # https://fuchsia.dev/internal/intree/concepts/remote-builds#authentication
    gcloud_auth || {
      echo "Failed to authenticate with gcloud."
      return 1
    }
  done
  style::echo --green "re-client+RBE authentication successful"
}

readonly BAZEL_TEST_DIR="$FUCHSIA_DIR/out/_bazel_rbe_test"
function setup_bazel_workspace() {
  rm -rf "$BAZEL_TEST_DIR"
  "$python" -S "$FUCHSIA_DIR/build/bazel/scripts/minimal_workspace.py" \
    --fuchsia-dir="$FUCHSIA_DIR" \
    --bazel-bin="$PREBUILT_BAZEL" \
    --topdir="$BAZEL_TEST_DIR"
}

function test_bazel_rbe() {
  setup_bazel_workspace
  # Test authentication to RBE and BES (both share the same gcloud auth).
  # Shutdown any bazel server each time to prevent it from caching
  # stale credentials, and force it to refresh.
  # Limit the number of upload retries to make this operation fail-fast.
  (
    cd "$BAZEL_TEST_DIR/workspace" &&
      ../bazel shutdown && \
      ../bazel --nohome_rc \
          test \
          --config=remote \
          --config=resultstore \
          --experimental_build_event_upload_max_retries=1 \
          :all
  )
}

function bazel_auth() {
  until test_bazel_rbe
  do
    gcloud_auth || {
      echo "Failed to authenticate with gcloud."
      return 1
    }
  done
  style::echo --green "bazel+RBE authentication successful"
}

function auth_subcommand() {
  local force=0
  for opt in "$@"
  do
    case "$opt" in
      -f|--force) force=1 ;;
      *) echo "Unknown option: $opt" ; return 1 ;;
    esac
  done

  if [[ "$force" == 1 ]]
  then
    # Start with a re-auth to get a fresh token.
    # This is a good idea if you don't know when your current token expires.
    gcloud_auth || {
      echo "Failed to authenticate with gcloud."
      return 1
    }
  fi

  bazel_auth && reclient_auth && echo && style::echo --bold --green "You can now 'fx build' with RBE."
}

# LINT.IfChange(reproxy_log_dirs)
# vars.sh:fx-run-ninja writes RBE logs here:
readonly rbe_logs_dir="${FUCHSIA_DIR}/out/.reproxy_logs"
# LINT.ThenChange(/tools/devshell/lib/vars.sh:reproxy_log_dirs)
function cleanlogs_subcommand() {
  echo "Removing $rbe_logs_dir"
  rm -rf "$rbe_logs_dir"
}

# main
case "$action" in
  -h|--help)
    usage
    exit 0
    ;;

  auth) auth_subcommand "${action_args[@]}" ;;
  cleanlogs) cleanlogs_subcommand "${action_args[@]}" ;;

  *)
    fx-error Invalid syntax
    fx-command-help
    exit 1
    ;;
esac
