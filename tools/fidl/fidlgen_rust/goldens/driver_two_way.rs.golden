// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::client::QueryResponseFut;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use fidl::endpoints::{ControlHandle as _, Responder as _};
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct TwoWayAddRequest {
    pub addend1: u16,
    pub addend2: u16,
}

impl fidl::Persistable for TwoWayAddRequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct TwoWayAddResponse {
    pub sum: u16,
}

impl fidl::Persistable for TwoWayAddResponse {}

#[cfg(feature = "driver")]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct TwoWayMarker;

#[cfg(feature = "driver")]
impl fidl_driver::endpoints::DriverProtocolMarker for TwoWayMarker {
    const DEBUG_NAME: &'static str = "(anonymous) TwoWay";
}

#[cfg(feature = "driver")]
#[derive(Debug)]
pub enum TwoWayRequest {
    Add { addend1: u16, addend2: u16, responder: TwoWayAddResponder },
}

#[cfg(feature = "driver")]
impl TwoWayRequest {
    #[allow(irrefutable_let_patterns)]
    pub fn into_add(self) -> Option<(u16, u16, TwoWayAddResponder)> {
        if let TwoWayRequest::Add { addend1, addend2, responder } = self {
            Some((addend1, addend2, responder))
        } else {
            None
        }
    }

    pub fn new_add(self, addend1: u16, addend2: u16, tx_id: u32) -> Self {
        Self::Add { addend1, addend2, responder: TwoWayAddResponder { tx_id } }
    }

    pub fn r#add_as_message(
        arena: fdf::Arena,
        mut addend1: u16,
        mut addend2: u16,
        tx_id: u32,
    ) -> Result<fdf::Message<[u8]>, fidl::Error> {
        let ordinal = 0xdbc3aab0bc6850f;
        let dynamic_flags = fidl::encoding::DynamicFlags::empty();
        let body = (addend1, addend2);
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(tx_id, ordinal, dynamic_flags),
            body,
        };
        fidl::encoding::with_tls_encoded::<
            fidl::encoding::TransactionMessageType<TwoWayAddRequest>,
            fidl::encoding::DefaultFuchsiaResourceDialect,
            fdf::Message<[u8]>,
        >(msg, |bytes, mut handles| {
            let handles = arena.insert_from_iter(
                std::mem::take(handles)
                    .into_iter()
                    .map(fidl_driver::encoding::mixed_from_handle_disposition),
            );
            Ok(fdf::Message::new(&arena, Some(arena.insert_slice(bytes)), Some(handles)))
        })
    }

    #[allow(irrefutable_let_patterns)]
    pub fn read_from(bytes: &[u8], _handles: &mut [zx::HandleInfo]) -> Result<Self, fidl::Error> {
        let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

        match header.ordinal {
            0xdbc3aab0bc6850f => {
                header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                let mut req = fidl::new_empty!(
                    TwoWayAddRequest,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                );
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<TwoWayAddRequest>(&header, _body_bytes, _handles, &mut req)?;
                Ok(TwoWayRequest::Add {
                    addend1: req.addend1,
                    addend2: req.addend2,

                    responder: TwoWayAddResponder { tx_id: header.tx_id },
                })
            }
            _ => Err(fidl::Error::UnknownOrdinal {
                ordinal: header.ordinal,
                protocol_name:
                    <TwoWayMarker as fidl_driver::endpoints::DriverProtocolMarker>::DEBUG_NAME,
            }),
        }
    }

    pub fn read_from_message(
        mut message: fdf::Message<[u8]>,
    ) -> Result<(fdf::Arena, Self), fidl::Error> {
        let (arena, Some(body), Some(handles)) = message.take_arena_boxes() else {
            return Err(fidl::Error::Invalid);
        };
        let mut handles = arena.try_insert_from_iter(
            handles
                .into_iter()
                .map(|handle| unsafe { fidl_driver::encoding::mixed_into_handle_info(handle) }),
        );
        let res = match handles {
            Ok(ref mut handles) => Self::read_from(&*body, handles)?,
            Err(_) => return Err(fidl::Error::Invalid),
        };
        std::mem::drop((body, handles));
        Ok((message.take_arena(), res))
    }

    /// Name of the method defined in FIDL
    pub fn method_name(&self) -> &'static str {
        match *self {
            TwoWayRequest::Add { .. } => "add",
        }
    }
}

/// Like [`TwoWayRequest::read_from_message`] except it drops the [`Arena`].
#[cfg(feature = "driver")]
impl std::convert::TryFrom<fdf::Message<[u8]>> for TwoWayRequest {
    type Error = fidl::Error;
    fn try_from(msg: fdf::Message<[u8]>) -> Result<TwoWayRequest, fidl::Error> {
        Ok(TwoWayRequest::read_from_message(msg)?.1)
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[cfg(feature = "driver")]
#[derive(Debug)]
pub struct TwoWayAddResponder {
    tx_id: u32,
}

#[cfg(feature = "driver")]
impl TwoWayAddResponder {
    pub fn send_response(
        &self,
        server_handle: &fdf::Channel<[u8]>,
        mut sum: u16,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                0xdbc3aab0bc6850f,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (sum,),
        };
        fidl::encoding::with_tls_encoded::<
            fidl::encoding::TransactionMessageType<TwoWayAddResponse>,
            fidl::encoding::DefaultFuchsiaResourceDialect,
            (),
        >(msg, |body, _handles| {
            server_handle
                .write_with_data(fdf::Arena::new(), |arena| arena.insert_slice(&body))
                .unwrap();
            Ok(())
        })
    }
}

mod internal {
    use super::*;

    impl fidl::encoding::ValueTypeMarker for TwoWayAddRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for TwoWayAddRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            2
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<TwoWayAddRequest, D>
        for &TwoWayAddRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<TwoWayAddRequest>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut TwoWayAddRequest)
                    .write_unaligned((self as *const TwoWayAddRequest).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u16, D>,
            T1: fidl::encoding::Encode<u16, D>,
        > fidl::encoding::Encode<TwoWayAddRequest, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<TwoWayAddRequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 2, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for TwoWayAddRequest {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { addend1: fidl::new_empty!(u16, D), addend2: fidl::new_empty!(u16, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for TwoWayAddResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for TwoWayAddResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            2
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            2
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<TwoWayAddResponse, D>
        for &TwoWayAddResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<TwoWayAddResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut TwoWayAddResponse)
                    .write_unaligned((self as *const TwoWayAddResponse).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<u16, D>>
        fidl::encoding::Encode<TwoWayAddResponse, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<TwoWayAddResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for TwoWayAddResponse {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { sum: fidl::new_empty!(u16, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 2);
            }
            Ok(())
        }
    }
}
