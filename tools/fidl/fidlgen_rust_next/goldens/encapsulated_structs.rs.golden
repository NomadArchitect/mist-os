// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(
    unused_parens,
    unused_variables,
    unused_mut,
    unused_imports,
    unreachable_code,
    nonstandard_style
)]

#[derive(Clone, Debug)]
pub struct Int16Int8 {
    pub a: i16,
    pub b: i8,
}

impl ::fidl::Encode for Int16Int8 {
    type Encoded<'buf> = WireInt16Int8;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<Int16Int8> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireInt16Int8>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireInt16Int8> for Int16Int8 {
    fn take_from(from: &mut WireInt16Int8) -> Self {
        Self {
            a: ::fidl::TakeFrom::take_from(&mut from.a),
            b: ::fidl::TakeFrom::take_from(&mut from.b),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireInt16Int8 {
    pub a: ::fidl::i16_le,
    pub b: i8,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireInt16Int8 {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
                mut b,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ArrayInt16Int8 {
    pub arr: [crate::Int16Int8; 3],
}

impl ::fidl::Encode for ArrayInt16Int8 {
    type Encoded<'buf> = WireArrayInt16Int8;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                arr,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.arr, encoder, arr)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<ArrayInt16Int8> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireArrayInt16Int8>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireArrayInt16Int8> for ArrayInt16Int8 {
    fn take_from(from: &mut WireArrayInt16Int8) -> Self {
        Self { arr: ::fidl::TakeFrom::take_from(&mut from.arr) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireArrayInt16Int8 {
    pub arr: [crate::WireInt16Int8; 3],
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireArrayInt16Int8 {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut arr,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(arr.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Int8Int32 {
    pub a: i8,
    pub b: i32,
}

impl ::fidl::Encode for Int8Int32 {
    type Encoded<'buf> = WireInt8Int32;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<Int8Int32> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireInt8Int32>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireInt8Int32> for Int8Int32 {
    fn take_from(from: &mut WireInt8Int32) -> Self {
        Self {
            a: ::fidl::TakeFrom::take_from(&mut from.a),
            b: ::fidl::TakeFrom::take_from(&mut from.b),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireInt8Int32 {
    pub a: i8,
    pub b: ::fidl::i32_le,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireInt8Int32 {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
                mut b,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct NonInlineStructTestStruct {
    pub element: Option<Box<crate::Int16Int8>>,
    pub h: Option<::fidl::Handle>,
}

impl ::fidl::Encode for NonInlineStructTestStruct {
    type Encoded<'buf> = WireNonInlineStructTestStruct<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                element,
                h,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.element, encoder, element)?;
        ::fidl::Encode::encode(&mut self.h, encoder, h)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<NonInlineStructTestStruct> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireNonInlineStructTestStruct<'buf>>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireNonInlineStructTestStruct<'buf>> for NonInlineStructTestStruct {
    fn take_from(from: &mut WireNonInlineStructTestStruct<'buf>) -> Self {
        Self {
            element: ::fidl::TakeFrom::take_from(&mut from.element),
            h: ::fidl::TakeFrom::take_from(&mut from.h),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireNonInlineStructTestStruct<'buf> {
    pub element: ::fidl::WireBox<'buf, crate::WireInt16Int8>,
    pub h: ::fidl::WireHandle,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireNonInlineStructTestStruct<'buf> {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut element,
                mut h,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(element.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(h.as_mut(), decoder)?;
        let h = unsafe { h.deref_unchecked() };

        if h.as_raw_handle().is_none() {
            return Err(::fidl::decode::Error::RequiredValueAbsent);
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct StructPaddingTestStruct {
    pub trailing: crate::Int16Int8,
    pub inner: crate::Int8Int32,
    pub array: crate::ArrayInt16Int8,
}

impl ::fidl::Encode for StructPaddingTestStruct {
    type Encoded<'buf> = WireStructPaddingTestStruct;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                trailing,
                inner,
                array,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.trailing, encoder, trailing)?;
        ::fidl::Encode::encode(&mut self.inner, encoder, inner)?;
        ::fidl::Encode::encode(&mut self.array, encoder, array)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<StructPaddingTestStruct> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireStructPaddingTestStruct>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireStructPaddingTestStruct> for StructPaddingTestStruct {
    fn take_from(from: &mut WireStructPaddingTestStruct) -> Self {
        Self {
            trailing: ::fidl::TakeFrom::take_from(&mut from.trailing),
            inner: ::fidl::TakeFrom::take_from(&mut from.inner),
            array: ::fidl::TakeFrom::take_from(&mut from.array),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireStructPaddingTestStruct {
    pub trailing: crate::WireInt16Int8,
    pub inner: crate::WireInt8Int32,
    pub array: crate::WireArrayInt16Int8,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireStructPaddingTestStruct {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut trailing,
                mut inner,
                mut array,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(trailing.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(inner.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(array.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct TopLevelStruct {
    pub a: crate::StructPaddingTestStruct,
    pub b: crate::NonInlineStructTestStruct,
}

impl ::fidl::Encode for TopLevelStruct {
    type Encoded<'buf> = WireTopLevelStruct<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<TopLevelStruct> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireTopLevelStruct<'buf>>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireTopLevelStruct<'buf>> for TopLevelStruct {
    fn take_from(from: &mut WireTopLevelStruct<'buf>) -> Self {
        Self {
            a: ::fidl::TakeFrom::take_from(&mut from.a),
            b: ::fidl::TakeFrom::take_from(&mut from.b),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireTopLevelStruct<'buf> {
    pub a: crate::WireStructPaddingTestStruct,
    pub b: crate::WireNonInlineStructTestStruct<'buf>,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireTopLevelStruct<'buf> {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
                mut b,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}
