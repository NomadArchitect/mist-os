// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

/// The type corresponding to the AnotherDiscoverableProtocol protocol.
#[derive(Debug)]
pub struct AnotherDiscoverableProtocol;

pub mod another_discoverable_protocol {}

/// A helper trait for the `AnotherDiscoverableProtocol` client sender.
pub trait AnotherDiscoverableProtocolClientSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> AnotherDiscoverableProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, AnotherDiscoverableProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A client handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for AnotherDiscoverableProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: AnotherDiscoverableProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `AnotherDiscoverableProtocol` server sender.
pub trait AnotherDiscoverableProtocolServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> AnotherDiscoverableProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, AnotherDiscoverableProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for AnotherDiscoverableProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: AnotherDiscoverableProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct ChannelProtocolMethodARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodARequest {
    type Encoded<'buf> = WireChannelProtocolMethodARequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodARequest
where
    i64: ::fidl_next::Encode<___E>,

    i64: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMethodARequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireChannelProtocolMethodARequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMethodARequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodARequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMethodARequest> for ChannelProtocolMethodARequest {
    fn take_from(from: &mut WireChannelProtocolMethodARequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&mut from.a),

            b: ::fidl_next::TakeFrom::take_from(&mut from.b),
        }
    }
}

/// The wire type corersponding to [`ChannelProtocolMethodARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodARequest {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodARequest
where
    ___D: ?Sized,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ChannelProtocolEventARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolEventARequest {
    type Encoded<'buf> = WireChannelProtocolEventARequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolEventARequest
where
    i64: ::fidl_next::Encode<___E>,

    i64: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolEventARequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireChannelProtocolEventARequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolEventARequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolEventARequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolEventARequest> for ChannelProtocolEventARequest {
    fn take_from(from: &mut WireChannelProtocolEventARequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&mut from.a),

            b: ::fidl_next::TakeFrom::take_from(&mut from.b),
        }
    }
}

/// The wire type corersponding to [`ChannelProtocolEventARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolEventARequest {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolEventARequest
where
    ___D: ?Sized,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ChannelProtocolMethodBRequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBRequest {
    type Encoded<'buf> = WireChannelProtocolMethodBRequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBRequest
where
    i64: ::fidl_next::Encode<___E>,

    i64: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMethodBRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireChannelProtocolMethodBRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMethodBRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMethodBRequest> for ChannelProtocolMethodBRequest {
    fn take_from(from: &mut WireChannelProtocolMethodBRequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&mut from.a),

            b: ::fidl_next::TakeFrom::take_from(&mut from.b),
        }
    }
}

/// The wire type corersponding to [`ChannelProtocolMethodBRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBRequest {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBRequest
where
    ___D: ?Sized,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ChannelProtocolMethodBResponse {
    pub result: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBResponse {
    type Encoded<'buf> = WireChannelProtocolMethodBResponse;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBResponse
where
    i64: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                result,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.result, encoder, result)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMethodBResponse> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireChannelProtocolMethodBResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMethodBResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMethodBResponse> for ChannelProtocolMethodBResponse {
    fn take_from(from: &mut WireChannelProtocolMethodBResponse) -> Self {
        Self { result: ::fidl_next::TakeFrom::take_from(&mut from.result) }
    }
}

/// The wire type corersponding to [`ChannelProtocolMethodBResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBResponse {
    pub result: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBResponse
where
    ___D: ?Sized,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut result,

            } = slot;
        }

        ::fidl_next::Decode::decode(result.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct ChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolTakeHandleRequest {
    type Encoded<'buf> = WireChannelProtocolTakeHandleRequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolTakeHandleRequest
where
    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolTakeHandleRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireChannelProtocolTakeHandleRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolTakeHandleRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolTakeHandleRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolTakeHandleRequest>
    for ChannelProtocolTakeHandleRequest
{
    fn take_from(from: &mut WireChannelProtocolTakeHandleRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&mut from.h) }
    }
}

/// The wire type corersponding to [`ChannelProtocolTakeHandleRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolTakeHandleRequest
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct ChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketRequest {
    type Encoded<'buf> = WireChannelProtocolMutateSocketRequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketRequest
where
    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMutateSocketRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireChannelProtocolMutateSocketRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMutateSocketRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMutateSocketRequest>
    for ChannelProtocolMutateSocketRequest
{
    fn take_from(from: &mut WireChannelProtocolMutateSocketRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

/// The wire type corersponding to [`ChannelProtocolMutateSocketRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketRequest
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct ChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketResponse {
    type Encoded<'buf> = WireChannelProtocolMutateSocketResponse;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketResponse
where
    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMutateSocketResponse> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireChannelProtocolMutateSocketResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMutateSocketResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMutateSocketResponse>
    for ChannelProtocolMutateSocketResponse
{
    fn take_from(from: &mut WireChannelProtocolMutateSocketResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&mut from.b) }
    }
}

/// The wire type corersponding to [`ChannelProtocolMutateSocketResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketResponse
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ChannelProtocol protocol.
#[derive(Debug)]
pub struct ChannelProtocol;

pub mod channel_protocol {

    pub struct MethodA;

    impl ::fidl_next::bind::Method for MethodA {
        const ORDINAL: u64 = 3155008840945527714;

        type Protocol = crate::ChannelProtocol;

        type Request<'buf> = crate::WireChannelProtocolMethodARequest;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct EventA;

    impl ::fidl_next::bind::Method for EventA {
        const ORDINAL: u64 = 2220452875311597006;

        type Protocol = crate::ChannelProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireChannelProtocolEventARequest;
    }

    pub struct MethodB;

    impl ::fidl_next::bind::Method for MethodB {
        const ORDINAL: u64 = 8903004957800778182;

        type Protocol = crate::ChannelProtocol;

        type Request<'buf> = crate::WireChannelProtocolMethodBRequest;

        type Response<'buf> = crate::WireChannelProtocolMethodBResponse;
    }

    pub struct TakeHandle;

    impl ::fidl_next::bind::Method for TakeHandle {
        const ORDINAL: u64 = 591935489944717925;

        type Protocol = crate::ChannelProtocol;

        type Request<'buf> = crate::WireChannelProtocolTakeHandleRequest;

        type Response<'buf> = ();
    }

    pub struct MutateSocket;

    impl ::fidl_next::bind::Method for MutateSocket {
        const ORDINAL: u64 = 7411742788430590287;

        type Protocol = crate::ChannelProtocol;

        type Request<'buf> = crate::WireChannelProtocolMutateSocketRequest;

        type Response<'buf> = crate::WireChannelProtocolMutateSocketResponse;
    }
}

/// A helper trait for the `ChannelProtocol` client sender.
pub trait ChannelProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn method_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolMethodARequest,
        >;

    fn method_b<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::MethodB>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolMethodBRequest,
        >;

    fn take_handle<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::TakeHandle>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolTakeHandleRequest,
        >;

    fn mutate_socket<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::MutateSocket>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolMutateSocketRequest,
        >;
}

impl<___T> ChannelProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, ChannelProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn method_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolMethodARequest,
        >,
    {
        self.as_untyped().send_one_way(3155008840945527714, request)
    }

    fn method_b<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::MethodB>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolMethodBRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8903004957800778182, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn take_handle<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::TakeHandle>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolTakeHandleRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(591935489944717925, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn mutate_socket<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::MutateSocket>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolMutateSocketRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(7411742788430590287, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn event_a(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, ChannelProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, channel_protocol::EventA>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for ChannelProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ChannelProtocolClientHandler<___T>,

    for<'buf> crate::WireChannelProtocolEventARequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireChannelProtocolMethodBResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireChannelProtocolMutateSocketResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            2220452875311597006 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_a(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ChannelProtocol` server sender.
pub trait ChannelProtocolServerSender<___T: ::fidl_next::protocol::Transport> {
    fn event_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolEventARequest,
        >;
}

impl<___T> ChannelProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, ChannelProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn event_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireChannelProtocolEventARequest,
        >,
    {
        self.as_untyped().send_event(2220452875311597006, request)
    }
}

/// A server handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn method_a(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, channel_protocol::MethodA>,
    );

    fn method_b(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, channel_protocol::MethodB>,

        responder: ::fidl_next::bind::Responder<channel_protocol::MethodB>,
    );

    fn take_handle(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, channel_protocol::TakeHandle>,

        responder: ::fidl_next::bind::Responder<channel_protocol::TakeHandle>,
    );

    fn mutate_socket(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, channel_protocol::MutateSocket>,

        responder: ::fidl_next::bind::Responder<channel_protocol::MutateSocket>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for ChannelProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ChannelProtocolServerHandler<___T>,

    for<'buf> crate::WireChannelProtocolMethodARequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireChannelProtocolMethodBRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireChannelProtocolTakeHandleRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireChannelProtocolMutateSocketRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3155008840945527714 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.method_a(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            8903004957800778182 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.method_b(sender, buffer, responder);
            }

            591935489944717925 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.take_handle(sender, buffer, responder);
            }

            7411742788430590287 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.mutate_socket(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the DiscoverableProtocol protocol.
#[derive(Debug)]
pub struct DiscoverableProtocol;

pub mod discoverable_protocol {

    pub struct Method;

    impl ::fidl_next::bind::Method for Method {
        const ORDINAL: u64 = 3455873048082739435;

        type Protocol = crate::DiscoverableProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }
}

/// A helper trait for the `DiscoverableProtocol` client sender.
pub trait DiscoverableProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn method(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;
}

impl<___T> DiscoverableProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, DiscoverableProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn method(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(3455873048082739435, &mut ())
    }
}

/// A client handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for DiscoverableProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: DiscoverableProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `DiscoverableProtocol` server sender.
pub trait DiscoverableProtocolServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> DiscoverableProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, DiscoverableProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn method(&mut self, sender: &::fidl_next::bind::ServerSender<___T, DiscoverableProtocol>);
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for DiscoverableProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: DiscoverableProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3455873048082739435 => {
                handler.method(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum ErrorEnum {
    ErrFoo = 1,
    ErrBar = 2,
}

impl ::fidl_next::Encodable for ErrorEnum {
    type Encoded<'buf> = WireErrorEnum;
}

impl<___E> ::fidl_next::Encode<___E> for ErrorEnum
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireErrorEnum { mut value } = slot);
        *value = ::fidl_next::u32_le::from(match *self {
            Self::ErrFoo => 1,

            Self::ErrBar => 2,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireErrorEnum> for ErrorEnum {
    fn from(wire: WireErrorEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::ErrFoo,

            2 => Self::ErrBar,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireErrorEnum> for ErrorEnum {
    fn take_from(from: &mut WireErrorEnum) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`ErrorEnum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireErrorEnum {
    value: ::fidl_next::u32_le,
}

impl WireErrorEnum {
    pub const ERR_FOO: WireErrorEnum = WireErrorEnum { value: ::fidl_next::u32_le::from_native(1) };

    pub const ERR_BAR: WireErrorEnum = WireErrorEnum { value: ::fidl_next::u32_le::from_native(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireErrorEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 | 2 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<ErrorEnum> for WireErrorEnum {
    fn from(natural: ErrorEnum) -> Self {
        match natural {
            ErrorEnum::ErrFoo => WireErrorEnum::ERR_FOO,

            ErrorEnum::ErrBar => WireErrorEnum::ERR_BAR,
        }
    }
}

#[derive(Debug)]
pub struct HandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolNoResponseMethodRequest {
    type Encoded<'buf> = WireHandleRightsProtocolNoResponseMethodRequest;
}

impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolNoResponseMethodRequest
where
    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolNoResponseMethodRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireHandleRightsProtocolNoResponseMethodRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolNoResponseMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolNoResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolNoResponseMethodRequest>
    for HandleRightsProtocolNoResponseMethodRequest
{
    fn take_from(from: &mut WireHandleRightsProtocolNoResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&mut from.h) }
    }
}

/// The wire type corersponding to [`HandleRightsProtocolNoResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolNoResponseMethodRequest
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct HandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodRequest {
    type Encoded<'buf> = WireHandleRightsProtocolResponseMethodRequest;
}

impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodRequest
where
    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolResponseMethodRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireHandleRightsProtocolResponseMethodRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolResponseMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolResponseMethodRequest>
    for HandleRightsProtocolResponseMethodRequest
{
    fn take_from(from: &mut WireHandleRightsProtocolResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&mut from.h) }
    }
}

/// The wire type corersponding to [`HandleRightsProtocolResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodRequest
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct HandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodResponse {
    type Encoded<'buf> = WireHandleRightsProtocolResponseMethodResponse;
}

impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodResponse
where
    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolResponseMethodResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireHandleRightsProtocolResponseMethodResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolResponseMethodResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolResponseMethodResponse>
    for HandleRightsProtocolResponseMethodResponse
{
    fn take_from(from: &mut WireHandleRightsProtocolResponseMethodResponse) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&mut from.h) }
    }
}

/// The wire type corersponding to [`HandleRightsProtocolResponseMethodResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodResponse
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct HandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolAnEventRequest {
    type Encoded<'buf> = WireHandleRightsProtocolAnEventRequest;
}

impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolAnEventRequest
where
    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolAnEventRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireHandleRightsProtocolAnEventRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolAnEventRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolAnEventRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolAnEventRequest>
    for HandleRightsProtocolAnEventRequest
{
    fn take_from(from: &mut WireHandleRightsProtocolAnEventRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&mut from.h) }
    }
}

/// The wire type corersponding to [`HandleRightsProtocolAnEventRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolAnEventRequest
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the HandleRightsProtocol protocol.
#[derive(Debug)]
pub struct HandleRightsProtocol;

pub mod handle_rights_protocol {

    pub struct NoResponseMethod;

    impl ::fidl_next::bind::Method for NoResponseMethod {
        const ORDINAL: u64 = 1155044649514904573;

        type Protocol = crate::HandleRightsProtocol;

        type Request<'buf> = crate::WireHandleRightsProtocolNoResponseMethodRequest;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct ResponseMethod;

    impl ::fidl_next::bind::Method for ResponseMethod {
        const ORDINAL: u64 = 5956276128041940295;

        type Protocol = crate::HandleRightsProtocol;

        type Request<'buf> = crate::WireHandleRightsProtocolResponseMethodRequest;

        type Response<'buf> = crate::WireHandleRightsProtocolResponseMethodResponse;
    }

    pub struct AnEvent;

    impl ::fidl_next::bind::Method for AnEvent {
        const ORDINAL: u64 = 476727631355490611;

        type Protocol = crate::HandleRightsProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireHandleRightsProtocolAnEventRequest;
    }
}

/// A helper trait for the `HandleRightsProtocol` client sender.
pub trait HandleRightsProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn no_response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireHandleRightsProtocolNoResponseMethodRequest,
        >;

    fn response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, handle_rights_protocol::ResponseMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireHandleRightsProtocolResponseMethodRequest,
        >;
}

impl<___T> HandleRightsProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, HandleRightsProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn no_response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireHandleRightsProtocolNoResponseMethodRequest,
        >,
    {
        self.as_untyped().send_one_way(1155044649514904573, request)
    }

    fn response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, handle_rights_protocol::ResponseMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireHandleRightsProtocolResponseMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(5956276128041940295, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn an_event(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, HandleRightsProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, handle_rights_protocol::AnEvent>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for HandleRightsProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: HandleRightsProtocolClientHandler<___T>,

    for<'buf> crate::WireHandleRightsProtocolResponseMethodResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireHandleRightsProtocolAnEventRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            476727631355490611 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.an_event(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `HandleRightsProtocol` server sender.
pub trait HandleRightsProtocolServerSender<___T: ::fidl_next::protocol::Transport> {
    fn an_event<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireHandleRightsProtocolAnEventRequest,
        >;
}

impl<___T> HandleRightsProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, HandleRightsProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn an_event<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireHandleRightsProtocolAnEventRequest,
        >,
    {
        self.as_untyped().send_event(476727631355490611, request)
    }
}

/// A server handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn no_response_method(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, HandleRightsProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, handle_rights_protocol::NoResponseMethod>,
    );

    fn response_method(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, HandleRightsProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, handle_rights_protocol::ResponseMethod>,

        responder: ::fidl_next::bind::Responder<handle_rights_protocol::ResponseMethod>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for HandleRightsProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: HandleRightsProtocolServerHandler<___T>,

    for<'buf> crate::WireHandleRightsProtocolNoResponseMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireHandleRightsProtocolResponseMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            1155044649514904573 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.no_response_method(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5956276128041940295 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.response_method(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct ManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

impl ::fidl_next::Encodable for ManyParametersFifteenRequest {
    type Encoded<'buf> = WireManyParametersFifteenRequest;
}

impl<___E> ::fidl_next::Encode<___E> for ManyParametersFifteenRequest
where
    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,

    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                p1,
                p2,
                p3,
                p4,
                p5,
                p6,
                p7,
                p8,
                p9,
                p10,
                p11,
                p12,
                p13,
                p14,
                p15,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.p1, encoder, p1)?;

        ::fidl_next::Encode::encode(&mut self.p2, encoder, p2)?;

        ::fidl_next::Encode::encode(&mut self.p3, encoder, p3)?;

        ::fidl_next::Encode::encode(&mut self.p4, encoder, p4)?;

        ::fidl_next::Encode::encode(&mut self.p5, encoder, p5)?;

        ::fidl_next::Encode::encode(&mut self.p6, encoder, p6)?;

        ::fidl_next::Encode::encode(&mut self.p7, encoder, p7)?;

        ::fidl_next::Encode::encode(&mut self.p8, encoder, p8)?;

        ::fidl_next::Encode::encode(&mut self.p9, encoder, p9)?;

        ::fidl_next::Encode::encode(&mut self.p10, encoder, p10)?;

        ::fidl_next::Encode::encode(&mut self.p11, encoder, p11)?;

        ::fidl_next::Encode::encode(&mut self.p12, encoder, p12)?;

        ::fidl_next::Encode::encode(&mut self.p13, encoder, p13)?;

        ::fidl_next::Encode::encode(&mut self.p14, encoder, p14)?;

        ::fidl_next::Encode::encode(&mut self.p15, encoder, p15)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ManyParametersFifteenRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireManyParametersFifteenRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ManyParametersFifteenRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ManyParametersFifteenRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireManyParametersFifteenRequest> for ManyParametersFifteenRequest {
    fn take_from(from: &mut WireManyParametersFifteenRequest) -> Self {
        Self {
            p1: ::fidl_next::TakeFrom::take_from(&mut from.p1),

            p2: ::fidl_next::TakeFrom::take_from(&mut from.p2),

            p3: ::fidl_next::TakeFrom::take_from(&mut from.p3),

            p4: ::fidl_next::TakeFrom::take_from(&mut from.p4),

            p5: ::fidl_next::TakeFrom::take_from(&mut from.p5),

            p6: ::fidl_next::TakeFrom::take_from(&mut from.p6),

            p7: ::fidl_next::TakeFrom::take_from(&mut from.p7),

            p8: ::fidl_next::TakeFrom::take_from(&mut from.p8),

            p9: ::fidl_next::TakeFrom::take_from(&mut from.p9),

            p10: ::fidl_next::TakeFrom::take_from(&mut from.p10),

            p11: ::fidl_next::TakeFrom::take_from(&mut from.p11),

            p12: ::fidl_next::TakeFrom::take_from(&mut from.p12),

            p13: ::fidl_next::TakeFrom::take_from(&mut from.p13),

            p14: ::fidl_next::TakeFrom::take_from(&mut from.p14),

            p15: ::fidl_next::TakeFrom::take_from(&mut from.p15),
        }
    }
}

/// The wire type corersponding to [`ManyParametersFifteenRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireManyParametersFifteenRequest
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut p1,
                mut p2,
                mut p3,
                mut p4,
                mut p5,
                mut p6,
                mut p7,
                mut p8,
                mut p9,
                mut p10,
                mut p11,
                mut p12,
                mut p13,
                mut p14,
                mut p15,

            } = slot;
        }

        ::fidl_next::Decode::decode(p1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p6.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p9.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p10.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p11.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p12.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p13.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p14.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p15.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ManyParameters protocol.
#[derive(Debug)]
pub struct ManyParameters;

pub mod many_parameters {

    pub struct Fifteen;

    impl ::fidl_next::bind::Method for Fifteen {
        const ORDINAL: u64 = 6423043252952467815;

        type Protocol = crate::ManyParameters;

        type Request<'buf> = crate::WireManyParametersFifteenRequest;

        type Response<'buf> = ::fidl_next::bind::Never;
    }
}

/// A helper trait for the `ManyParameters` client sender.
pub trait ManyParametersClientSender<___T: ::fidl_next::protocol::Transport> {
    fn fifteen<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireManyParametersFifteenRequest,
        >;
}

impl<___T> ManyParametersClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, ManyParameters>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn fifteen<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireManyParametersFifteenRequest,
        >,
    {
        self.as_untyped().send_one_way(6423043252952467815, request)
    }
}

/// A client handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for ManyParameters
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ManyParametersClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ManyParameters` server sender.
pub trait ManyParametersServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> ManyParametersServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, ManyParameters>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn fifteen(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ManyParameters>,

        request: ::fidl_next::bind::RequestBuffer<___T, many_parameters::Fifteen>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for ManyParameters
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ManyParametersServerHandler<___T>,

    for<'buf> crate::WireManyParametersFifteenRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6423043252952467815 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.fifteen(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum TheUnion {
    V(u32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for TheUnion {
    type Encoded<'buf> = WireTheUnion;
}

impl<___E> ::fidl_next::Encode<___E> for TheUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTheUnion { raw, _phantom: _ } = slot);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<TheUnion> {
    type EncodedOption<'buf> = WireOptionalTheUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<TheUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TheUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalTheUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTheUnion> for TheUnion {
    fn take_from(from: &mut WireTheUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::V(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalTheUnion> for Option<Box<TheUnion>> {
    fn take_from(from: &mut WireOptionalTheUnion) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`TheUnion`].
#[repr(transparent)]
pub struct WireTheUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod the_union {
    pub enum Ref<'union> {
        V(&'union ::fidl_next::u32_le),

        UnknownOrdinal_(u64),
    }

    pub enum Mut<'union> {
        V(&'union mut ::fidl_next::u32_le),

        UnknownOrdinal_(u64),
    }
}

impl WireTheUnion {
    pub fn as_ref(&self) -> crate::the_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::the_union::Ref::V(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::the_union::Ref::UnknownOrdinal_(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::the_union::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::the_union::Mut::V(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            unknown => crate::the_union::Mut::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireTheUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalTheUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalTheUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireTheUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireTheUnion> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireTheUnion> {
        if self.is_some() {
            Some(WireTheUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalTheUnion {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalTheUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalTheUnion {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct MethodWithUnionUnionMethodRequest {
    pub u: crate::TheUnion,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodRequest {
    type Encoded<'buf> = WireMethodWithUnionUnionMethodRequest;
}

impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodRequest
where
    crate::TheUnion: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<MethodWithUnionUnionMethodRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireMethodWithUnionUnionMethodRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<MethodWithUnionUnionMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireMethodWithUnionUnionMethodRequest>
    for MethodWithUnionUnionMethodRequest
{
    fn take_from(from: &mut WireMethodWithUnionUnionMethodRequest) -> Self {
        Self { u: ::fidl_next::TakeFrom::take_from(&mut from.u) }
    }
}

/// The wire type corersponding to [`MethodWithUnionUnionMethodRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodRequest {
    pub u: crate::WireTheUnion,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodRequest
where
    ___D: ?Sized,

    crate::WireTheUnion: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct MethodWithUnionUnionMethodResponse {
    pub u: Option<Box<crate::TheUnion>>,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodResponse {
    type Encoded<'buf> = WireMethodWithUnionUnionMethodResponse;
}

impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodResponse
where
    Option<Box<crate::TheUnion>>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<MethodWithUnionUnionMethodResponse> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireMethodWithUnionUnionMethodResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<MethodWithUnionUnionMethodResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireMethodWithUnionUnionMethodResponse>
    for MethodWithUnionUnionMethodResponse
{
    fn take_from(from: &mut WireMethodWithUnionUnionMethodResponse) -> Self {
        Self { u: ::fidl_next::TakeFrom::take_from(&mut from.u) }
    }
}

/// The wire type corersponding to [`MethodWithUnionUnionMethodResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodResponse {
    pub u: crate::WireOptionalTheUnion,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodResponse
where
    ___D: ?Sized,

    crate::WireOptionalTheUnion: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the MethodWithUnion protocol.
#[derive(Debug)]
pub struct MethodWithUnion;

pub mod method_with_union {

    pub struct UnionMethod;

    impl ::fidl_next::bind::Method for UnionMethod {
        const ORDINAL: u64 = 4124874338266649112;

        type Protocol = crate::MethodWithUnion;

        type Request<'buf> = crate::WireMethodWithUnionUnionMethodRequest;

        type Response<'buf> = crate::WireMethodWithUnionUnionMethodResponse;
    }
}

/// A helper trait for the `MethodWithUnion` client sender.
pub trait MethodWithUnionClientSender<___T: ::fidl_next::protocol::Transport> {
    fn union_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, method_with_union::UnionMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireMethodWithUnionUnionMethodRequest,
        >;
}

impl<___T> MethodWithUnionClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, MethodWithUnion>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn union_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, method_with_union::UnionMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireMethodWithUnionUnionMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(4124874338266649112, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for MethodWithUnion
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: MethodWithUnionClientHandler<___T>,

    for<'buf> crate::WireMethodWithUnionUnionMethodResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `MethodWithUnion` server sender.
pub trait MethodWithUnionServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> MethodWithUnionServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, MethodWithUnion>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn union_method(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, MethodWithUnion>,

        request: ::fidl_next::bind::RequestBuffer<___T, method_with_union::UnionMethod>,

        responder: ::fidl_next::bind::Responder<method_with_union::UnionMethod>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for MethodWithUnion
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: MethodWithUnionServerHandler<___T>,

    for<'buf> crate::WireMethodWithUnionUnionMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            4124874338266649112 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.union_method(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the PlatformServer protocol.
#[derive(Debug)]
pub struct PlatformServer;

pub mod platform_server {}

/// A helper trait for the `PlatformServer` client sender.
pub trait PlatformServerClientSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> PlatformServerClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, PlatformServer>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A client handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for PlatformServer
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: PlatformServerClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `PlatformServer` server sender.
pub trait PlatformServerServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> PlatformServerServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, PlatformServer>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerServerHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for PlatformServer
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: PlatformServerServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
pub struct ProtocolEnds {
    pub client: ::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::DiscoverableProtocol>,

    pub server: ::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::DiscoverableProtocol>,

    pub client_opt:
        ::fidl_next::bind::ClientEnd<Option<::fidl_next::zx::Handle>, crate::DiscoverableProtocol>,

    pub server_opt:
        ::fidl_next::bind::ServerEnd<Option<::fidl_next::zx::Handle>, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for ProtocolEnds {
    type Encoded<'buf> = WireProtocolEnds;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolEnds
where
    ::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::DiscoverableProtocol>:
        ::fidl_next::Encode<___E>,

    ::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::DiscoverableProtocol>:
        ::fidl_next::Encode<___E>,

    ::fidl_next::bind::ClientEnd<Option<::fidl_next::zx::Handle>, crate::DiscoverableProtocol>:
        ::fidl_next::Encode<___E>,

    ::fidl_next::bind::ServerEnd<Option<::fidl_next::zx::Handle>, crate::DiscoverableProtocol>:
        ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                client,
                server,
                client_opt,
                server_opt,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.client, encoder, client)?;

        ::fidl_next::Encode::encode(&mut self.server, encoder, server)?;

        ::fidl_next::Encode::encode(&mut self.client_opt, encoder, client_opt)?;

        ::fidl_next::Encode::encode(&mut self.server_opt, encoder, server_opt)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolEnds> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireProtocolEnds>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolEnds>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolEnds: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolEnds> for ProtocolEnds {
    fn take_from(from: &mut WireProtocolEnds) -> Self {
        Self {
            client: ::fidl_next::TakeFrom::take_from(&mut from.client),

            server: ::fidl_next::TakeFrom::take_from(&mut from.server),

            client_opt: ::fidl_next::TakeFrom::take_from(&mut from.client_opt),

            server_opt: ::fidl_next::TakeFrom::take_from(&mut from.server_opt),
        }
    }
}

/// The wire type corersponding to [`ProtocolEnds`].
#[derive(Debug)]
#[repr(C)]
pub struct WireProtocolEnds {
    pub client: ::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::DiscoverableProtocol>,

    pub server: ::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::DiscoverableProtocol>,

    pub client_opt:
        ::fidl_next::bind::ClientEnd<::fidl_next::WireOptionalHandle, crate::DiscoverableProtocol>,

    pub server_opt:
        ::fidl_next::bind::ServerEnd<::fidl_next::WireOptionalHandle, crate::DiscoverableProtocol>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireProtocolEnds
where
    ___D: ?Sized,

    ::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::DiscoverableProtocol>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::DiscoverableProtocol>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::bind::ClientEnd<::fidl_next::WireOptionalHandle, crate::DiscoverableProtocol>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::bind::ServerEnd<::fidl_next::WireOptionalHandle, crate::DiscoverableProtocol>:
        ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut client,
                mut server,
                mut client_opt,
                mut server_opt,

            } = slot;
        }

        ::fidl_next::Decode::decode(client.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_opt.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_opt.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct SyscallProtocolMethodCRequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for SyscallProtocolMethodCRequest {
    type Encoded<'buf> = WireSyscallProtocolMethodCRequest;
}

impl<___E> ::fidl_next::Encode<___E> for SyscallProtocolMethodCRequest
where
    i64: ::fidl_next::Encode<___E>,

    i64: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SyscallProtocolMethodCRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireSyscallProtocolMethodCRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<SyscallProtocolMethodCRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SyscallProtocolMethodCRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSyscallProtocolMethodCRequest> for SyscallProtocolMethodCRequest {
    fn take_from(from: &mut WireSyscallProtocolMethodCRequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&mut from.a),

            b: ::fidl_next::TakeFrom::take_from(&mut from.b),
        }
    }
}

/// The wire type corersponding to [`SyscallProtocolMethodCRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireSyscallProtocolMethodCRequest {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSyscallProtocolMethodCRequest
where
    ___D: ?Sized,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the SyscallProtocol protocol.
#[derive(Debug)]
pub struct SyscallProtocol;

pub mod syscall_protocol {

    pub struct MethodC;

    impl ::fidl_next::bind::Method for MethodC {
        const ORDINAL: u64 = 1468025868259603279;

        type Protocol = crate::SyscallProtocol;

        type Request<'buf> = crate::WireSyscallProtocolMethodCRequest;

        type Response<'buf> = ::fidl_next::bind::Never;
    }
}

/// A helper trait for the `SyscallProtocol` client sender.
pub trait SyscallProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn method_c<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireSyscallProtocolMethodCRequest,
        >;
}

impl<___T> SyscallProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, SyscallProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn method_c<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireSyscallProtocolMethodCRequest,
        >,
    {
        self.as_untyped().send_one_way(1468025868259603279, request)
    }
}

/// A client handler for the SyscallProtocol protocol.
///
/// See [`SyscallProtocol`] for more details.
pub trait SyscallProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for SyscallProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: SyscallProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `SyscallProtocol` server sender.
pub trait SyscallProtocolServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> SyscallProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, SyscallProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the SyscallProtocol protocol.
///
/// See [`SyscallProtocol`] for more details.
pub trait SyscallProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn method_c(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, SyscallProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, syscall_protocol::MethodC>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for SyscallProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: SyscallProtocolServerHandler<___T>,

    for<'buf> crate::WireSyscallProtocolMethodCRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            1468025868259603279 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.method_c(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    type Encoded<'buf> = WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseNoRequestWithResponseResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'buf>,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseNoRequestWithResponseResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseNoRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'buf>>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
{
    fn take_from(
        from: &mut WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'buf>,
    ) -> Self {
        Self { ret: ::fidl_next::TakeFrom::take_from(&mut from.ret) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseNoRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'buf> {
    pub ret: ::fidl_next::WireString<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    type Encoded<'buf> = WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestNoResponseRequest>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'buf>,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestNoResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestNoResponseRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'buf>>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
{
    fn take_from(
        from: &mut WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'buf>,
    ) -> Self {
        Self { arg: ::fidl_next::TakeFrom::take_from(&mut from.arg) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseWithRequestNoResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'buf> {
    pub arg: ::fidl_next::WireString<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    type Encoded<'buf> = WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'buf>,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'buf>>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
{
    fn take_from(
        from: &mut WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'buf>,
    ) -> Self {
        Self { arg: ::fidl_next::TakeFrom::take_from(&mut from.arg) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseWithRequestEmptyResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'buf> {
    pub arg: ::fidl_next::WireString<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    type Encoded<'buf> = WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseRequest>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'buf>,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'buf>>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
{
    fn take_from(
        from: &mut WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'buf>,
    ) -> Self {
        Self { arg: ::fidl_next::TakeFrom::take_from(&mut from.arg) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseWithRequestWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'buf> {
    pub arg: ::fidl_next::WireString<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    type Encoded<'buf> = WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'buf>,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'buf>>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
{
    fn take_from(
        from: &mut WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'buf>,
    ) -> Self {
        Self { ret: ::fidl_next::TakeFrom::take_from(&mut from.ret) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseWithRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'buf> {
    pub ret: ::fidl_next::WireString<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseOnWithResponseRequest {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseOnWithResponseRequest {
    type Encoded<'buf> = WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseOnWithResponseRequest
where
    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithAndWithoutRequestResponseOnWithResponseRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseOnWithResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseOnWithResponseRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf>>
    for WithAndWithoutRequestResponseOnWithResponseRequest
{
    fn take_from(from: &mut WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf>) -> Self {
        Self { ret: ::fidl_next::TakeFrom::take_from(&mut from.ret) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseOnWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf> {
    pub ret: ::fidl_next::WireString<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithAndWithoutRequestResponse protocol.
#[derive(Debug)]
pub struct WithAndWithoutRequestResponse;

pub mod with_and_without_request_response {

    pub struct NoRequestNoResponse;

    impl ::fidl_next::bind::Method for NoRequestNoResponse {
        const ORDINAL: u64 = 5413654872775949227;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct NoRequestEmptyResponse;

    impl ::fidl_next::bind::Method for NoRequestEmptyResponse {
        const ORDINAL: u64 = 1631193469798418024;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request<'buf> = ();

        type Response<'buf> = ();
    }

    pub struct NoRequestWithResponse;

    impl ::fidl_next::bind::Method for NoRequestWithResponse {
        const ORDINAL: u64 = 9037369643591427517;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'buf>;
    }

    pub struct WithRequestNoResponse;

    impl ::fidl_next::bind::Method for WithRequestNoResponse {
        const ORDINAL: u64 = 7326057319832554103;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request<'buf> =
            crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct WithRequestEmptyResponse;

    impl ::fidl_next::bind::Method for WithRequestEmptyResponse {
        const ORDINAL: u64 = 2877322062572412767;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request<'buf> =
            crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'buf>;

        type Response<'buf> = ();
    }

    pub struct WithRequestWithResponse;

    impl ::fidl_next::bind::Method for WithRequestWithResponse {
        const ORDINAL: u64 = 6417226585456833969;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request<'buf> =
            crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'buf>;

        type Response<'buf> =
            crate::WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'buf>;
    }

    pub struct OnEmptyResponse;

    impl ::fidl_next::bind::Method for OnEmptyResponse {
        const ORDINAL: u64 = 5397663296507358806;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = ();
    }

    pub struct OnWithResponse;

    impl ::fidl_next::bind::Method for OnWithResponse {
        const ORDINAL: u64 = 5811598563493228968;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf>;
    }
}

/// A helper trait for the `WithAndWithoutRequestResponse` client sender.
pub trait WithAndWithoutRequestResponseClientSender<___T: ::fidl_next::protocol::Transport> {
    fn no_request_no_response(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn no_request_empty_response(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >;

    fn no_request_with_response(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::NoRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >;

    fn with_request_no_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<
                'buf,
            >,
        >;

    fn with_request_empty_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<
                'buf,
            >,
        >;

    fn with_request_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::WithRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<
                'buf,
            >,
        >;
}

impl<___T> WithAndWithoutRequestResponseClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, WithAndWithoutRequestResponse>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn no_request_no_response(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(5413654872775949227, &mut ())
    }

    fn no_request_empty_response(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1631193469798418024, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn no_request_with_response(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::NoRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9037369643591427517, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn with_request_no_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<
                'buf,
            >,
        >,
    {
        self.as_untyped().send_one_way(7326057319832554103, request)
    }

    fn with_request_empty_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<
                'buf,
            >,
        >,
    {
        self.as_untyped()
            .send_two_way(2877322062572412767, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn with_request_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::WithRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<
                'buf,
            >,
        >,
    {
        self.as_untyped()
            .send_two_way(6417226585456833969, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn on_empty_response(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, WithAndWithoutRequestResponse>,
    );

    fn on_with_response(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, WithAndWithoutRequestResponse>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            with_and_without_request_response::OnWithResponse,
        >,
    );
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for WithAndWithoutRequestResponse
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithAndWithoutRequestResponseClientHandler<___T>,

    for<'buf> crate::WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5397663296507358806 => {
                handler.on_empty_response(sender);
            }

            5811598563493228968 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.on_with_response(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithAndWithoutRequestResponse` server sender.
pub trait WithAndWithoutRequestResponseServerSender<___T: ::fidl_next::protocol::Transport> {
    fn on_empty_response(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn on_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf>,
        >;
}

impl<___T> WithAndWithoutRequestResponseServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn on_empty_response(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(5397663296507358806, &mut ())
    }

    fn on_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest<'buf>,
        >,
    {
        self.as_untyped().send_event(5811598563493228968, request)
    }
}

/// A server handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn no_request_no_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,
    );

    fn no_request_empty_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        responder: ::fidl_next::bind::Responder<
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
    );

    fn no_request_with_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        responder: ::fidl_next::bind::Responder<
            with_and_without_request_response::NoRequestWithResponse,
        >,
    );

    fn with_request_no_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::bind::RequestBuffer<
            ___T,
            with_and_without_request_response::WithRequestNoResponse,
        >,
    );

    fn with_request_empty_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::bind::RequestBuffer<
            ___T,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,

        responder: ::fidl_next::bind::Responder<
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
    );

    fn with_request_with_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::bind::RequestBuffer<
            ___T,
            with_and_without_request_response::WithRequestWithResponse,
        >,

        responder: ::fidl_next::bind::Responder<
            with_and_without_request_response::WithRequestWithResponse,
        >,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for WithAndWithoutRequestResponse
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithAndWithoutRequestResponseServerHandler<___T>,

    for<'buf> crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5413654872775949227 => {
                handler.no_request_no_response(sender);
            }

            7326057319832554103 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.with_request_no_response(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            1631193469798418024 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.no_request_empty_response(sender, responder);
            }

            9037369643591427517 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.no_request_with_response(sender, responder);
            }

            2877322062572412767 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.with_request_empty_response(sender, buffer, responder);
            }

            6417226585456833969 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.with_request_with_response(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct WithErrorSyntaxResponseAsStructResponse {
    pub a: i64,

    pub b: i64,

    pub c: i64,
}

impl ::fidl_next::Encodable for WithErrorSyntaxResponseAsStructResponse {
    type Encoded<'buf> = WireWithErrorSyntaxResponseAsStructResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxResponseAsStructResponse
where
    i64: ::fidl_next::Encode<___E>,

    i64: ::fidl_next::Encode<___E>,

    i64: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        ::fidl_next::Encode::encode(&mut self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxResponseAsStructResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireWithErrorSyntaxResponseAsStructResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxResponseAsStructResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxResponseAsStructResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxResponseAsStructResponse>
    for WithErrorSyntaxResponseAsStructResponse
{
    fn take_from(from: &mut WireWithErrorSyntaxResponseAsStructResponse) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&mut from.a),

            b: ::fidl_next::TakeFrom::take_from(&mut from.b),

            c: ::fidl_next::TakeFrom::take_from(&mut from.c),
        }
    }
}

/// The wire type corersponding to [`WithErrorSyntaxResponseAsStructResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxResponseAsStructResponse {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,

    pub c: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxResponseAsStructResponse
where
    ___D: ?Sized,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum WithErrorSyntaxResponseAsStructResult {
    Response(crate::WithErrorSyntaxResponseAsStructResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for WithErrorSyntaxResponseAsStructResult {
    type Encoded<'buf> = WireWithErrorSyntaxResponseAsStructResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxResponseAsStructResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::WithErrorSyntaxResponseAsStructResponse: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireWithErrorSyntaxResponseAsStructResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::WithErrorSyntaxResponseAsStructResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxResponseAsStructResult> {
    type EncodedOption<'buf> = WireOptionalWithErrorSyntaxResponseAsStructResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxResponseAsStructResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxResponseAsStructResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalWithErrorSyntaxResponseAsStructResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireWithErrorSyntaxResponseAsStructResult<'buf>>
    for WithErrorSyntaxResponseAsStructResult
{
    fn take_from(from: &mut WireWithErrorSyntaxResponseAsStructResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalWithErrorSyntaxResponseAsStructResult<'buf>>
    for Option<Box<WithErrorSyntaxResponseAsStructResult>>
{
    fn take_from(from: &mut WireOptionalWithErrorSyntaxResponseAsStructResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxResponseAsStructResult`].
#[repr(transparent)]
pub struct WireWithErrorSyntaxResponseAsStructResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod with_error_syntax_response_as_struct_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireWithErrorSyntaxResponseAsStructResponse),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireWithErrorSyntaxResponseAsStructResponse),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireWithErrorSyntaxResponseAsStructResult<'buf> {
    pub fn as_ref(&self) -> crate::with_error_syntax_response_as_struct_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_response_as_struct_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::with_error_syntax_response_as_struct_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::with_error_syntax_response_as_struct_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_response_as_struct_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::with_error_syntax_response_as_struct_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireWithErrorSyntaxResponseAsStructResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireWithErrorSyntaxResponseAsStructResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireWithErrorSyntaxResponseAsStructResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireWithErrorSyntaxResponseAsStructResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireWithErrorSyntaxResponseAsStructResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalWithErrorSyntaxResponseAsStructResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalWithErrorSyntaxResponseAsStructResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireWithErrorSyntaxResponseAsStructResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireWithErrorSyntaxResponseAsStructResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireWithErrorSyntaxResponseAsStructResult<'buf>> {
        if self.is_some() {
            Some(WireWithErrorSyntaxResponseAsStructResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalWithErrorSyntaxResponseAsStructResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalWithErrorSyntaxResponseAsStructResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireWithErrorSyntaxResponseAsStructResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireWithErrorSyntaxResponseAsStructResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalWithErrorSyntaxResponseAsStructResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct WithErrorSyntaxErrorAsPrimitiveResponse {}

impl ::fidl_next::Encodable for WithErrorSyntaxErrorAsPrimitiveResponse {
    type Encoded<'buf> = WireWithErrorSyntaxErrorAsPrimitiveResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxErrorAsPrimitiveResponse {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxErrorAsPrimitiveResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireWithErrorSyntaxErrorAsPrimitiveResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxErrorAsPrimitiveResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxErrorAsPrimitiveResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxErrorAsPrimitiveResponse>
    for WithErrorSyntaxErrorAsPrimitiveResponse
{
    fn take_from(from: &mut WireWithErrorSyntaxErrorAsPrimitiveResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`WithErrorSyntaxErrorAsPrimitiveResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxErrorAsPrimitiveResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxErrorAsPrimitiveResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum WithErrorSyntaxErrorAsPrimitiveResult {
    Response(crate::WithErrorSyntaxErrorAsPrimitiveResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for WithErrorSyntaxErrorAsPrimitiveResult {
    type Encoded<'buf> = WireWithErrorSyntaxErrorAsPrimitiveResult;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxErrorAsPrimitiveResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::WithErrorSyntaxErrorAsPrimitiveResponse: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireWithErrorSyntaxErrorAsPrimitiveResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::WithErrorSyntaxErrorAsPrimitiveResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxErrorAsPrimitiveResult> {
    type EncodedOption<'buf> = WireOptionalWithErrorSyntaxErrorAsPrimitiveResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxErrorAsPrimitiveResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxErrorAsPrimitiveResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalWithErrorSyntaxErrorAsPrimitiveResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxErrorAsPrimitiveResult>
    for WithErrorSyntaxErrorAsPrimitiveResult
{
    fn take_from(from: &mut WireWithErrorSyntaxErrorAsPrimitiveResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalWithErrorSyntaxErrorAsPrimitiveResult>
    for Option<Box<WithErrorSyntaxErrorAsPrimitiveResult>>
{
    fn take_from(from: &mut WireOptionalWithErrorSyntaxErrorAsPrimitiveResult) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxErrorAsPrimitiveResult`].
#[repr(transparent)]
pub struct WireWithErrorSyntaxErrorAsPrimitiveResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod with_error_syntax_error_as_primitive_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireWithErrorSyntaxErrorAsPrimitiveResponse),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireWithErrorSyntaxErrorAsPrimitiveResponse),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl WireWithErrorSyntaxErrorAsPrimitiveResult {
    pub fn as_ref(&self) -> crate::with_error_syntax_error_as_primitive_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_error_as_primitive_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::with_error_syntax_error_as_primitive_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::with_error_syntax_error_as_primitive_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_error_as_primitive_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::with_error_syntax_error_as_primitive_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireWithErrorSyntaxErrorAsPrimitiveResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireWithErrorSyntaxErrorAsPrimitiveResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireWithErrorSyntaxErrorAsPrimitiveResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder,

    crate::WireWithErrorSyntaxErrorAsPrimitiveResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxErrorAsPrimitiveResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireWithErrorSyntaxErrorAsPrimitiveResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireWithErrorSyntaxErrorAsPrimitiveResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireWithErrorSyntaxErrorAsPrimitiveResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireWithErrorSyntaxErrorAsPrimitiveResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireWithErrorSyntaxErrorAsPrimitiveResult> {
        if self.is_some() {
            Some(WireWithErrorSyntaxErrorAsPrimitiveResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireWithErrorSyntaxErrorAsPrimitiveResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalWithErrorSyntaxErrorAsPrimitiveResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder,

    crate::WireWithErrorSyntaxErrorAsPrimitiveResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxErrorAsPrimitiveResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct WithErrorSyntaxErrorAsEnumResponse {}

impl ::fidl_next::Encodable for WithErrorSyntaxErrorAsEnumResponse {
    type Encoded<'buf> = WireWithErrorSyntaxErrorAsEnumResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxErrorAsEnumResponse {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxErrorAsEnumResponse> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireWithErrorSyntaxErrorAsEnumResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxErrorAsEnumResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxErrorAsEnumResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxErrorAsEnumResponse>
    for WithErrorSyntaxErrorAsEnumResponse
{
    fn take_from(from: &mut WireWithErrorSyntaxErrorAsEnumResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`WithErrorSyntaxErrorAsEnumResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxErrorAsEnumResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxErrorAsEnumResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum WithErrorSyntaxErrorAsEnumResult {
    Response(crate::WithErrorSyntaxErrorAsEnumResponse),

    Err(crate::ErrorEnum),
}

impl ::fidl_next::Encodable for WithErrorSyntaxErrorAsEnumResult {
    type Encoded<'buf> = WireWithErrorSyntaxErrorAsEnumResult;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxErrorAsEnumResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::WithErrorSyntaxErrorAsEnumResponse: ::fidl_next::Encode<___E>,

    crate::ErrorEnum: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireWithErrorSyntaxErrorAsEnumResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::WithErrorSyntaxErrorAsEnumResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => ::fidl_next::RawWireUnion::encode_as::<___E, crate::ErrorEnum>(
                value, 2, encoder, raw,
            )?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxErrorAsEnumResult> {
    type EncodedOption<'buf> = WireOptionalWithErrorSyntaxErrorAsEnumResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxErrorAsEnumResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxErrorAsEnumResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalWithErrorSyntaxErrorAsEnumResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxErrorAsEnumResult>
    for WithErrorSyntaxErrorAsEnumResult
{
    fn take_from(from: &mut WireWithErrorSyntaxErrorAsEnumResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalWithErrorSyntaxErrorAsEnumResult>
    for Option<Box<WithErrorSyntaxErrorAsEnumResult>>
{
    fn take_from(from: &mut WireOptionalWithErrorSyntaxErrorAsEnumResult) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxErrorAsEnumResult`].
#[repr(transparent)]
pub struct WireWithErrorSyntaxErrorAsEnumResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod with_error_syntax_error_as_enum_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireWithErrorSyntaxErrorAsEnumResponse),

        Err(&'union crate::WireErrorEnum),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireWithErrorSyntaxErrorAsEnumResponse),

        Err(&'union mut crate::WireErrorEnum),
    }
}

impl WireWithErrorSyntaxErrorAsEnumResult {
    pub fn as_ref(&self) -> crate::with_error_syntax_error_as_enum_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_error_as_enum_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::with_error_syntax_error_as_enum_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::with_error_syntax_error_as_enum_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_error_as_enum_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::with_error_syntax_error_as_enum_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireWithErrorSyntaxErrorAsEnumResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireWithErrorSyntaxErrorAsEnumResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<crate::WireErrorEnum>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireWithErrorSyntaxErrorAsEnumResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder,

    crate::WireWithErrorSyntaxErrorAsEnumResponse: ::fidl_next::Decode<___D>,

    crate::WireErrorEnum: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxErrorAsEnumResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireErrorEnum>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireWithErrorSyntaxErrorAsEnumResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireWithErrorSyntaxErrorAsEnumResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WireErrorEnum>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalWithErrorSyntaxErrorAsEnumResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalWithErrorSyntaxErrorAsEnumResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireWithErrorSyntaxErrorAsEnumResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireWithErrorSyntaxErrorAsEnumResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireWithErrorSyntaxErrorAsEnumResult> {
        if self.is_some() {
            Some(WireWithErrorSyntaxErrorAsEnumResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalWithErrorSyntaxErrorAsEnumResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalWithErrorSyntaxErrorAsEnumResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalWithErrorSyntaxErrorAsEnumResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireWithErrorSyntaxErrorAsEnumResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<crate::WireErrorEnum>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalWithErrorSyntaxErrorAsEnumResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder,

    crate::WireWithErrorSyntaxErrorAsEnumResponse: ::fidl_next::Decode<___D>,

    crate::WireErrorEnum: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxErrorAsEnumResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireErrorEnum>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalWithErrorSyntaxErrorAsEnumResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Debug)]
pub struct WithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::zx::Handle,
}

impl ::fidl_next::Encodable for WithErrorSyntaxHandleInResultResponse {
    type Encoded<'buf> = WireWithErrorSyntaxHandleInResultResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxHandleInResultResponse
where
    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxHandleInResultResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireWithErrorSyntaxHandleInResultResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxHandleInResultResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxHandleInResultResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxHandleInResultResponse>
    for WithErrorSyntaxHandleInResultResponse
{
    fn take_from(from: &mut WireWithErrorSyntaxHandleInResultResponse) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&mut from.h) }
    }
}

/// The wire type corersponding to [`WithErrorSyntaxHandleInResultResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxHandleInResultResponse
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub enum WithErrorSyntaxHandleInResultResult {
    Response(crate::WithErrorSyntaxHandleInResultResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for WithErrorSyntaxHandleInResultResult {
    type Encoded<'buf> = WireWithErrorSyntaxHandleInResultResult;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxHandleInResultResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::WithErrorSyntaxHandleInResultResponse: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireWithErrorSyntaxHandleInResultResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::WithErrorSyntaxHandleInResultResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxHandleInResultResult> {
    type EncodedOption<'buf> = WireOptionalWithErrorSyntaxHandleInResultResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxHandleInResultResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxHandleInResultResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalWithErrorSyntaxHandleInResultResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxHandleInResultResult>
    for WithErrorSyntaxHandleInResultResult
{
    fn take_from(from: &mut WireWithErrorSyntaxHandleInResultResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalWithErrorSyntaxHandleInResultResult>
    for Option<Box<WithErrorSyntaxHandleInResultResult>>
{
    fn take_from(from: &mut WireOptionalWithErrorSyntaxHandleInResultResult) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxHandleInResultResult`].
#[repr(transparent)]
pub struct WireWithErrorSyntaxHandleInResultResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod with_error_syntax_handle_in_result_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireWithErrorSyntaxHandleInResultResponse),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireWithErrorSyntaxHandleInResultResponse),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl WireWithErrorSyntaxHandleInResultResult {
    pub fn as_ref(&self) -> crate::with_error_syntax_handle_in_result_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_handle_in_result_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::with_error_syntax_handle_in_result_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::with_error_syntax_handle_in_result_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_handle_in_result_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::with_error_syntax_handle_in_result_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireWithErrorSyntaxHandleInResultResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder,

    crate::WireWithErrorSyntaxHandleInResultResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxHandleInResultResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireWithErrorSyntaxHandleInResultResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireWithErrorSyntaxHandleInResultResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalWithErrorSyntaxHandleInResultResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalWithErrorSyntaxHandleInResultResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireWithErrorSyntaxHandleInResultResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireWithErrorSyntaxHandleInResultResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireWithErrorSyntaxHandleInResultResult> {
        if self.is_some() {
            Some(WireWithErrorSyntaxHandleInResultResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalWithErrorSyntaxHandleInResultResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalWithErrorSyntaxHandleInResultResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder,

    crate::WireWithErrorSyntaxHandleInResultResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxHandleInResultResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalWithErrorSyntaxHandleInResultResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the WithErrorSyntax protocol.
#[derive(Debug)]
pub struct WithErrorSyntax;

pub mod with_error_syntax {

    pub struct ResponseAsStruct;

    impl ::fidl_next::bind::Method for ResponseAsStruct {
        const ORDINAL: u64 = 268248568430741139;

        type Protocol = crate::WithErrorSyntax;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireWithErrorSyntaxResponseAsStructResult<'buf>;
    }

    pub struct ErrorAsPrimitive;

    impl ::fidl_next::bind::Method for ErrorAsPrimitive {
        const ORDINAL: u64 = 6930994461233198567;

        type Protocol = crate::WithErrorSyntax;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireWithErrorSyntaxErrorAsPrimitiveResult;
    }

    pub struct ErrorAsEnum;

    impl ::fidl_next::bind::Method for ErrorAsEnum {
        const ORDINAL: u64 = 5491891352371277635;

        type Protocol = crate::WithErrorSyntax;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireWithErrorSyntaxErrorAsEnumResult;
    }

    pub struct HandleInResult;

    impl ::fidl_next::bind::Method for HandleInResult {
        const ORDINAL: u64 = 1371676333068455103;

        type Protocol = crate::WithErrorSyntax;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireWithErrorSyntaxHandleInResultResult;
    }
}

/// A helper trait for the `WithErrorSyntax` client sender.
pub trait WithErrorSyntaxClientSender<___T: ::fidl_next::protocol::Transport> {
    fn response_as_struct(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ResponseAsStruct>,
        ::fidl_next::EncodeError,
    >;

    fn error_as_primitive(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ErrorAsPrimitive>,
        ::fidl_next::EncodeError,
    >;

    fn error_as_enum(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ErrorAsEnum>,
        ::fidl_next::EncodeError,
    >;

    fn handle_in_result(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::HandleInResult>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> WithErrorSyntaxClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, WithErrorSyntax>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn response_as_struct(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ResponseAsStruct>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(268248568430741139, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_as_primitive(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ErrorAsPrimitive>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6930994461233198567, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_as_enum(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ErrorAsEnum>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5491891352371277635, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn handle_in_result(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::HandleInResult>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1371676333068455103, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for WithErrorSyntax
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithErrorSyntaxClientHandler<___T>,

    for<'buf> crate::WireWithErrorSyntaxResponseAsStructResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithErrorSyntaxErrorAsPrimitiveResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithErrorSyntaxErrorAsEnumResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithErrorSyntaxHandleInResultResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithErrorSyntax` server sender.
pub trait WithErrorSyntaxServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> WithErrorSyntaxServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, WithErrorSyntax>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn response_as_struct(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::bind::Responder<with_error_syntax::ResponseAsStruct>,
    );

    fn error_as_primitive(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::bind::Responder<with_error_syntax::ErrorAsPrimitive>,
    );

    fn error_as_enum(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::bind::Responder<with_error_syntax::ErrorAsEnum>,
    );

    fn handle_in_result(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::bind::Responder<with_error_syntax::HandleInResult>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for WithErrorSyntax
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithErrorSyntaxServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            268248568430741139 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.response_as_struct(sender, responder);
            }

            6930994461233198567 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_as_primitive(sender, responder);
            }

            5491891352371277635 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_as_enum(sender, responder);
            }

            1371676333068455103 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.handle_in_result(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsClientEndsRequest {
    pub in_: ::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsRequest {
    type Encoded<'buf> = WireWithProtocolEndsClientEndsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsRequest
where
    ::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::DiscoverableProtocol>:
        ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsClientEndsRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireWithProtocolEndsClientEndsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsClientEndsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsClientEndsRequest>
    for WithProtocolEndsClientEndsRequest
{
    fn take_from(from: &mut WireWithProtocolEndsClientEndsRequest) -> Self {
        Self { in_: ::fidl_next::TakeFrom::take_from(&mut from.in_) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsClientEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsRequest {
    pub in_: ::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::DiscoverableProtocol>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsRequest
where
    ___D: ?Sized,

    ::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::DiscoverableProtocol>:
        ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsClientEndsResponse {
    pub out:
        ::fidl_next::bind::ClientEnd<Option<::fidl_next::zx::Handle>, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsResponse {
    type Encoded<'buf> = WireWithProtocolEndsClientEndsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsResponse
where
    ::fidl_next::bind::ClientEnd<Option<::fidl_next::zx::Handle>, crate::DiscoverableProtocol>:
        ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsClientEndsResponse> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireWithProtocolEndsClientEndsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsClientEndsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsClientEndsResponse>
    for WithProtocolEndsClientEndsResponse
{
    fn take_from(from: &mut WireWithProtocolEndsClientEndsResponse) -> Self {
        Self { out: ::fidl_next::TakeFrom::take_from(&mut from.out) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsClientEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsResponse {
    pub out:
        ::fidl_next::bind::ClientEnd<::fidl_next::WireOptionalHandle, crate::DiscoverableProtocol>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsResponse
where
    ___D: ?Sized,

    ::fidl_next::bind::ClientEnd<::fidl_next::WireOptionalHandle, crate::DiscoverableProtocol>:
        ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsServerEndsRequest {
    pub in_:
        ::fidl_next::bind::ServerEnd<Option<::fidl_next::zx::Handle>, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsRequest {
    type Encoded<'buf> = WireWithProtocolEndsServerEndsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsRequest
where
    ::fidl_next::bind::ServerEnd<Option<::fidl_next::zx::Handle>, crate::DiscoverableProtocol>:
        ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsServerEndsRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireWithProtocolEndsServerEndsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsServerEndsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsServerEndsRequest>
    for WithProtocolEndsServerEndsRequest
{
    fn take_from(from: &mut WireWithProtocolEndsServerEndsRequest) -> Self {
        Self { in_: ::fidl_next::TakeFrom::take_from(&mut from.in_) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsServerEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsRequest {
    pub in_:
        ::fidl_next::bind::ServerEnd<::fidl_next::WireOptionalHandle, crate::DiscoverableProtocol>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsRequest
where
    ___D: ?Sized,

    ::fidl_next::bind::ServerEnd<::fidl_next::WireOptionalHandle, crate::DiscoverableProtocol>:
        ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsServerEndsResponse {
    pub out: ::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsResponse {
    type Encoded<'buf> = WireWithProtocolEndsServerEndsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsResponse
where
    ::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::DiscoverableProtocol>:
        ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsServerEndsResponse> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireWithProtocolEndsServerEndsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsServerEndsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsServerEndsResponse>
    for WithProtocolEndsServerEndsResponse
{
    fn take_from(from: &mut WireWithProtocolEndsServerEndsResponse) -> Self {
        Self { out: ::fidl_next::TakeFrom::take_from(&mut from.out) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsServerEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsResponse {
    pub out: ::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::DiscoverableProtocol>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsResponse
where
    ___D: ?Sized,

    ::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::DiscoverableProtocol>:
        ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsRequest {
    type Encoded<'buf> = WireWithProtocolEndsStructContainingEndsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsRequest
where
    crate::ProtocolEnds: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsStructContainingEndsRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireWithProtocolEndsStructContainingEndsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsStructContainingEndsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsStructContainingEndsRequest>
    for WithProtocolEndsStructContainingEndsRequest
{
    fn take_from(from: &mut WireWithProtocolEndsStructContainingEndsRequest) -> Self {
        Self { in_: ::fidl_next::TakeFrom::take_from(&mut from.in_) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsStructContainingEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::WireProtocolEnds,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsRequest
where
    ___D: ?Sized,

    crate::WireProtocolEnds: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsStructContainingEndsResponse {
    pub out: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsResponse {
    type Encoded<'buf> = WireWithProtocolEndsStructContainingEndsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsResponse
where
    crate::ProtocolEnds: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsStructContainingEndsResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireWithProtocolEndsStructContainingEndsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsStructContainingEndsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsStructContainingEndsResponse>
    for WithProtocolEndsStructContainingEndsResponse
{
    fn take_from(from: &mut WireWithProtocolEndsStructContainingEndsResponse) -> Self {
        Self { out: ::fidl_next::TakeFrom::take_from(&mut from.out) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsStructContainingEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsResponse {
    pub out: crate::WireProtocolEnds,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsResponse
where
    ___D: ?Sized,

    crate::WireProtocolEnds: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithProtocolEnds protocol.
#[derive(Debug)]
pub struct WithProtocolEnds;

pub mod with_protocol_ends {

    pub struct ClientEnds;

    impl ::fidl_next::bind::Method for ClientEnds {
        const ORDINAL: u64 = 5870448041025163330;

        type Protocol = crate::WithProtocolEnds;

        type Request<'buf> = crate::WireWithProtocolEndsClientEndsRequest;

        type Response<'buf> = crate::WireWithProtocolEndsClientEndsResponse;
    }

    pub struct ServerEnds;

    impl ::fidl_next::bind::Method for ServerEnds {
        const ORDINAL: u64 = 8115535094437022259;

        type Protocol = crate::WithProtocolEnds;

        type Request<'buf> = crate::WireWithProtocolEndsServerEndsRequest;

        type Response<'buf> = crate::WireWithProtocolEndsServerEndsResponse;
    }

    pub struct StructContainingEnds;

    impl ::fidl_next::bind::Method for StructContainingEnds {
        const ORDINAL: u64 = 4076866772260025813;

        type Protocol = crate::WithProtocolEnds;

        type Request<'buf> = crate::WireWithProtocolEndsStructContainingEndsRequest;

        type Response<'buf> = crate::WireWithProtocolEndsStructContainingEndsResponse;
    }
}

/// A helper trait for the `WithProtocolEnds` client sender.
pub trait WithProtocolEndsClientSender<___T: ::fidl_next::protocol::Transport> {
    fn client_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::ClientEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithProtocolEndsClientEndsRequest,
        >;

    fn server_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::ServerEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithProtocolEndsServerEndsRequest,
        >;

    fn struct_containing_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::StructContainingEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithProtocolEndsStructContainingEndsRequest,
        >;
}

impl<___T> WithProtocolEndsClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, WithProtocolEnds>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn client_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::ClientEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithProtocolEndsClientEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(5870448041025163330, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn server_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::ServerEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithProtocolEndsServerEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8115535094437022259, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn struct_containing_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::StructContainingEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireWithProtocolEndsStructContainingEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(4076866772260025813, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for WithProtocolEnds
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithProtocolEndsClientHandler<___T>,

    for<'buf> crate::WireWithProtocolEndsClientEndsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithProtocolEndsServerEndsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithProtocolEndsStructContainingEndsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithProtocolEnds` server sender.
pub trait WithProtocolEndsServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> WithProtocolEndsServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, WithProtocolEnds>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn client_ends(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::bind::RequestBuffer<___T, with_protocol_ends::ClientEnds>,

        responder: ::fidl_next::bind::Responder<with_protocol_ends::ClientEnds>,
    );

    fn server_ends(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::bind::RequestBuffer<___T, with_protocol_ends::ServerEnds>,

        responder: ::fidl_next::bind::Responder<with_protocol_ends::ServerEnds>,
    );

    fn struct_containing_ends(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::bind::RequestBuffer<___T, with_protocol_ends::StructContainingEnds>,

        responder: ::fidl_next::bind::Responder<with_protocol_ends::StructContainingEnds>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for WithProtocolEnds
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithProtocolEndsServerHandler<___T>,

    for<'buf> crate::WireWithProtocolEndsClientEndsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithProtocolEndsServerEndsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireWithProtocolEndsStructContainingEndsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5870448041025163330 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.client_ends(sender, buffer, responder);
            }

            8115535094437022259 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.server_ends(sender, buffer, responder);
            }

            4076866772260025813 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.struct_containing_ends(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}
