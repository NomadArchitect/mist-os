// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct ArrayBasic {
    pub array_uint8: [u8; 5],

    pub array_uint16: [u16; 5],

    pub array_uint32: [u32; 5],

    pub array_uint64: [u64; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [i16; 5],

    pub array_int32: [i32; 5],

    pub array_int64: [i64; 5],

    pub array_float32: [f32; 5],

    pub array_float64: [f64; 5],

    pub array_string: [String; 5],

    pub array_opt_string: [Option<String>; 5],
}

impl ::fidl_next::Encodable for ArrayBasic {
    type Encoded<'buf> = WireArrayBasic<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ArrayBasic
where
    [u8; 5]: ::fidl_next::Encode<___E>,

    [u16; 5]: ::fidl_next::Encode<___E>,

    [u32; 5]: ::fidl_next::Encode<___E>,

    [u64; 5]: ::fidl_next::Encode<___E>,

    [i8; 5]: ::fidl_next::Encode<___E>,

    [i16; 5]: ::fidl_next::Encode<___E>,

    [i32; 5]: ::fidl_next::Encode<___E>,

    [i64; 5]: ::fidl_next::Encode<___E>,

    [f32; 5]: ::fidl_next::Encode<___E>,

    [f64; 5]: ::fidl_next::Encode<___E>,

    [String; 5]: ::fidl_next::Encode<___E>,

    [Option<String>; 5]: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.array_uint8, encoder, array_uint8)?;

        ::fidl_next::Encode::encode(&mut self.array_uint16, encoder, array_uint16)?;

        ::fidl_next::Encode::encode(&mut self.array_uint32, encoder, array_uint32)?;

        ::fidl_next::Encode::encode(&mut self.array_uint64, encoder, array_uint64)?;

        ::fidl_next::Encode::encode(&mut self.array_int8, encoder, array_int8)?;

        ::fidl_next::Encode::encode(&mut self.array_int16, encoder, array_int16)?;

        ::fidl_next::Encode::encode(&mut self.array_int32, encoder, array_int32)?;

        ::fidl_next::Encode::encode(&mut self.array_int64, encoder, array_int64)?;

        ::fidl_next::Encode::encode(&mut self.array_float32, encoder, array_float32)?;

        ::fidl_next::Encode::encode(&mut self.array_float64, encoder, array_float64)?;

        ::fidl_next::Encode::encode(&mut self.array_string, encoder, array_string)?;

        ::fidl_next::Encode::encode(&mut self.array_opt_string, encoder, array_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ArrayBasic> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireArrayBasic<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ArrayBasic>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayBasic: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireArrayBasic<'buf>> for ArrayBasic {
    fn take_from(from: &mut WireArrayBasic<'buf>) -> Self {
        Self {
            array_uint8: ::fidl_next::TakeFrom::take_from(&mut from.array_uint8),

            array_uint16: ::fidl_next::TakeFrom::take_from(&mut from.array_uint16),

            array_uint32: ::fidl_next::TakeFrom::take_from(&mut from.array_uint32),

            array_uint64: ::fidl_next::TakeFrom::take_from(&mut from.array_uint64),

            array_int8: ::fidl_next::TakeFrom::take_from(&mut from.array_int8),

            array_int16: ::fidl_next::TakeFrom::take_from(&mut from.array_int16),

            array_int32: ::fidl_next::TakeFrom::take_from(&mut from.array_int32),

            array_int64: ::fidl_next::TakeFrom::take_from(&mut from.array_int64),

            array_float32: ::fidl_next::TakeFrom::take_from(&mut from.array_float32),

            array_float64: ::fidl_next::TakeFrom::take_from(&mut from.array_float64),

            array_string: ::fidl_next::TakeFrom::take_from(&mut from.array_string),

            array_opt_string: ::fidl_next::TakeFrom::take_from(&mut from.array_opt_string),
        }
    }
}

/// The wire type corersponding to [`ArrayBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayBasic<'buf> {
    pub array_uint8: [u8; 5],

    pub array_uint16: [::fidl_next::u16_le; 5],

    pub array_uint32: [::fidl_next::u32_le; 5],

    pub array_uint64: [::fidl_next::u64_le; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [::fidl_next::i16_le; 5],

    pub array_int32: [::fidl_next::i32_le; 5],

    pub array_int64: [::fidl_next::i64_le; 5],

    pub array_float32: [::fidl_next::f32_le; 5],

    pub array_float64: [::fidl_next::f64_le; 5],

    pub array_string: [::fidl_next::WireString<'buf>; 5],

    pub array_opt_string: [::fidl_next::WireOptionalString<'buf>; 5],
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireArrayBasic<'buf>
where
    ___D: ?Sized,

    [u8; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::u16_le; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::u32_le; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::u64_le; 5]: ::fidl_next::Decode<___D>,

    [i8; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::i16_le; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::i32_le; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::i64_le; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::f32_le; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::f64_le; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::WireString<'buf>; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::WireOptionalString<'buf>; 5]: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_uint8,
                mut array_uint16,
                mut array_uint32,
                mut array_uint64,
                mut array_int8,
                mut array_int16,
                mut array_int32,
                mut array_int64,
                mut array_float32,
                mut array_float64,
                mut array_string,
                mut array_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

::fidl_next::bitflags! {

    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Bits: u32 {
        const VAL = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Bits {
    type Encoded<'buf> = WireBits;
}

impl<___E> ::fidl_next::Encode<___E> for Bits
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBits { mut value } = slot);
        *value = ::fidl_next::u32_le::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<WireBits> for Bits {
    fn from(wire: WireBits) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBits> for Bits {
    fn take_from(from: &mut WireBits) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Bits`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBits {
    value: ::fidl_next::u32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBits
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Bits> for WireBits {
    fn from(natural: Bits) -> Self {
        Self { value: ::fidl_next::u32_le::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug)]
#[repr(u32)]
pub enum Enum {
    Val = 1,
    UnknownOrdinal(u32),
}

impl ::fidl_next::Encodable for Enum {
    type Encoded<'buf> = WireEnum;
}

impl<___E> ::fidl_next::Encode<___E> for Enum
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnum { mut value } = slot);
        *value = ::fidl_next::u32_le::from(match *self {
            Self::Val => 1,

            Self::UnknownOrdinal(value) => value,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireEnum> for Enum {
    fn from(wire: WireEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::Val,

            value => Self::UnknownOrdinal(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireEnum> for Enum {
    fn take_from(from: &mut WireEnum) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Enum`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireEnum {
    value: ::fidl_next::u32_le,
}

impl WireEnum {
    pub const VAL: WireEnum = WireEnum { value: ::fidl_next::u32_le::from_native(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Enum> for WireEnum {
    fn from(natural: Enum) -> Self {
        match natural {
            Enum::Val => WireEnum::VAL,

            Enum::UnknownOrdinal(value) => WireEnum { value: ::fidl_next::u32_le::from(value) },
        }
    }
}

#[derive(Clone, Debug)]
pub struct Struct {}

impl ::fidl_next::Encodable for Struct {
    type Encoded<'buf> = WireStruct;
}

impl<___E> ::fidl_next::Encode<___E> for Struct {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Struct> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireStruct>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Struct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStruct> for Struct {
    fn take_from(from: &mut WireStruct) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`Struct`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireStruct {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStruct
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Table {}

impl Table {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for Table {
    type Encoded<'buf> = WireTable<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Table
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireTable<'buf>> for Table {
    fn take_from(from: &mut WireTable<'buf>) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`Table`].
#[repr(C)]
pub struct WireTable<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireTable<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireTable<'buf> {}

impl ::core::fmt::Debug for WireTable<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("Table").finish()
    }
}

#[derive(Clone, Debug)]
pub enum Union {
    B(bool),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for Union {
    type Encoded<'buf> = WireUnion;
}

impl<___E> ::fidl_next::Encode<___E> for Union
where
    ___E: ::fidl_next::Encoder + ?Sized,

    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw, _phantom: _ } = slot);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Union> {
    type EncodedOption<'buf> = WireOptionalUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Union>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Union: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnion> for Union {
    fn take_from(from: &mut WireUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::B(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnion> for Option<Box<Union>> {
    fn take_from(from: &mut WireOptionalUnion) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Union`].
#[repr(transparent)]
pub struct WireUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod r#union {
    pub enum Ref<'union> {
        B(&'union bool),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        B(&'union mut bool),

        UnknownOrdinal(u64),
    }
}

impl WireUnion {
    pub fn as_ref(&self) -> crate::r#union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::r#union::Ref::B(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::r#union::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::r#union::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::r#union::Mut::B(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            unknown => crate::r#union::Mut::UnknownOrdinal(unknown),
        }
    }
}

impl Clone for WireUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireUnion
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnion> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnion> {
        if self.is_some() {
            Some(WireUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnion {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnion {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalUnion
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct ArrayCompound {
    pub array_bits: [crate::Bits; 5],

    pub array_enum: [crate::Enum; 5],

    pub array_struct: [crate::Struct; 5],

    pub array_table: [crate::Table; 5],

    pub array_union: [crate::Union; 5],

    pub array_opt_struct: [Option<Box<crate::Struct>>; 5],

    pub array_opt_union: [Option<Box<crate::Union>>; 5],
}

impl ::fidl_next::Encodable for ArrayCompound {
    type Encoded<'buf> = WireArrayCompound<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ArrayCompound
where
    [crate::Bits; 5]: ::fidl_next::Encode<___E>,

    [crate::Enum; 5]: ::fidl_next::Encode<___E>,

    [crate::Struct; 5]: ::fidl_next::Encode<___E>,

    [crate::Table; 5]: ::fidl_next::Encode<___E>,

    [crate::Union; 5]: ::fidl_next::Encode<___E>,

    [Option<Box<crate::Struct>>; 5]: ::fidl_next::Encode<___E>,

    [Option<Box<crate::Union>>; 5]: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.array_bits, encoder, array_bits)?;

        ::fidl_next::Encode::encode(&mut self.array_enum, encoder, array_enum)?;

        ::fidl_next::Encode::encode(&mut self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(&mut self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(&mut self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(&mut self.array_opt_struct, encoder, array_opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.array_opt_union, encoder, array_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ArrayCompound> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireArrayCompound<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ArrayCompound>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayCompound: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireArrayCompound<'buf>> for ArrayCompound {
    fn take_from(from: &mut WireArrayCompound<'buf>) -> Self {
        Self {
            array_bits: ::fidl_next::TakeFrom::take_from(&mut from.array_bits),

            array_enum: ::fidl_next::TakeFrom::take_from(&mut from.array_enum),

            array_struct: ::fidl_next::TakeFrom::take_from(&mut from.array_struct),

            array_table: ::fidl_next::TakeFrom::take_from(&mut from.array_table),

            array_union: ::fidl_next::TakeFrom::take_from(&mut from.array_union),

            array_opt_struct: ::fidl_next::TakeFrom::take_from(&mut from.array_opt_struct),

            array_opt_union: ::fidl_next::TakeFrom::take_from(&mut from.array_opt_union),
        }
    }
}

/// The wire type corersponding to [`ArrayCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayCompound<'buf> {
    pub array_bits: [crate::WireBits; 5],

    pub array_enum: [crate::WireEnum; 5],

    pub array_struct: [crate::WireStruct; 5],

    pub array_table: [crate::WireTable<'buf>; 5],

    pub array_union: [crate::WireUnion; 5],

    pub array_opt_struct: [::fidl_next::WireBox<'buf, crate::WireStruct>; 5],

    pub array_opt_union: [crate::WireOptionalUnion; 5],
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireArrayCompound<'buf>
where
    ___D: ?Sized,

    [crate::WireBits; 5]: ::fidl_next::Decode<___D>,

    [crate::WireEnum; 5]: ::fidl_next::Decode<___D>,

    [crate::WireStruct; 5]: ::fidl_next::Decode<___D>,

    [crate::WireTable<'buf>; 5]: ::fidl_next::Decode<___D>,

    [crate::WireUnion; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::WireBox<'buf, crate::WireStruct>; 5]: ::fidl_next::Decode<___D>,

    [crate::WireOptionalUnion; 5]: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_bits,
                mut array_enum,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut array_opt_struct,
                mut array_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ArrayVectorNested {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [Vec<u8>; 5],

    pub vector_array_uint8: Vec<[u8; 5]>,

    pub vector_vector_uint8: Vec<Vec<u8>>,
}

impl ::fidl_next::Encodable for ArrayVectorNested {
    type Encoded<'buf> = WireArrayVectorNested<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ArrayVectorNested
where
    [[u8; 5]; 5]: ::fidl_next::Encode<___E>,

    [Vec<u8>; 5]: ::fidl_next::Encode<___E>,

    Vec<[u8; 5]>: ::fidl_next::Encode<___E>,

    Vec<Vec<u8>>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_array_uint8,
                array_vector_uint8,
                vector_array_uint8,
                vector_vector_uint8,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.array_array_uint8, encoder, array_array_uint8)?;

        ::fidl_next::Encode::encode(&mut self.array_vector_uint8, encoder, array_vector_uint8)?;

        ::fidl_next::Encode::encode(&mut self.vector_array_uint8, encoder, vector_array_uint8)?;

        ::fidl_next::Encode::encode(&mut self.vector_vector_uint8, encoder, vector_vector_uint8)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ArrayVectorNested> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireArrayVectorNested<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ArrayVectorNested>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayVectorNested: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireArrayVectorNested<'buf>> for ArrayVectorNested {
    fn take_from(from: &mut WireArrayVectorNested<'buf>) -> Self {
        Self {
            array_array_uint8: ::fidl_next::TakeFrom::take_from(&mut from.array_array_uint8),

            array_vector_uint8: ::fidl_next::TakeFrom::take_from(&mut from.array_vector_uint8),

            vector_array_uint8: ::fidl_next::TakeFrom::take_from(&mut from.vector_array_uint8),

            vector_vector_uint8: ::fidl_next::TakeFrom::take_from(&mut from.vector_vector_uint8),
        }
    }
}

/// The wire type corersponding to [`ArrayVectorNested`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayVectorNested<'buf> {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [::fidl_next::WireVector<'buf, u8>; 5],

    pub vector_array_uint8: ::fidl_next::WireVector<'buf, [u8; 5]>,

    pub vector_vector_uint8: ::fidl_next::WireVector<'buf, ::fidl_next::WireVector<'buf, u8>>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireArrayVectorNested<'buf>
where
    ___D: ?Sized,

    [[u8; 5]; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::WireVector<'buf, u8>; 5]: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, [u8; 5]>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireVector<'buf, u8>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_array_uint8,
                mut array_vector_uint8,
                mut vector_array_uint8,
                mut vector_vector_uint8,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vector_uint8.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Basic {
    pub uint8: u8,

    pub uint16: u16,

    pub uint32: u32,

    pub uint64: u64,

    pub int8: i8,

    pub int16: i16,

    pub int32: i32,

    pub int64: i64,

    pub float32: f32,

    pub float64: f64,

    pub string: String,

    pub opt_string: Option<String>,
}

impl ::fidl_next::Encodable for Basic {
    type Encoded<'buf> = WireBasic<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Basic
where
    u8: ::fidl_next::Encode<___E>,

    u16: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,

    u64: ::fidl_next::Encode<___E>,

    i8: ::fidl_next::Encode<___E>,

    i16: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,

    i64: ::fidl_next::Encode<___E>,

    f32: ::fidl_next::Encode<___E>,

    f64: ::fidl_next::Encode<___E>,

    String: ::fidl_next::Encode<___E>,

    Option<String>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.uint8, encoder, uint8)?;

        ::fidl_next::Encode::encode(&mut self.uint16, encoder, uint16)?;

        ::fidl_next::Encode::encode(&mut self.uint32, encoder, uint32)?;

        ::fidl_next::Encode::encode(&mut self.uint64, encoder, uint64)?;

        ::fidl_next::Encode::encode(&mut self.int8, encoder, int8)?;

        ::fidl_next::Encode::encode(&mut self.int16, encoder, int16)?;

        ::fidl_next::Encode::encode(&mut self.int32, encoder, int32)?;

        ::fidl_next::Encode::encode(&mut self.int64, encoder, int64)?;

        ::fidl_next::Encode::encode(&mut self.float32, encoder, float32)?;

        ::fidl_next::Encode::encode(&mut self.float64, encoder, float64)?;

        ::fidl_next::Encode::encode(&mut self.string, encoder, string)?;

        ::fidl_next::Encode::encode(&mut self.opt_string, encoder, opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Basic> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireBasic<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Basic>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Basic: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireBasic<'buf>> for Basic {
    fn take_from(from: &mut WireBasic<'buf>) -> Self {
        Self {
            uint8: ::fidl_next::TakeFrom::take_from(&mut from.uint8),

            uint16: ::fidl_next::TakeFrom::take_from(&mut from.uint16),

            uint32: ::fidl_next::TakeFrom::take_from(&mut from.uint32),

            uint64: ::fidl_next::TakeFrom::take_from(&mut from.uint64),

            int8: ::fidl_next::TakeFrom::take_from(&mut from.int8),

            int16: ::fidl_next::TakeFrom::take_from(&mut from.int16),

            int32: ::fidl_next::TakeFrom::take_from(&mut from.int32),

            int64: ::fidl_next::TakeFrom::take_from(&mut from.int64),

            float32: ::fidl_next::TakeFrom::take_from(&mut from.float32),

            float64: ::fidl_next::TakeFrom::take_from(&mut from.float64),

            string: ::fidl_next::TakeFrom::take_from(&mut from.string),

            opt_string: ::fidl_next::TakeFrom::take_from(&mut from.opt_string),
        }
    }
}

/// The wire type corersponding to [`Basic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireBasic<'buf> {
    pub uint8: u8,

    pub uint16: ::fidl_next::u16_le,

    pub uint32: ::fidl_next::u32_le,

    pub uint64: ::fidl_next::u64_le,

    pub int8: i8,

    pub int16: ::fidl_next::i16_le,

    pub int32: ::fidl_next::i32_le,

    pub int64: ::fidl_next::i64_le,

    pub float32: ::fidl_next::f32_le,

    pub float64: ::fidl_next::f64_le,

    pub string: ::fidl_next::WireString<'buf>,

    pub opt_string: ::fidl_next::WireOptionalString<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireBasic<'buf>
where
    ___D: ?Sized,

    u8: ::fidl_next::Decode<___D>,

    ::fidl_next::u16_le: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::u64_le: ::fidl_next::Decode<___D>,

    i8: ::fidl_next::Decode<___D>,

    ::fidl_next::i16_le: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::f32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::f64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireOptionalString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut uint8,
                mut uint16,
                mut uint32,
                mut uint64,
                mut int8,
                mut int16,
                mut int32,
                mut int64,
                mut float32,
                mut float64,
                mut string,
                mut opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Compound {
    pub bits: crate::Bits,

    pub r#enum: crate::Enum,

    pub r#struct: crate::Struct,

    pub table: crate::Table,

    pub r#union: crate::Union,

    pub opt_struct: Option<Box<crate::Struct>>,

    pub opt_union: Option<Box<crate::Union>>,
}

impl ::fidl_next::Encodable for Compound {
    type Encoded<'buf> = WireCompound<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Compound
where
    crate::Bits: ::fidl_next::Encode<___E>,

    crate::Enum: ::fidl_next::Encode<___E>,

    crate::Struct: ::fidl_next::Encode<___E>,

    crate::Table: ::fidl_next::Encode<___E>,

    crate::Union: ::fidl_next::Encode<___E>,

    Option<Box<crate::Struct>>: ::fidl_next::Encode<___E>,

    Option<Box<crate::Union>>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits,
                r#enum,
                r#struct,
                table,
                r#union,
                opt_struct,
                opt_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.bits, encoder, bits)?;

        ::fidl_next::Encode::encode(&mut self.r#enum, encoder, r#enum)?;

        ::fidl_next::Encode::encode(&mut self.r#struct, encoder, r#struct)?;

        ::fidl_next::Encode::encode(&mut self.table, encoder, table)?;

        ::fidl_next::Encode::encode(&mut self.r#union, encoder, r#union)?;

        ::fidl_next::Encode::encode(&mut self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.opt_union, encoder, opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Compound> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireCompound<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Compound>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Compound: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireCompound<'buf>> for Compound {
    fn take_from(from: &mut WireCompound<'buf>) -> Self {
        Self {
            bits: ::fidl_next::TakeFrom::take_from(&mut from.bits),

            r#enum: ::fidl_next::TakeFrom::take_from(&mut from.r#enum),

            r#struct: ::fidl_next::TakeFrom::take_from(&mut from.r#struct),

            table: ::fidl_next::TakeFrom::take_from(&mut from.table),

            r#union: ::fidl_next::TakeFrom::take_from(&mut from.r#union),

            opt_struct: ::fidl_next::TakeFrom::take_from(&mut from.opt_struct),

            opt_union: ::fidl_next::TakeFrom::take_from(&mut from.opt_union),
        }
    }
}

/// The wire type corersponding to [`Compound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireCompound<'buf> {
    pub bits: crate::WireBits,

    pub r#enum: crate::WireEnum,

    pub r#struct: crate::WireStruct,

    pub table: crate::WireTable<'buf>,

    pub r#union: crate::WireUnion,

    pub opt_struct: ::fidl_next::WireBox<'buf, crate::WireStruct>,

    pub opt_union: crate::WireOptionalUnion,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireCompound<'buf>
where
    ___D: ?Sized,

    crate::WireBits: ::fidl_next::Decode<___D>,

    crate::WireEnum: ::fidl_next::Decode<___D>,

    crate::WireStruct: ::fidl_next::Decode<___D>,

    crate::WireTable<'buf>: ::fidl_next::Decode<___D>,

    crate::WireUnion: ::fidl_next::Decode<___D>,

    ::fidl_next::WireBox<'buf, crate::WireStruct>: ::fidl_next::Decode<___D>,

    crate::WireOptionalUnion: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut bits,
                mut r#enum,
                mut r#struct,
                mut table,
                mut r#union,
                mut opt_struct,
                mut opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r#enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r#struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r#union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorBasicResult {
    Response(crate::Basic),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorBasicResult {
    type Encoded<'buf> = WireProtocolErrorBasicResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorBasicResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::Basic: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorBasicResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Basic>(value, 1, encoder, raw)?
            }

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorBasicResult> {
    type EncodedOption<'buf> = WireOptionalProtocolErrorBasicResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorBasicResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolErrorBasicResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorBasicResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireProtocolErrorBasicResult<'buf>> for ProtocolErrorBasicResult {
    fn take_from(from: &mut WireProtocolErrorBasicResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalProtocolErrorBasicResult<'buf>>
    for Option<Box<ProtocolErrorBasicResult>>
{
    fn take_from(from: &mut WireOptionalProtocolErrorBasicResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorBasicResult`].
#[repr(transparent)]
pub struct WireProtocolErrorBasicResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod protocol_error_basic_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireBasic<'buf>),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireBasic<'buf>),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireProtocolErrorBasicResult<'buf> {
    pub fn as_ref(&self) -> crate::protocol_error_basic_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_basic_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_basic_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::protocol_error_basic_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_basic_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::protocol_error_basic_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireProtocolErrorBasicResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireBasic<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireBasic<'buf>>(raw, decoder)?
            }

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireProtocolErrorBasicResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireBasic<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorBasicResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalProtocolErrorBasicResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorBasicResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireProtocolErrorBasicResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireProtocolErrorBasicResult<'buf>> {
        if self.is_some() {
            Some(WireProtocolErrorBasicResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalProtocolErrorBasicResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorBasicResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireBasic<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireBasic<'buf>>(raw, decoder)?
            }

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalProtocolErrorBasicResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorCompoundResult {
    Response(crate::Compound),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorCompoundResult {
    type Encoded<'buf> = WireProtocolErrorCompoundResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorCompoundResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::Compound: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorCompoundResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<___E, crate::Compound>(
                value, 1, encoder, raw,
            )?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorCompoundResult> {
    type EncodedOption<'buf> = WireOptionalProtocolErrorCompoundResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorCompoundResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolErrorCompoundResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorCompoundResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireProtocolErrorCompoundResult<'buf>>
    for ProtocolErrorCompoundResult
{
    fn take_from(from: &mut WireProtocolErrorCompoundResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalProtocolErrorCompoundResult<'buf>>
    for Option<Box<ProtocolErrorCompoundResult>>
{
    fn take_from(from: &mut WireOptionalProtocolErrorCompoundResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorCompoundResult`].
#[repr(transparent)]
pub struct WireProtocolErrorCompoundResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod protocol_error_compound_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireCompound<'buf>),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireCompound<'buf>),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireProtocolErrorCompoundResult<'buf> {
    pub fn as_ref(&self) -> crate::protocol_error_compound_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_compound_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_compound_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::protocol_error_compound_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_compound_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::protocol_error_compound_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireProtocolErrorCompoundResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireCompound<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireCompound<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireProtocolErrorCompoundResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireCompound<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorCompoundResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalProtocolErrorCompoundResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorCompoundResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireProtocolErrorCompoundResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireProtocolErrorCompoundResult<'buf>> {
        if self.is_some() {
            Some(WireProtocolErrorCompoundResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalProtocolErrorCompoundResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorCompoundResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireCompound<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireCompound<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalProtocolErrorCompoundResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorArrayBasicResult {
    Response(crate::ArrayBasic),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorArrayBasicResult {
    type Encoded<'buf> = WireProtocolErrorArrayBasicResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorArrayBasicResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::ArrayBasic: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorArrayBasicResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::ArrayBasic>(
                    value, 1, encoder, raw,
                )?
            }

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorArrayBasicResult> {
    type EncodedOption<'buf> = WireOptionalProtocolErrorArrayBasicResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorArrayBasicResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolErrorArrayBasicResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorArrayBasicResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireProtocolErrorArrayBasicResult<'buf>>
    for ProtocolErrorArrayBasicResult
{
    fn take_from(from: &mut WireProtocolErrorArrayBasicResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalProtocolErrorArrayBasicResult<'buf>>
    for Option<Box<ProtocolErrorArrayBasicResult>>
{
    fn take_from(from: &mut WireOptionalProtocolErrorArrayBasicResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorArrayBasicResult`].
#[repr(transparent)]
pub struct WireProtocolErrorArrayBasicResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod protocol_error_array_basic_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireArrayBasic<'buf>),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireArrayBasic<'buf>),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireProtocolErrorArrayBasicResult<'buf> {
    pub fn as_ref(&self) -> crate::protocol_error_array_basic_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_array_basic_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_array_basic_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::protocol_error_array_basic_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_array_basic_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::protocol_error_array_basic_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireProtocolErrorArrayBasicResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireArrayBasic<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayBasic<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireProtocolErrorArrayBasicResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireArrayBasic<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorArrayBasicResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalProtocolErrorArrayBasicResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorArrayBasicResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireProtocolErrorArrayBasicResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireProtocolErrorArrayBasicResult<'buf>> {
        if self.is_some() {
            Some(WireProtocolErrorArrayBasicResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalProtocolErrorArrayBasicResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorArrayBasicResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireArrayBasic<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayBasic<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalProtocolErrorArrayBasicResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorArrayCompoundResult {
    Response(crate::ArrayCompound),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorArrayCompoundResult {
    type Encoded<'buf> = WireProtocolErrorArrayCompoundResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorArrayCompoundResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::ArrayCompound: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorArrayCompoundResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::ArrayCompound,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorArrayCompoundResult> {
    type EncodedOption<'buf> = WireOptionalProtocolErrorArrayCompoundResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorArrayCompoundResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolErrorArrayCompoundResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorArrayCompoundResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireProtocolErrorArrayCompoundResult<'buf>>
    for ProtocolErrorArrayCompoundResult
{
    fn take_from(from: &mut WireProtocolErrorArrayCompoundResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalProtocolErrorArrayCompoundResult<'buf>>
    for Option<Box<ProtocolErrorArrayCompoundResult>>
{
    fn take_from(from: &mut WireOptionalProtocolErrorArrayCompoundResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorArrayCompoundResult`].
#[repr(transparent)]
pub struct WireProtocolErrorArrayCompoundResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod protocol_error_array_compound_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireArrayCompound<'buf>),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireArrayCompound<'buf>),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireProtocolErrorArrayCompoundResult<'buf> {
    pub fn as_ref(&self) -> crate::protocol_error_array_compound_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_array_compound_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_array_compound_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::protocol_error_array_compound_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_array_compound_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::protocol_error_array_compound_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireProtocolErrorArrayCompoundResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireArrayCompound<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayCompound<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireProtocolErrorArrayCompoundResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireArrayCompound<'buf>>().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorArrayCompoundResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalProtocolErrorArrayCompoundResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorArrayCompoundResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireProtocolErrorArrayCompoundResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireProtocolErrorArrayCompoundResult<'buf>> {
        if self.is_some() {
            Some(WireProtocolErrorArrayCompoundResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalProtocolErrorArrayCompoundResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorArrayCompoundResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireArrayCompound<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayCompound<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalProtocolErrorArrayCompoundResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct VectorBasic {
    pub vector_uint8: Vec<u8>,

    pub vector_uint16: Vec<u16>,

    pub vector_uint32: Vec<u32>,

    pub vector_uint64: Vec<u64>,

    pub vector_int8: Vec<i8>,

    pub vector_int16: Vec<i16>,

    pub vector_int32: Vec<i32>,

    pub vector_int64: Vec<i64>,

    pub vector_float32: Vec<f32>,

    pub vector_float64: Vec<f64>,

    pub vector_string: Vec<String>,

    pub vector_opt_string: Vec<Option<String>>,
}

impl ::fidl_next::Encodable for VectorBasic {
    type Encoded<'buf> = WireVectorBasic<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for VectorBasic
where
    Vec<u8>: ::fidl_next::Encode<___E>,

    Vec<u16>: ::fidl_next::Encode<___E>,

    Vec<u32>: ::fidl_next::Encode<___E>,

    Vec<u64>: ::fidl_next::Encode<___E>,

    Vec<i8>: ::fidl_next::Encode<___E>,

    Vec<i16>: ::fidl_next::Encode<___E>,

    Vec<i32>: ::fidl_next::Encode<___E>,

    Vec<i64>: ::fidl_next::Encode<___E>,

    Vec<f32>: ::fidl_next::Encode<___E>,

    Vec<f64>: ::fidl_next::Encode<___E>,

    Vec<String>: ::fidl_next::Encode<___E>,

    Vec<Option<String>>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.vector_uint8, encoder, vector_uint8)?;

        ::fidl_next::Encode::encode(&mut self.vector_uint16, encoder, vector_uint16)?;

        ::fidl_next::Encode::encode(&mut self.vector_uint32, encoder, vector_uint32)?;

        ::fidl_next::Encode::encode(&mut self.vector_uint64, encoder, vector_uint64)?;

        ::fidl_next::Encode::encode(&mut self.vector_int8, encoder, vector_int8)?;

        ::fidl_next::Encode::encode(&mut self.vector_int16, encoder, vector_int16)?;

        ::fidl_next::Encode::encode(&mut self.vector_int32, encoder, vector_int32)?;

        ::fidl_next::Encode::encode(&mut self.vector_int64, encoder, vector_int64)?;

        ::fidl_next::Encode::encode(&mut self.vector_float32, encoder, vector_float32)?;

        ::fidl_next::Encode::encode(&mut self.vector_float64, encoder, vector_float64)?;

        ::fidl_next::Encode::encode(&mut self.vector_string, encoder, vector_string)?;

        ::fidl_next::Encode::encode(&mut self.vector_opt_string, encoder, vector_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<VectorBasic> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireVectorBasic<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<VectorBasic>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorBasic: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireVectorBasic<'buf>> for VectorBasic {
    fn take_from(from: &mut WireVectorBasic<'buf>) -> Self {
        Self {
            vector_uint8: ::fidl_next::TakeFrom::take_from(&mut from.vector_uint8),

            vector_uint16: ::fidl_next::TakeFrom::take_from(&mut from.vector_uint16),

            vector_uint32: ::fidl_next::TakeFrom::take_from(&mut from.vector_uint32),

            vector_uint64: ::fidl_next::TakeFrom::take_from(&mut from.vector_uint64),

            vector_int8: ::fidl_next::TakeFrom::take_from(&mut from.vector_int8),

            vector_int16: ::fidl_next::TakeFrom::take_from(&mut from.vector_int16),

            vector_int32: ::fidl_next::TakeFrom::take_from(&mut from.vector_int32),

            vector_int64: ::fidl_next::TakeFrom::take_from(&mut from.vector_int64),

            vector_float32: ::fidl_next::TakeFrom::take_from(&mut from.vector_float32),

            vector_float64: ::fidl_next::TakeFrom::take_from(&mut from.vector_float64),

            vector_string: ::fidl_next::TakeFrom::take_from(&mut from.vector_string),

            vector_opt_string: ::fidl_next::TakeFrom::take_from(&mut from.vector_opt_string),
        }
    }
}

/// The wire type corersponding to [`VectorBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorBasic<'buf> {
    pub vector_uint8: ::fidl_next::WireVector<'buf, u8>,

    pub vector_uint16: ::fidl_next::WireVector<'buf, ::fidl_next::u16_le>,

    pub vector_uint32: ::fidl_next::WireVector<'buf, ::fidl_next::u32_le>,

    pub vector_uint64: ::fidl_next::WireVector<'buf, ::fidl_next::u64_le>,

    pub vector_int8: ::fidl_next::WireVector<'buf, i8>,

    pub vector_int16: ::fidl_next::WireVector<'buf, ::fidl_next::i16_le>,

    pub vector_int32: ::fidl_next::WireVector<'buf, ::fidl_next::i32_le>,

    pub vector_int64: ::fidl_next::WireVector<'buf, ::fidl_next::i64_le>,

    pub vector_float32: ::fidl_next::WireVector<'buf, ::fidl_next::f32_le>,

    pub vector_float64: ::fidl_next::WireVector<'buf, ::fidl_next::f64_le>,

    pub vector_string: ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,

    pub vector_opt_string: ::fidl_next::WireVector<'buf, ::fidl_next::WireOptionalString<'buf>>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireVectorBasic<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireVector<'buf, u8>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::u16_le>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::u32_le>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::u64_le>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, i8>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::i16_le>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::i32_le>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::i64_le>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::f32_le>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::f64_le>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireOptionalString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_uint8,
                mut vector_uint16,
                mut vector_uint32,
                mut vector_uint64,
                mut vector_int8,
                mut vector_int16,
                mut vector_int32,
                mut vector_int64,
                mut vector_float32,
                mut vector_float64,
                mut vector_string,
                mut vector_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorVectorBasicResult {
    Response(crate::VectorBasic),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorVectorBasicResult {
    type Encoded<'buf> = WireProtocolErrorVectorBasicResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorVectorBasicResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::VectorBasic: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorVectorBasicResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::VectorBasic,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorVectorBasicResult> {
    type EncodedOption<'buf> = WireOptionalProtocolErrorVectorBasicResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorVectorBasicResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolErrorVectorBasicResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorVectorBasicResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireProtocolErrorVectorBasicResult<'buf>>
    for ProtocolErrorVectorBasicResult
{
    fn take_from(from: &mut WireProtocolErrorVectorBasicResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalProtocolErrorVectorBasicResult<'buf>>
    for Option<Box<ProtocolErrorVectorBasicResult>>
{
    fn take_from(from: &mut WireOptionalProtocolErrorVectorBasicResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorVectorBasicResult`].
#[repr(transparent)]
pub struct WireProtocolErrorVectorBasicResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod protocol_error_vector_basic_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireVectorBasic<'buf>),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireVectorBasic<'buf>),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireProtocolErrorVectorBasicResult<'buf> {
    pub fn as_ref(&self) -> crate::protocol_error_vector_basic_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_vector_basic_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_vector_basic_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::protocol_error_vector_basic_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_vector_basic_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::protocol_error_vector_basic_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireProtocolErrorVectorBasicResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireVectorBasic<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorBasic<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireProtocolErrorVectorBasicResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireVectorBasic<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorVectorBasicResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalProtocolErrorVectorBasicResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorVectorBasicResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireProtocolErrorVectorBasicResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireProtocolErrorVectorBasicResult<'buf>> {
        if self.is_some() {
            Some(WireProtocolErrorVectorBasicResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalProtocolErrorVectorBasicResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorVectorBasicResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireVectorBasic<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorBasic<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalProtocolErrorVectorBasicResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct VectorCompound {
    pub vector_bits: Vec<crate::Bits>,

    pub vector_enum: Vec<crate::Enum>,

    pub vector_struct: Vec<crate::Struct>,

    pub vector_table: Vec<crate::Table>,

    pub vector_union: Vec<crate::Union>,

    pub vector_opt_struct: Vec<Option<Box<crate::Struct>>>,

    pub vector_opt_union: Vec<Option<Box<crate::Union>>>,
}

impl ::fidl_next::Encodable for VectorCompound {
    type Encoded<'buf> = WireVectorCompound<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for VectorCompound
where
    Vec<crate::Bits>: ::fidl_next::Encode<___E>,

    Vec<crate::Enum>: ::fidl_next::Encode<___E>,

    Vec<crate::Struct>: ::fidl_next::Encode<___E>,

    Vec<crate::Table>: ::fidl_next::Encode<___E>,

    Vec<crate::Union>: ::fidl_next::Encode<___E>,

    Vec<Option<Box<crate::Struct>>>: ::fidl_next::Encode<___E>,

    Vec<Option<Box<crate::Union>>>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.vector_bits, encoder, vector_bits)?;

        ::fidl_next::Encode::encode(&mut self.vector_enum, encoder, vector_enum)?;

        ::fidl_next::Encode::encode(&mut self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(&mut self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(&mut self.vector_union, encoder, vector_union)?;

        ::fidl_next::Encode::encode(&mut self.vector_opt_struct, encoder, vector_opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.vector_opt_union, encoder, vector_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<VectorCompound> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireVectorCompound<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<VectorCompound>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorCompound: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireVectorCompound<'buf>> for VectorCompound {
    fn take_from(from: &mut WireVectorCompound<'buf>) -> Self {
        Self {
            vector_bits: ::fidl_next::TakeFrom::take_from(&mut from.vector_bits),

            vector_enum: ::fidl_next::TakeFrom::take_from(&mut from.vector_enum),

            vector_struct: ::fidl_next::TakeFrom::take_from(&mut from.vector_struct),

            vector_table: ::fidl_next::TakeFrom::take_from(&mut from.vector_table),

            vector_union: ::fidl_next::TakeFrom::take_from(&mut from.vector_union),

            vector_opt_struct: ::fidl_next::TakeFrom::take_from(&mut from.vector_opt_struct),

            vector_opt_union: ::fidl_next::TakeFrom::take_from(&mut from.vector_opt_union),
        }
    }
}

/// The wire type corersponding to [`VectorCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorCompound<'buf> {
    pub vector_bits: ::fidl_next::WireVector<'buf, crate::WireBits>,

    pub vector_enum: ::fidl_next::WireVector<'buf, crate::WireEnum>,

    pub vector_struct: ::fidl_next::WireVector<'buf, crate::WireStruct>,

    pub vector_table: ::fidl_next::WireVector<'buf, crate::WireTable<'buf>>,

    pub vector_union: ::fidl_next::WireVector<'buf, crate::WireUnion>,

    pub vector_opt_struct:
        ::fidl_next::WireVector<'buf, ::fidl_next::WireBox<'buf, crate::WireStruct>>,

    pub vector_opt_union: ::fidl_next::WireVector<'buf, crate::WireOptionalUnion>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireVectorCompound<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireVector<'buf, crate::WireBits>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, crate::WireEnum>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, crate::WireStruct>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, crate::WireTable<'buf>>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, crate::WireUnion>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireBox<'buf, crate::WireStruct>>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, crate::WireOptionalUnion>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_bits,
                mut vector_enum,
                mut vector_struct,
                mut vector_table,
                mut vector_union,
                mut vector_opt_struct,
                mut vector_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorVectorCompoundResult {
    Response(crate::VectorCompound),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorVectorCompoundResult {
    type Encoded<'buf> = WireProtocolErrorVectorCompoundResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorVectorCompoundResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::VectorCompound: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorVectorCompoundResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::VectorCompound,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorVectorCompoundResult> {
    type EncodedOption<'buf> = WireOptionalProtocolErrorVectorCompoundResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorVectorCompoundResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolErrorVectorCompoundResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorVectorCompoundResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireProtocolErrorVectorCompoundResult<'buf>>
    for ProtocolErrorVectorCompoundResult
{
    fn take_from(from: &mut WireProtocolErrorVectorCompoundResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalProtocolErrorVectorCompoundResult<'buf>>
    for Option<Box<ProtocolErrorVectorCompoundResult>>
{
    fn take_from(from: &mut WireOptionalProtocolErrorVectorCompoundResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorVectorCompoundResult`].
#[repr(transparent)]
pub struct WireProtocolErrorVectorCompoundResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod protocol_error_vector_compound_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireVectorCompound<'buf>),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireVectorCompound<'buf>),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireProtocolErrorVectorCompoundResult<'buf> {
    pub fn as_ref(&self) -> crate::protocol_error_vector_compound_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_vector_compound_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_vector_compound_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::protocol_error_vector_compound_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_vector_compound_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::protocol_error_vector_compound_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireProtocolErrorVectorCompoundResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireVectorCompound<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorCompound<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireProtocolErrorVectorCompoundResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireVectorCompound<'buf>>().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorVectorCompoundResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalProtocolErrorVectorCompoundResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorVectorCompoundResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireProtocolErrorVectorCompoundResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireProtocolErrorVectorCompoundResult<'buf>> {
        if self.is_some() {
            Some(WireProtocolErrorVectorCompoundResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalProtocolErrorVectorCompoundResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorVectorCompoundResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireVectorCompound<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorCompound<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalProtocolErrorVectorCompoundResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct VectorOptional {
    pub opt_vector_uint8: Option<Vec<u8>>,

    pub opt_vector_string: Option<Vec<String>>,

    pub opt_vector_struct: Option<Vec<crate::Struct>>,

    pub opt_vector_opt_struct: Option<Vec<Option<Box<crate::Struct>>>>,
}

impl ::fidl_next::Encodable for VectorOptional {
    type Encoded<'buf> = WireVectorOptional<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for VectorOptional
where
    Option<Vec<u8>>: ::fidl_next::Encode<___E>,

    Option<Vec<String>>: ::fidl_next::Encode<___E>,

    Option<Vec<crate::Struct>>: ::fidl_next::Encode<___E>,

    Option<Vec<Option<Box<crate::Struct>>>>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.opt_vector_uint8, encoder, opt_vector_uint8)?;

        ::fidl_next::Encode::encode(&mut self.opt_vector_string, encoder, opt_vector_string)?;

        ::fidl_next::Encode::encode(&mut self.opt_vector_struct, encoder, opt_vector_struct)?;

        ::fidl_next::Encode::encode(
            &mut self.opt_vector_opt_struct,
            encoder,
            opt_vector_opt_struct,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<VectorOptional> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireVectorOptional<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<VectorOptional>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorOptional: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireVectorOptional<'buf>> for VectorOptional {
    fn take_from(from: &mut WireVectorOptional<'buf>) -> Self {
        Self {
            opt_vector_uint8: ::fidl_next::TakeFrom::take_from(&mut from.opt_vector_uint8),

            opt_vector_string: ::fidl_next::TakeFrom::take_from(&mut from.opt_vector_string),

            opt_vector_struct: ::fidl_next::TakeFrom::take_from(&mut from.opt_vector_struct),

            opt_vector_opt_struct: ::fidl_next::TakeFrom::take_from(
                &mut from.opt_vector_opt_struct,
            ),
        }
    }
}

/// The wire type corersponding to [`VectorOptional`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorOptional<'buf> {
    pub opt_vector_uint8: ::fidl_next::WireOptionalVector<'buf, u8>,

    pub opt_vector_string: ::fidl_next::WireOptionalVector<'buf, ::fidl_next::WireString<'buf>>,

    pub opt_vector_struct: ::fidl_next::WireOptionalVector<'buf, crate::WireStruct>,

    pub opt_vector_opt_struct:
        ::fidl_next::WireOptionalVector<'buf, ::fidl_next::WireBox<'buf, crate::WireStruct>>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireVectorOptional<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireOptionalVector<'buf, u8>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireOptionalVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireOptionalVector<'buf, crate::WireStruct>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireOptionalVector<'buf, ::fidl_next::WireBox<'buf, crate::WireStruct>>:
        ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut opt_vector_uint8,
                mut opt_vector_string,
                mut opt_vector_struct,
                mut opt_vector_opt_struct,

            } = slot;
        }

        ::fidl_next::Decode::decode(opt_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_opt_struct.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorVectorOptionalResult {
    Response(crate::VectorOptional),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorVectorOptionalResult {
    type Encoded<'buf> = WireProtocolErrorVectorOptionalResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorVectorOptionalResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::VectorOptional: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorVectorOptionalResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::VectorOptional,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorVectorOptionalResult> {
    type EncodedOption<'buf> = WireOptionalProtocolErrorVectorOptionalResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorVectorOptionalResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolErrorVectorOptionalResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorVectorOptionalResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireProtocolErrorVectorOptionalResult<'buf>>
    for ProtocolErrorVectorOptionalResult
{
    fn take_from(from: &mut WireProtocolErrorVectorOptionalResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalProtocolErrorVectorOptionalResult<'buf>>
    for Option<Box<ProtocolErrorVectorOptionalResult>>
{
    fn take_from(from: &mut WireOptionalProtocolErrorVectorOptionalResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorVectorOptionalResult`].
#[repr(transparent)]
pub struct WireProtocolErrorVectorOptionalResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod protocol_error_vector_optional_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireVectorOptional<'buf>),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireVectorOptional<'buf>),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireProtocolErrorVectorOptionalResult<'buf> {
    pub fn as_ref(&self) -> crate::protocol_error_vector_optional_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_vector_optional_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_vector_optional_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::protocol_error_vector_optional_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_vector_optional_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::protocol_error_vector_optional_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireProtocolErrorVectorOptionalResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireVectorOptional<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorOptional<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireProtocolErrorVectorOptionalResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireVectorOptional<'buf>>().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorVectorOptionalResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalProtocolErrorVectorOptionalResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorVectorOptionalResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireProtocolErrorVectorOptionalResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireProtocolErrorVectorOptionalResult<'buf>> {
        if self.is_some() {
            Some(WireProtocolErrorVectorOptionalResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalProtocolErrorVectorOptionalResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorVectorOptionalResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireVectorOptional<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorOptional<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalProtocolErrorVectorOptionalResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorArrayVectorNestedResult {
    Response(crate::ArrayVectorNested),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorArrayVectorNestedResult {
    type Encoded<'buf> = WireProtocolErrorArrayVectorNestedResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorArrayVectorNestedResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::ArrayVectorNested: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorArrayVectorNestedResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::ArrayVectorNested,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorArrayVectorNestedResult> {
    type EncodedOption<'buf> = WireOptionalProtocolErrorArrayVectorNestedResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorArrayVectorNestedResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolErrorArrayVectorNestedResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorArrayVectorNestedResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireProtocolErrorArrayVectorNestedResult<'buf>>
    for ProtocolErrorArrayVectorNestedResult
{
    fn take_from(from: &mut WireProtocolErrorArrayVectorNestedResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalProtocolErrorArrayVectorNestedResult<'buf>>
    for Option<Box<ProtocolErrorArrayVectorNestedResult>>
{
    fn take_from(from: &mut WireOptionalProtocolErrorArrayVectorNestedResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorArrayVectorNestedResult`].
#[repr(transparent)]
pub struct WireProtocolErrorArrayVectorNestedResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod protocol_error_array_vector_nested_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireArrayVectorNested<'buf>),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireArrayVectorNested<'buf>),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireProtocolErrorArrayVectorNestedResult<'buf> {
    pub fn as_ref(&self) -> crate::protocol_error_array_vector_nested_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_array_vector_nested_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_array_vector_nested_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::protocol_error_array_vector_nested_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_array_vector_nested_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::protocol_error_array_vector_nested_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireProtocolErrorArrayVectorNestedResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireArrayVectorNested<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayVectorNested<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireProtocolErrorArrayVectorNestedResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireArrayVectorNested<'buf>>().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorArrayVectorNestedResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalProtocolErrorArrayVectorNestedResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorArrayVectorNestedResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireProtocolErrorArrayVectorNestedResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireProtocolErrorArrayVectorNestedResult<'buf>> {
        if self.is_some() {
            Some(WireProtocolErrorArrayVectorNestedResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalProtocolErrorArrayVectorNestedResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorArrayVectorNestedResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireArrayVectorNested<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayVectorNested<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalProtocolErrorArrayVectorNestedResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Debug)]
pub struct ResourceStruct {}

impl ::fidl_next::Encodable for ResourceStruct {
    type Encoded<'buf> = WireResourceStruct;
}

impl<___E> ::fidl_next::Encode<___E> for ResourceStruct {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ResourceStruct> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireResourceStruct>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ResourceStruct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ResourceStruct: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResourceStruct> for ResourceStruct {
    fn take_from(from: &mut WireResourceStruct) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`ResourceStruct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResourceStruct {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceStruct
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Debug)]
pub struct ResourceTable {}

impl ResourceTable {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for ResourceTable {
    type Encoded<'buf> = WireResourceTable<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ResourceTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireResourceTable<'buf>> for ResourceTable {
    fn take_from(from: &mut WireResourceTable<'buf>) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`ResourceTable`].
#[repr(C)]
pub struct WireResourceTable<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireResourceTable<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireResourceTable<'buf> {}

impl ::core::fmt::Debug for WireResourceTable<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ResourceTable").finish()
    }
}

#[derive(Debug)]
pub enum ResourceUnion {
    B(bool),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for ResourceUnion {
    type Encoded<'buf> = WireResourceUnion;
}

impl<___E> ::fidl_next::Encode<___E> for ResourceUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceUnion { raw, _phantom: _ } = slot);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ResourceUnion> {
    type EncodedOption<'buf> = WireOptionalResourceUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ResourceUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ResourceUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalResourceUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResourceUnion> for ResourceUnion {
    fn take_from(from: &mut WireResourceUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::B(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalResourceUnion> for Option<Box<ResourceUnion>> {
    fn take_from(from: &mut WireOptionalResourceUnion) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ResourceUnion`].
#[repr(transparent)]
pub struct WireResourceUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod resource_union {
    pub enum Ref<'union> {
        B(&'union bool),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        B(&'union mut bool),

        UnknownOrdinal(u64),
    }
}

impl WireResourceUnion {
    pub fn as_ref(&self) -> crate::resource_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::resource_union::Ref::B(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::resource_union::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::resource_union::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::resource_union::Mut::B(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            unknown => crate::resource_union::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireResourceUnion
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalResourceUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalResourceUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireResourceUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireResourceUnion> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireResourceUnion> {
        if self.is_some() {
            Some(WireResourceUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalResourceUnion {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalResourceUnion
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Debug)]
pub struct Resource {
    pub handle: ::fidl_next::zx::Handle,

    pub vmo: ::fidl_next::zx::Handle,

    pub client_end: ::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::Protocol>,

    pub server_end: ::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::Protocol>,

    pub r#struct: crate::ResourceStruct,

    pub table: crate::ResourceTable,

    pub r#union: crate::ResourceUnion,

    pub opt_handle: Option<::fidl_next::zx::Handle>,

    pub opt_vmo: Option<::fidl_next::zx::Handle>,

    pub opt_client_end:
        ::fidl_next::bind::ClientEnd<Option<::fidl_next::zx::Handle>, crate::Protocol>,

    pub opt_server_end:
        ::fidl_next::bind::ServerEnd<Option<::fidl_next::zx::Handle>, crate::Protocol>,

    pub opt_struct: Option<Box<crate::ResourceStruct>>,

    pub opt_union: Option<Box<crate::ResourceUnion>>,

    pub array_handle: [::fidl_next::zx::Handle; 5],

    pub array_vmo: [::fidl_next::zx::Handle; 5],

    pub array_client_end:
        [::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::Protocol>; 5],

    pub array_server_end:
        [::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::Protocol>; 5],

    pub array_struct: [crate::ResourceStruct; 5],

    pub array_table: [crate::ResourceTable; 5],

    pub array_union: [crate::ResourceUnion; 5],

    pub vector_handle: Vec<::fidl_next::zx::Handle>,

    pub vector_vmo: Vec<::fidl_next::zx::Handle>,

    pub vector_client_end:
        Vec<::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::Protocol>>,

    pub vector_server_end:
        Vec<::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::Protocol>>,

    pub vector_struct: Vec<crate::ResourceStruct>,

    pub vector_table: Vec<crate::ResourceTable>,

    pub vector_union: Vec<crate::ResourceUnion>,
}

impl ::fidl_next::Encodable for Resource {
    type Encoded<'buf> = WireResource<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Resource
where
    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,

    ::fidl_next::zx::Handle: ::fidl_next::Encode<___E>,

    ::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::Protocol>:
        ::fidl_next::Encode<___E>,

    ::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::Protocol>:
        ::fidl_next::Encode<___E>,

    crate::ResourceStruct: ::fidl_next::Encode<___E>,

    crate::ResourceTable: ::fidl_next::Encode<___E>,

    crate::ResourceUnion: ::fidl_next::Encode<___E>,

    Option<::fidl_next::zx::Handle>: ::fidl_next::Encode<___E>,

    Option<::fidl_next::zx::Handle>: ::fidl_next::Encode<___E>,

    ::fidl_next::bind::ClientEnd<Option<::fidl_next::zx::Handle>, crate::Protocol>:
        ::fidl_next::Encode<___E>,

    ::fidl_next::bind::ServerEnd<Option<::fidl_next::zx::Handle>, crate::Protocol>:
        ::fidl_next::Encode<___E>,

    Option<Box<crate::ResourceStruct>>: ::fidl_next::Encode<___E>,

    Option<Box<crate::ResourceUnion>>: ::fidl_next::Encode<___E>,

    [::fidl_next::zx::Handle; 5]: ::fidl_next::Encode<___E>,

    [::fidl_next::zx::Handle; 5]: ::fidl_next::Encode<___E>,

    [::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::Protocol>; 5]:
        ::fidl_next::Encode<___E>,

    [::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::Protocol>; 5]:
        ::fidl_next::Encode<___E>,

    [crate::ResourceStruct; 5]: ::fidl_next::Encode<___E>,

    [crate::ResourceTable; 5]: ::fidl_next::Encode<___E>,

    [crate::ResourceUnion; 5]: ::fidl_next::Encode<___E>,

    Vec<::fidl_next::zx::Handle>: ::fidl_next::Encode<___E>,

    Vec<::fidl_next::zx::Handle>: ::fidl_next::Encode<___E>,

    Vec<::fidl_next::bind::ClientEnd<::fidl_next::zx::Handle, crate::Protocol>>:
        ::fidl_next::Encode<___E>,

    Vec<::fidl_next::bind::ServerEnd<::fidl_next::zx::Handle, crate::Protocol>>:
        ::fidl_next::Encode<___E>,

    Vec<crate::ResourceStruct>: ::fidl_next::Encode<___E>,

    Vec<crate::ResourceTable>: ::fidl_next::Encode<___E>,

    Vec<crate::ResourceUnion>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                handle,
                vmo,
                client_end,
                server_end,
                r#struct,
                table,
                r#union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.handle, encoder, handle)?;

        ::fidl_next::Encode::encode(&mut self.vmo, encoder, vmo)?;

        ::fidl_next::Encode::encode(&mut self.client_end, encoder, client_end)?;

        ::fidl_next::Encode::encode(&mut self.server_end, encoder, server_end)?;

        ::fidl_next::Encode::encode(&mut self.r#struct, encoder, r#struct)?;

        ::fidl_next::Encode::encode(&mut self.table, encoder, table)?;

        ::fidl_next::Encode::encode(&mut self.r#union, encoder, r#union)?;

        ::fidl_next::Encode::encode(&mut self.opt_handle, encoder, opt_handle)?;

        ::fidl_next::Encode::encode(&mut self.opt_vmo, encoder, opt_vmo)?;

        ::fidl_next::Encode::encode(&mut self.opt_client_end, encoder, opt_client_end)?;

        ::fidl_next::Encode::encode(&mut self.opt_server_end, encoder, opt_server_end)?;

        ::fidl_next::Encode::encode(&mut self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.opt_union, encoder, opt_union)?;

        ::fidl_next::Encode::encode(&mut self.array_handle, encoder, array_handle)?;

        ::fidl_next::Encode::encode(&mut self.array_vmo, encoder, array_vmo)?;

        ::fidl_next::Encode::encode(&mut self.array_client_end, encoder, array_client_end)?;

        ::fidl_next::Encode::encode(&mut self.array_server_end, encoder, array_server_end)?;

        ::fidl_next::Encode::encode(&mut self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(&mut self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(&mut self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(&mut self.vector_handle, encoder, vector_handle)?;

        ::fidl_next::Encode::encode(&mut self.vector_vmo, encoder, vector_vmo)?;

        ::fidl_next::Encode::encode(&mut self.vector_client_end, encoder, vector_client_end)?;

        ::fidl_next::Encode::encode(&mut self.vector_server_end, encoder, vector_server_end)?;

        ::fidl_next::Encode::encode(&mut self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(&mut self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(&mut self.vector_union, encoder, vector_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Resource> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireResource<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Resource>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Resource: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireResource<'buf>> for Resource {
    fn take_from(from: &mut WireResource<'buf>) -> Self {
        Self {
            handle: ::fidl_next::TakeFrom::take_from(&mut from.handle),

            vmo: ::fidl_next::TakeFrom::take_from(&mut from.vmo),

            client_end: ::fidl_next::TakeFrom::take_from(&mut from.client_end),

            server_end: ::fidl_next::TakeFrom::take_from(&mut from.server_end),

            r#struct: ::fidl_next::TakeFrom::take_from(&mut from.r#struct),

            table: ::fidl_next::TakeFrom::take_from(&mut from.table),

            r#union: ::fidl_next::TakeFrom::take_from(&mut from.r#union),

            opt_handle: ::fidl_next::TakeFrom::take_from(&mut from.opt_handle),

            opt_vmo: ::fidl_next::TakeFrom::take_from(&mut from.opt_vmo),

            opt_client_end: ::fidl_next::TakeFrom::take_from(&mut from.opt_client_end),

            opt_server_end: ::fidl_next::TakeFrom::take_from(&mut from.opt_server_end),

            opt_struct: ::fidl_next::TakeFrom::take_from(&mut from.opt_struct),

            opt_union: ::fidl_next::TakeFrom::take_from(&mut from.opt_union),

            array_handle: ::fidl_next::TakeFrom::take_from(&mut from.array_handle),

            array_vmo: ::fidl_next::TakeFrom::take_from(&mut from.array_vmo),

            array_client_end: ::fidl_next::TakeFrom::take_from(&mut from.array_client_end),

            array_server_end: ::fidl_next::TakeFrom::take_from(&mut from.array_server_end),

            array_struct: ::fidl_next::TakeFrom::take_from(&mut from.array_struct),

            array_table: ::fidl_next::TakeFrom::take_from(&mut from.array_table),

            array_union: ::fidl_next::TakeFrom::take_from(&mut from.array_union),

            vector_handle: ::fidl_next::TakeFrom::take_from(&mut from.vector_handle),

            vector_vmo: ::fidl_next::TakeFrom::take_from(&mut from.vector_vmo),

            vector_client_end: ::fidl_next::TakeFrom::take_from(&mut from.vector_client_end),

            vector_server_end: ::fidl_next::TakeFrom::take_from(&mut from.vector_server_end),

            vector_struct: ::fidl_next::TakeFrom::take_from(&mut from.vector_struct),

            vector_table: ::fidl_next::TakeFrom::take_from(&mut from.vector_table),

            vector_union: ::fidl_next::TakeFrom::take_from(&mut from.vector_union),
        }
    }
}

/// The wire type corersponding to [`Resource`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResource<'buf> {
    pub handle: ::fidl_next::WireHandle,

    pub vmo: ::fidl_next::WireHandle,

    pub client_end: ::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::Protocol>,

    pub server_end: ::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::Protocol>,

    pub r#struct: crate::WireResourceStruct,

    pub table: crate::WireResourceTable<'buf>,

    pub r#union: crate::WireResourceUnion,

    pub opt_handle: ::fidl_next::WireOptionalHandle,

    pub opt_vmo: ::fidl_next::WireOptionalHandle,

    pub opt_client_end:
        ::fidl_next::bind::ClientEnd<::fidl_next::WireOptionalHandle, crate::Protocol>,

    pub opt_server_end:
        ::fidl_next::bind::ServerEnd<::fidl_next::WireOptionalHandle, crate::Protocol>,

    pub opt_struct: ::fidl_next::WireBox<'buf, crate::WireResourceStruct>,

    pub opt_union: crate::WireOptionalResourceUnion,

    pub array_handle: [::fidl_next::WireHandle; 5],

    pub array_vmo: [::fidl_next::WireHandle; 5],

    pub array_client_end:
        [::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::Protocol>; 5],

    pub array_server_end:
        [::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::Protocol>; 5],

    pub array_struct: [crate::WireResourceStruct; 5],

    pub array_table: [crate::WireResourceTable<'buf>; 5],

    pub array_union: [crate::WireResourceUnion; 5],

    pub vector_handle: ::fidl_next::WireVector<'buf, ::fidl_next::WireHandle>,

    pub vector_vmo: ::fidl_next::WireVector<'buf, ::fidl_next::WireHandle>,

    pub vector_client_end: ::fidl_next::WireVector<
        'buf,
        ::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::Protocol>,
    >,

    pub vector_server_end: ::fidl_next::WireVector<
        'buf,
        ::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::Protocol>,
    >,

    pub vector_struct: ::fidl_next::WireVector<'buf, crate::WireResourceStruct>,

    pub vector_table: ::fidl_next::WireVector<'buf, crate::WireResourceTable<'buf>>,

    pub vector_union: ::fidl_next::WireVector<'buf, crate::WireResourceUnion>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireResource<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,

    ::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::Protocol>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::Protocol>:
        ::fidl_next::Decode<___D>,

    crate::WireResourceStruct: ::fidl_next::Decode<___D>,

    crate::WireResourceTable<'buf>: ::fidl_next::Decode<___D>,

    crate::WireResourceUnion: ::fidl_next::Decode<___D>,

    ::fidl_next::WireOptionalHandle: ::fidl_next::Decode<___D>,

    ::fidl_next::WireOptionalHandle: ::fidl_next::Decode<___D>,

    ::fidl_next::bind::ClientEnd<::fidl_next::WireOptionalHandle, crate::Protocol>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::bind::ServerEnd<::fidl_next::WireOptionalHandle, crate::Protocol>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireBox<'buf, crate::WireResourceStruct>: ::fidl_next::Decode<___D>,

    crate::WireOptionalResourceUnion: ::fidl_next::Decode<___D>,

    [::fidl_next::WireHandle; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::WireHandle; 5]: ::fidl_next::Decode<___D>,

    [::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::Protocol>; 5]:
        ::fidl_next::Decode<___D>,

    [::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::Protocol>; 5]:
        ::fidl_next::Decode<___D>,

    [crate::WireResourceStruct; 5]: ::fidl_next::Decode<___D>,

    [crate::WireResourceTable<'buf>; 5]: ::fidl_next::Decode<___D>,

    [crate::WireResourceUnion; 5]: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireHandle>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireHandle>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<
        'buf,
        ::fidl_next::bind::ClientEnd<::fidl_next::WireHandle, crate::Protocol>,
    >: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<
        'buf,
        ::fidl_next::bind::ServerEnd<::fidl_next::WireHandle, crate::Protocol>,
    >: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, crate::WireResourceStruct>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, crate::WireResourceTable<'buf>>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, crate::WireResourceUnion>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut handle,
                mut vmo,
                mut client_end,
                mut server_end,
                mut r#struct,
                mut table,
                mut r#union,
                mut opt_handle,
                mut opt_vmo,
                mut opt_client_end,
                mut opt_server_end,
                mut opt_struct,
                mut opt_union,
                mut array_handle,
                mut array_vmo,
                mut array_client_end,
                mut array_server_end,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut vector_handle,
                mut vector_vmo,
                mut vector_client_end,
                mut vector_server_end,
                mut vector_struct,
                mut vector_table,
                mut vector_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r#struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r#union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub enum ProtocolErrorResourceResult {
    Response(crate::Resource),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorResourceResult {
    type Encoded<'buf> = WireProtocolErrorResourceResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorResourceResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::Resource: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorResourceResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<___E, crate::Resource>(
                value, 1, encoder, raw,
            )?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorResourceResult> {
    type EncodedOption<'buf> = WireOptionalProtocolErrorResourceResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorResourceResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolErrorResourceResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorResourceResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireProtocolErrorResourceResult<'buf>>
    for ProtocolErrorResourceResult
{
    fn take_from(from: &mut WireProtocolErrorResourceResult<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalProtocolErrorResourceResult<'buf>>
    for Option<Box<ProtocolErrorResourceResult>>
{
    fn take_from(from: &mut WireOptionalProtocolErrorResourceResult<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorResourceResult`].
#[repr(transparent)]
pub struct WireProtocolErrorResourceResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod protocol_error_resource_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireResource<'buf>),

        Err(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireResource<'buf>),

        Err(&'union mut ::fidl_next::u32_le),
    }
}

impl<'buf> WireProtocolErrorResourceResult<'buf> {
    pub fn as_ref(&self) -> crate::protocol_error_resource_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_resource_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_resource_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::protocol_error_resource_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_resource_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::protocol_error_resource_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireProtocolErrorResourceResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireResource<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireResource<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireProtocolErrorResourceResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireResource<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorResourceResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalProtocolErrorResourceResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorResourceResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireProtocolErrorResourceResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireProtocolErrorResourceResult<'buf>> {
        if self.is_some() {
            Some(WireProtocolErrorResourceResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalProtocolErrorResourceResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorResourceResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireResource<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireResource<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalProtocolErrorResourceResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the Protocol protocol.
#[derive(Debug)]
pub struct Protocol;

pub mod protocol {

    pub struct OneWayBasic;

    impl ::fidl_next::bind::Method for OneWayBasic {
        const ORDINAL: u64 = 8948968077914418681;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireBasic<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct TwoWayBasic;

    impl ::fidl_next::bind::Method for TwoWayBasic {
        const ORDINAL: u64 = 2331618702752598159;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireBasic<'buf>;

        type Response<'buf> = crate::WireBasic<'buf>;
    }

    pub struct ErrorBasic;

    impl ::fidl_next::bind::Method for ErrorBasic {
        const ORDINAL: u64 = 5016634351643393939;

        type Protocol = crate::Protocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireProtocolErrorBasicResult<'buf>;
    }

    pub struct EventBasic;

    impl ::fidl_next::bind::Method for EventBasic {
        const ORDINAL: u64 = 5892309624949902400;

        type Protocol = crate::Protocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireBasic<'buf>;
    }

    pub struct OneWayCompound;

    impl ::fidl_next::bind::Method for OneWayCompound {
        const ORDINAL: u64 = 3153289648860022476;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireCompound<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct TwoWayCompound;

    impl ::fidl_next::bind::Method for TwoWayCompound {
        const ORDINAL: u64 = 8787219719097524529;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireCompound<'buf>;

        type Response<'buf> = crate::WireCompound<'buf>;
    }

    pub struct ErrorCompound;

    impl ::fidl_next::bind::Method for ErrorCompound {
        const ORDINAL: u64 = 2990809657626249085;

        type Protocol = crate::Protocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireProtocolErrorCompoundResult<'buf>;
    }

    pub struct EventCompound;

    impl ::fidl_next::bind::Method for EventCompound {
        const ORDINAL: u64 = 7024581948727571669;

        type Protocol = crate::Protocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireCompound<'buf>;
    }

    pub struct OneWayArrayBasic;

    impl ::fidl_next::bind::Method for OneWayArrayBasic {
        const ORDINAL: u64 = 7125516817014311449;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireArrayBasic<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct TwoWayArrayBasic;

    impl ::fidl_next::bind::Method for TwoWayArrayBasic {
        const ORDINAL: u64 = 5309034178175279380;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireArrayBasic<'buf>;

        type Response<'buf> = crate::WireArrayBasic<'buf>;
    }

    pub struct ErrorArrayBasic;

    impl ::fidl_next::bind::Method for ErrorArrayBasic {
        const ORDINAL: u64 = 1084731895342694265;

        type Protocol = crate::Protocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireProtocolErrorArrayBasicResult<'buf>;
    }

    pub struct EventArrayBasic;

    impl ::fidl_next::bind::Method for EventArrayBasic {
        const ORDINAL: u64 = 5888282827283820590;

        type Protocol = crate::Protocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireArrayBasic<'buf>;
    }

    pub struct OneWayArrayCompound;

    impl ::fidl_next::bind::Method for OneWayArrayCompound {
        const ORDINAL: u64 = 5064659223443251357;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireArrayCompound<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct TwoWayArrayCompound;

    impl ::fidl_next::bind::Method for TwoWayArrayCompound {
        const ORDINAL: u64 = 849744466051983995;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireArrayCompound<'buf>;

        type Response<'buf> = crate::WireArrayCompound<'buf>;
    }

    pub struct ErrorArrayCompound;

    impl ::fidl_next::bind::Method for ErrorArrayCompound {
        const ORDINAL: u64 = 5919277476782807556;

        type Protocol = crate::Protocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireProtocolErrorArrayCompoundResult<'buf>;
    }

    pub struct EventArrayCompound;

    impl ::fidl_next::bind::Method for EventArrayCompound {
        const ORDINAL: u64 = 2189769767733851157;

        type Protocol = crate::Protocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireArrayCompound<'buf>;
    }

    pub struct OneWayVectorBasic;

    impl ::fidl_next::bind::Method for OneWayVectorBasic {
        const ORDINAL: u64 = 5733220720079947351;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireVectorBasic<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct TwoWayVectorBasic;

    impl ::fidl_next::bind::Method for TwoWayVectorBasic {
        const ORDINAL: u64 = 8674156353091415668;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireVectorBasic<'buf>;

        type Response<'buf> = crate::WireVectorBasic<'buf>;
    }

    pub struct ErrorVectorBasic;

    impl ::fidl_next::bind::Method for ErrorVectorBasic {
        const ORDINAL: u64 = 875941614196965234;

        type Protocol = crate::Protocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireProtocolErrorVectorBasicResult<'buf>;
    }

    pub struct EventVectorBasic;

    impl ::fidl_next::bind::Method for EventVectorBasic {
        const ORDINAL: u64 = 4583890770109526006;

        type Protocol = crate::Protocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireVectorBasic<'buf>;
    }

    pub struct OneWayVectorCompound;

    impl ::fidl_next::bind::Method for OneWayVectorCompound {
        const ORDINAL: u64 = 1853985797298830992;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireVectorCompound<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct TwoWayVectorCompound;

    impl ::fidl_next::bind::Method for TwoWayVectorCompound {
        const ORDINAL: u64 = 3968024057912959924;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireVectorCompound<'buf>;

        type Response<'buf> = crate::WireVectorCompound<'buf>;
    }

    pub struct ErrorVectorCompound;

    impl ::fidl_next::bind::Method for ErrorVectorCompound {
        const ORDINAL: u64 = 8506780203315865989;

        type Protocol = crate::Protocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireProtocolErrorVectorCompoundResult<'buf>;
    }

    pub struct EventVectorCompound;

    impl ::fidl_next::bind::Method for EventVectorCompound {
        const ORDINAL: u64 = 6026375226599919603;

        type Protocol = crate::Protocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireVectorCompound<'buf>;
    }

    pub struct OneWayVectorOptional;

    impl ::fidl_next::bind::Method for OneWayVectorOptional {
        const ORDINAL: u64 = 1530215841195476271;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireVectorOptional<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct TwoWayVectorOptional;

    impl ::fidl_next::bind::Method for TwoWayVectorOptional {
        const ORDINAL: u64 = 1030024737742222323;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireVectorOptional<'buf>;

        type Response<'buf> = crate::WireVectorOptional<'buf>;
    }

    pub struct ErrorVectorOptional;

    impl ::fidl_next::bind::Method for ErrorVectorOptional {
        const ORDINAL: u64 = 6406191217027936606;

        type Protocol = crate::Protocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireProtocolErrorVectorOptionalResult<'buf>;
    }

    pub struct EventVectorOptional;

    impl ::fidl_next::bind::Method for EventVectorOptional {
        const ORDINAL: u64 = 1684763340073130077;

        type Protocol = crate::Protocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireVectorOptional<'buf>;
    }

    pub struct OneWayArrayVectorNested;

    impl ::fidl_next::bind::Method for OneWayArrayVectorNested {
        const ORDINAL: u64 = 5912603762133524183;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireArrayVectorNested<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct TwoWayArrayVectorNested;

    impl ::fidl_next::bind::Method for TwoWayArrayVectorNested {
        const ORDINAL: u64 = 5351275678438791132;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireArrayVectorNested<'buf>;

        type Response<'buf> = crate::WireArrayVectorNested<'buf>;
    }

    pub struct ErrorArrayVectorNested;

    impl ::fidl_next::bind::Method for ErrorArrayVectorNested {
        const ORDINAL: u64 = 9085604921605802151;

        type Protocol = crate::Protocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireProtocolErrorArrayVectorNestedResult<'buf>;
    }

    pub struct EventArrayVectorNested;

    impl ::fidl_next::bind::Method for EventArrayVectorNested {
        const ORDINAL: u64 = 1228201560727880574;

        type Protocol = crate::Protocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireArrayVectorNested<'buf>;
    }

    pub struct OneWayResource;

    impl ::fidl_next::bind::Method for OneWayResource {
        const ORDINAL: u64 = 6553996787849601058;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireResource<'buf>;

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct TwoWayResource;

    impl ::fidl_next::bind::Method for TwoWayResource {
        const ORDINAL: u64 = 1802709005492464987;

        type Protocol = crate::Protocol;

        type Request<'buf> = crate::WireResource<'buf>;

        type Response<'buf> = crate::WireResource<'buf>;
    }

    pub struct ErrorResource;

    impl ::fidl_next::bind::Method for ErrorResource {
        const ORDINAL: u64 = 6568609240497354166;

        type Protocol = crate::Protocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireProtocolErrorResourceResult<'buf>;
    }

    pub struct EventResource;

    impl ::fidl_next::bind::Method for EventResource {
        const ORDINAL: u64 = 5745997765922613643;

        type Protocol = crate::Protocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireResource<'buf>;
    }
}

/// A helper trait for the `Protocol` client protocol.
pub trait ProtocolClient<___T: ::fidl_next::protocol::Transport> {
    fn one_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireBasic<'buf>>;

    fn two_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireBasic<'buf>>;

    fn error_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireCompound<'buf>>;

    fn two_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireCompound<'buf>>;

    fn error_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireArrayBasic<'buf>>;

    fn two_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayArrayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireArrayBasic<'buf>>;

    fn error_array_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorArrayBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireArrayCompound<'buf>,
        >;

    fn two_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayArrayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireArrayCompound<'buf>,
        >;

    fn error_array_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorArrayCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireVectorBasic<'buf>>;

    fn two_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayVectorBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireVectorBasic<'buf>>;

    fn error_vector_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorVectorBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireVectorCompound<'buf>,
        >;

    fn two_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayVectorCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireVectorCompound<'buf>,
        >;

    fn error_vector_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorVectorCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireVectorOptional<'buf>,
        >;

    fn two_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayVectorOptional>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireVectorOptional<'buf>,
        >;

    fn error_vector_optional(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorVectorOptional>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireArrayVectorNested<'buf>,
        >;

    fn two_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayArrayVectorNested>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireArrayVectorNested<'buf>,
        >;

    fn error_array_vector_nested(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorArrayVectorNested>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireResource<'buf>>;

    fn two_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayResource>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireResource<'buf>>;

    fn error_resource(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorResource>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> ProtocolClient<___T> for ::fidl_next::bind::Client<___T, Protocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn one_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireBasic<'buf>>,
    {
        self.untyped().send_request(8948968077914418681, request)
    }

    fn two_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireBasic<'buf>>,
    {
        self.untyped()
            .send_transaction(2331618702752598159, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn error_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorBasic>,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(5016634351643393939, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn one_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireCompound<'buf>>,
    {
        self.untyped().send_request(3153289648860022476, request)
    }

    fn two_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireCompound<'buf>>,
    {
        self.untyped()
            .send_transaction(8787219719097524529, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn error_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorCompound>,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(2990809657626249085, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn one_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireArrayBasic<'buf>>,
    {
        self.untyped().send_request(7125516817014311449, request)
    }

    fn two_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayArrayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireArrayBasic<'buf>>,
    {
        self.untyped()
            .send_transaction(5309034178175279380, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn error_array_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorArrayBasic>,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(1084731895342694265, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn one_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireArrayCompound<'buf>,
        >,
    {
        self.untyped().send_request(5064659223443251357, request)
    }

    fn two_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayArrayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireArrayCompound<'buf>,
        >,
    {
        self.untyped()
            .send_transaction(849744466051983995, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn error_array_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorArrayCompound>,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(5919277476782807556, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn one_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireVectorBasic<'buf>>,
    {
        self.untyped().send_request(5733220720079947351, request)
    }

    fn two_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayVectorBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireVectorBasic<'buf>>,
    {
        self.untyped()
            .send_transaction(8674156353091415668, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn error_vector_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorVectorBasic>,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(875941614196965234, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn one_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireVectorCompound<'buf>,
        >,
    {
        self.untyped().send_request(1853985797298830992, request)
    }

    fn two_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayVectorCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireVectorCompound<'buf>,
        >,
    {
        self.untyped()
            .send_transaction(3968024057912959924, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn error_vector_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorVectorCompound>,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(8506780203315865989, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn one_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireVectorOptional<'buf>,
        >,
    {
        self.untyped().send_request(1530215841195476271, request)
    }

    fn two_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayVectorOptional>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireVectorOptional<'buf>,
        >,
    {
        self.untyped()
            .send_transaction(1030024737742222323, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn error_vector_optional(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorVectorOptional>,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(6406191217027936606, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn one_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireArrayVectorNested<'buf>,
        >,
    {
        self.untyped().send_request(5912603762133524183, request)
    }

    fn two_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayArrayVectorNested>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireArrayVectorNested<'buf>,
        >,
    {
        self.untyped()
            .send_transaction(5351275678438791132, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn error_array_vector_nested(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorArrayVectorNested>,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(9085604921605802151, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn one_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireResource<'buf>>,
    {
        self.untyped().send_request(6553996787849601058, request)
    }

    fn two_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::TwoWayResource>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::Encoder<'buf>, Encoded<'buf> = crate::WireResource<'buf>>,
    {
        self.untyped()
            .send_transaction(1802709005492464987, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn error_resource(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, protocol::ErrorResource>,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(6568609240497354166, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }
}

/// A client handler for the Protocol protocol.

pub trait ProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn event_basic(
        &mut self,
        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventBasic>,
    );

    fn event_compound(
        &mut self,
        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventCompound>,
    );

    fn event_array_basic(
        &mut self,
        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventArrayBasic>,
    );

    fn event_array_compound(
        &mut self,
        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventArrayCompound>,
    );

    fn event_vector_basic(
        &mut self,
        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventVectorBasic>,
    );

    fn event_vector_compound(
        &mut self,
        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventVectorCompound>,
    );

    fn event_vector_optional(
        &mut self,
        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventVectorOptional>,
    );

    fn event_array_vector_nested(
        &mut self,
        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventArrayVectorNested>,
    );

    fn event_resource(
        &mut self,
        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventResource>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ProtocolClientHandler<___T>,

    for<'buf> crate::WireBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireProtocolErrorBasicResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireProtocolErrorCompoundResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireProtocolErrorArrayBasicResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireProtocolErrorArrayCompoundResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireProtocolErrorVectorBasicResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireProtocolErrorVectorCompoundResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorOptional<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireProtocolErrorVectorOptionalResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorOptional<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayVectorNested<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireProtocolErrorArrayVectorNestedResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayVectorNested<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireResource<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireProtocolErrorResourceResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireResource<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(handler: &mut ___H, ordinal: u64, buffer: ___T::RecvBuffer) {
        match ordinal {
            5892309624949902400 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_basic(buffer);
            }

            7024581948727571669 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_compound(buffer);
            }

            5888282827283820590 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_array_basic(buffer);
            }

            2189769767733851157 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_array_compound(buffer);
            }

            4583890770109526006 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_vector_basic(buffer);
            }

            6026375226599919603 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_vector_compound(buffer);
            }

            1684763340073130077 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_vector_optional(buffer);
            }

            1228201560727880574 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_array_vector_nested(buffer);
            }

            5745997765922613643 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_resource(buffer);
            }

            ordinal => todo!(),
        }
    }
}

/// A helper trait for the `Protocol` server protocol.
pub trait ProtocolServer<___T: ::fidl_next::protocol::Transport> {
    fn event_basic(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn event_compound(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn event_array_basic(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn event_array_compound(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn event_vector_basic(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn event_vector_compound(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn event_vector_optional(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn event_array_vector_nested(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn event_resource(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;
}

impl<___T> ProtocolServer<___T> for ::fidl_next::bind::Server<___T, Protocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn event_basic(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.untyped().send_event(5892309624949902400, &mut ())
    }

    fn event_compound(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.untyped().send_event(7024581948727571669, &mut ())
    }

    fn event_array_basic(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.untyped().send_event(5888282827283820590, &mut ())
    }

    fn event_array_compound(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.untyped().send_event(2189769767733851157, &mut ())
    }

    fn event_vector_basic(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.untyped().send_event(4583890770109526006, &mut ())
    }

    fn event_vector_compound(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.untyped().send_event(6026375226599919603, &mut ())
    }

    fn event_vector_optional(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.untyped().send_event(1684763340073130077, &mut ())
    }

    fn event_array_vector_nested(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.untyped().send_event(1228201560727880574, &mut ())
    }

    fn event_resource(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.untyped().send_event(5745997765922613643, &mut ())
    }
}

/// A server handler for the Protocol protocol.

pub trait ProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn one_way_basic(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayBasic>,
    );

    fn two_way_basic(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayBasic>,
        responder: ::fidl_next::bind::Responder<protocol::TwoWayBasic>,
    );

    fn error_basic(&mut self, responder: ::fidl_next::bind::Responder<protocol::ErrorBasic>);

    fn one_way_compound(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayCompound>,
    );

    fn two_way_compound(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayCompound>,
        responder: ::fidl_next::bind::Responder<protocol::TwoWayCompound>,
    );

    fn error_compound(&mut self, responder: ::fidl_next::bind::Responder<protocol::ErrorCompound>);

    fn one_way_array_basic(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayArrayBasic>,
    );

    fn two_way_array_basic(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayArrayBasic>,
        responder: ::fidl_next::bind::Responder<protocol::TwoWayArrayBasic>,
    );

    fn error_array_basic(
        &mut self,
        responder: ::fidl_next::bind::Responder<protocol::ErrorArrayBasic>,
    );

    fn one_way_array_compound(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayArrayCompound>,
    );

    fn two_way_array_compound(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayArrayCompound>,
        responder: ::fidl_next::bind::Responder<protocol::TwoWayArrayCompound>,
    );

    fn error_array_compound(
        &mut self,
        responder: ::fidl_next::bind::Responder<protocol::ErrorArrayCompound>,
    );

    fn one_way_vector_basic(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayVectorBasic>,
    );

    fn two_way_vector_basic(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayVectorBasic>,
        responder: ::fidl_next::bind::Responder<protocol::TwoWayVectorBasic>,
    );

    fn error_vector_basic(
        &mut self,
        responder: ::fidl_next::bind::Responder<protocol::ErrorVectorBasic>,
    );

    fn one_way_vector_compound(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayVectorCompound>,
    );

    fn two_way_vector_compound(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayVectorCompound>,
        responder: ::fidl_next::bind::Responder<protocol::TwoWayVectorCompound>,
    );

    fn error_vector_compound(
        &mut self,
        responder: ::fidl_next::bind::Responder<protocol::ErrorVectorCompound>,
    );

    fn one_way_vector_optional(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayVectorOptional>,
    );

    fn two_way_vector_optional(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayVectorOptional>,
        responder: ::fidl_next::bind::Responder<protocol::TwoWayVectorOptional>,
    );

    fn error_vector_optional(
        &mut self,
        responder: ::fidl_next::bind::Responder<protocol::ErrorVectorOptional>,
    );

    fn one_way_array_vector_nested(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayArrayVectorNested>,
    );

    fn two_way_array_vector_nested(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayArrayVectorNested>,
        responder: ::fidl_next::bind::Responder<protocol::TwoWayArrayVectorNested>,
    );

    fn error_array_vector_nested(
        &mut self,
        responder: ::fidl_next::bind::Responder<protocol::ErrorArrayVectorNested>,
    );

    fn one_way_resource(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayResource>,
    );

    fn two_way_resource(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayResource>,
        responder: ::fidl_next::bind::Responder<protocol::TwoWayResource>,
    );

    fn error_resource(&mut self, responder: ::fidl_next::bind::Responder<protocol::ErrorResource>);
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ProtocolServerHandler<___T>,

    for<'buf> crate::WireBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorBasic<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorCompound<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorOptional<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireVectorOptional<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayVectorNested<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireArrayVectorNested<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireResource<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireResource<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(handler: &mut ___H, ordinal: u64, buffer: ___T::RecvBuffer) {
        match ordinal {
            8948968077914418681 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_basic(buffer);
            }

            3153289648860022476 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_compound(buffer);
            }

            7125516817014311449 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_array_basic(buffer);
            }

            5064659223443251357 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_array_compound(buffer);
            }

            5733220720079947351 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_vector_basic(buffer);
            }

            1853985797298830992 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_vector_compound(buffer);
            }

            1530215841195476271 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_vector_optional(buffer);
            }

            5912603762133524183 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_array_vector_nested(buffer);
            }

            6553996787849601058 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_resource(buffer);
            }

            ordinal => todo!(),
        }
    }

    fn on_transaction(
        handler: &mut ___H,
        ordinal: u64,
        mut buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2331618702752598159 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_basic(buffer, responder);
            }

            5016634351643393939 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_basic(responder);
            }

            8787219719097524529 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_compound(buffer, responder);
            }

            2990809657626249085 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_compound(responder);
            }

            5309034178175279380 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_array_basic(buffer, responder);
            }

            1084731895342694265 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_array_basic(responder);
            }

            849744466051983995 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_array_compound(buffer, responder);
            }

            5919277476782807556 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_array_compound(responder);
            }

            8674156353091415668 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_vector_basic(buffer, responder);
            }

            875941614196965234 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_vector_basic(responder);
            }

            3968024057912959924 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_vector_compound(buffer, responder);
            }

            8506780203315865989 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_vector_compound(responder);
            }

            1030024737742222323 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_vector_optional(buffer, responder);
            }

            6406191217027936606 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_vector_optional(responder);
            }

            5351275678438791132 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_array_vector_nested(buffer, responder);
            }

            9085604921605802151 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_array_vector_nested(responder);
            }

            1802709005492464987 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_resource(buffer, responder);
            }

            6568609240497354166 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_resource(responder);
            }

            ordinal => todo!(),
        }
    }
}
