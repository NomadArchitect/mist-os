// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct Empty {}

impl ::fidl_next::Encodable for Empty {
    type Encoded<'buf> = WireEmpty;
}

impl<___E> ::fidl_next::Encode<___E> for Empty {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Empty> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireEmpty>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Empty>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Empty: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireEmpty> for Empty {
    fn take_from(from: &mut WireEmpty) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`Empty`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireEmpty {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEmpty
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum EmptyFlexibleUnion {
    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for EmptyFlexibleUnion {
    type Encoded<'buf> = WireEmptyFlexibleUnion;
}

impl<___E> ::fidl_next::Encode<___E> for EmptyFlexibleUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEmptyFlexibleUnion { raw, _phantom: _ } = slot);

        match self {
            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<EmptyFlexibleUnion> {
    type EncodedOption<'buf> = WireOptionalEmptyFlexibleUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<EmptyFlexibleUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    EmptyFlexibleUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalEmptyFlexibleUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireEmptyFlexibleUnion> for EmptyFlexibleUnion {
    fn take_from(from: &mut WireEmptyFlexibleUnion) -> Self {
        match from.raw.ordinal() {
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalEmptyFlexibleUnion> for Option<Box<EmptyFlexibleUnion>> {
    fn take_from(from: &mut WireOptionalEmptyFlexibleUnion) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`EmptyFlexibleUnion`].
#[repr(transparent)]
pub struct WireEmptyFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod empty_flexible_union {
    pub enum Ref {
        UnknownOrdinal(u64),
    }

    pub enum Mut {
        UnknownOrdinal(u64),
    }
}

impl WireEmptyFlexibleUnion {
    pub fn as_ref(&self) -> crate::empty_flexible_union::Ref {
        match self.raw.ordinal() {
            unknown => crate::empty_flexible_union::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::empty_flexible_union::Mut {
        match self.raw.ordinal() {
            unknown => crate::empty_flexible_union::Mut::UnknownOrdinal(unknown),
        }
    }
}

impl Clone for WireEmptyFlexibleUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireEmptyFlexibleUnion
where
    ___D: fidl_next::decoder::InternalHandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireEmptyFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalEmptyFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalEmptyFlexibleUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireEmptyFlexibleUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireEmptyFlexibleUnion> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireEmptyFlexibleUnion> {
        if self.is_some() {
            Some(WireEmptyFlexibleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalEmptyFlexibleUnion {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalEmptyFlexibleUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalEmptyFlexibleUnion {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalEmptyFlexibleUnion
where
    ___D: fidl_next::decoder::InternalHandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalEmptyFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitFlexibleUnion {
    I(i64),

    F(f32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for ExplicitFlexibleUnion {
    type Encoded<'buf> = WireExplicitFlexibleUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitFlexibleUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i64: ::fidl_next::Encode<___E>,

    f32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitFlexibleUnion { raw, _phantom: _ } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, f32>(value, 4, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitFlexibleUnion> {
    type EncodedOption<'buf> = WireOptionalExplicitFlexibleUnion<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitFlexibleUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ExplicitFlexibleUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitFlexibleUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireExplicitFlexibleUnion<'buf>> for ExplicitFlexibleUnion {
    fn take_from(from: &mut WireExplicitFlexibleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            4 => Self::F(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalExplicitFlexibleUnion<'buf>>
    for Option<Box<ExplicitFlexibleUnion>>
{
    fn take_from(from: &mut WireOptionalExplicitFlexibleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitFlexibleUnion`].
#[repr(transparent)]
pub struct WireExplicitFlexibleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod explicit_flexible_union {
    pub enum Ref<'union> {
        I(&'union ::fidl_next::i64_le),

        F(&'union ::fidl_next::f32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        I(&'union mut ::fidl_next::i64_le),

        F(&'union mut ::fidl_next::f32_le),

        UnknownOrdinal(u64),
    }
}

impl<'buf> WireExplicitFlexibleUnion<'buf> {
    pub fn as_ref(&self) -> crate::explicit_flexible_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::explicit_flexible_union::Ref::I(unsafe { self.raw.get().deref_unchecked() })
            }

            4 => {
                crate::explicit_flexible_union::Ref::F(unsafe { self.raw.get().deref_unchecked() })
            }

            unknown => crate::explicit_flexible_union::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::explicit_flexible_union::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::explicit_flexible_union::Mut::I(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            4 => crate::explicit_flexible_union::Mut::F(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            unknown => crate::explicit_flexible_union::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireExplicitFlexibleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::f32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i64_le>(raw, decoder)?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::f32_le>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i64_le>().fmt(f) },
            4 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::f32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitFlexibleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalExplicitFlexibleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(WireExplicitFlexibleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitFlexibleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalExplicitFlexibleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::f32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i64_le>(raw, decoder)?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::f32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitFoo {
    I(i32),

    S(String),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for ExplicitFoo {
    type Encoded<'buf> = WireExplicitFoo<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitFoo
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,

    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitFoo { raw, _phantom: _ } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitFoo> {
    type EncodedOption<'buf> = WireOptionalExplicitFoo<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitFoo>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ExplicitFoo: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitFoo { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireExplicitFoo<'buf>> for ExplicitFoo {
    fn take_from(from: &mut WireExplicitFoo<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalExplicitFoo<'buf>> for Option<Box<ExplicitFoo>> {
    fn take_from(from: &mut WireOptionalExplicitFoo<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitFoo`].
#[repr(transparent)]
pub struct WireExplicitFoo<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod explicit_foo {
    pub enum Ref<'union, 'buf> {
        I(&'union ::fidl_next::i32_le),

        S(&'union ::fidl_next::WireString<'buf>),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union, 'buf> {
        I(&'union mut ::fidl_next::i32_le),

        S(&'union mut ::fidl_next::WireString<'buf>),

        UnknownOrdinal(u64),
    }
}

impl<'buf> WireExplicitFoo<'buf> {
    pub fn as_ref(&self) -> crate::explicit_foo::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::explicit_foo::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::explicit_foo::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::explicit_foo::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::explicit_foo::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::explicit_foo::Mut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => crate::explicit_foo::Mut::S(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            unknown => crate::explicit_foo::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireExplicitFoo<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            2 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitFoo<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalExplicitFoo<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitFoo<'buf>> {
        if self.is_some() {
            Some(WireExplicitFoo {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitFoo<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalExplicitFoo<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct Pizza {
    pub toppings: Vec<String>,
}

impl ::fidl_next::Encodable for Pizza {
    type Encoded<'buf> = WirePizza<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Pizza
where
    Vec<String>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                toppings,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.toppings, encoder, toppings)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Pizza> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WirePizza<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Pizza>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Pizza: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WirePizza<'buf>> for Pizza {
    fn take_from(from: &mut WirePizza<'buf>) -> Self {
        Self { toppings: ::fidl_next::TakeFrom::take_from(&mut from.toppings) }
    }
}

/// The wire type corersponding to [`Pizza`].
#[derive(Debug)]
#[repr(C)]
pub struct WirePizza<'buf> {
    pub toppings: ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WirePizza<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut toppings,

            } = slot;
        }

        ::fidl_next::Decode::decode(toppings.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Pasta {
    pub sauce: String,
}

impl ::fidl_next::Encodable for Pasta {
    type Encoded<'buf> = WirePasta<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Pasta
where
    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                sauce,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.sauce, encoder, sauce)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Pasta> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WirePasta<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Pasta>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Pasta: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WirePasta<'buf>> for Pasta {
    fn take_from(from: &mut WirePasta<'buf>) -> Self {
        Self { sauce: ::fidl_next::TakeFrom::take_from(&mut from.sauce) }
    }
}

/// The wire type corersponding to [`Pasta`].
#[derive(Debug)]
#[repr(C)]
pub struct WirePasta<'buf> {
    pub sauce: ::fidl_next::WireString<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WirePasta<'buf>
where
    ___D: ?Sized,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut sauce,

            } = slot;
        }

        ::fidl_next::Decode::decode(sauce.as_mut(), decoder)?;

        let sauce = unsafe { sauce.deref_unchecked() };

        if sauce.len() > 16 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: sauce.len() as u64,
                limit: 16,
            });
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitPizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),
}

impl ::fidl_next::Encodable for ExplicitPizzaOrPasta {
    type Encoded<'buf> = WireExplicitPizzaOrPasta<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitPizzaOrPasta
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::Pizza: ::fidl_next::Encode<___E>,

    crate::Pasta: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitPizzaOrPasta { raw, _phantom: _ } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 4, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitPizzaOrPasta> {
    type EncodedOption<'buf> = WireOptionalExplicitPizzaOrPasta<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitPizzaOrPasta>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ExplicitPizzaOrPasta: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitPizzaOrPasta { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireExplicitPizzaOrPasta<'buf>> for ExplicitPizzaOrPasta {
    fn take_from(from: &mut WireExplicitPizzaOrPasta<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            4 => Self::Pasta(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalExplicitPizzaOrPasta<'buf>>
    for Option<Box<ExplicitPizzaOrPasta>>
{
    fn take_from(from: &mut WireOptionalExplicitPizzaOrPasta<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitPizzaOrPasta`].
#[repr(transparent)]
pub struct WireExplicitPizzaOrPasta<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod explicit_pizza_or_pasta {
    pub enum Ref<'union, 'buf> {
        Pizza(&'union crate::WirePizza<'buf>),

        Pasta(&'union crate::WirePasta<'buf>),
    }

    pub enum Mut<'union, 'buf> {
        Pizza(&'union mut crate::WirePizza<'buf>),

        Pasta(&'union mut crate::WirePasta<'buf>),
    }
}

impl<'buf> WireExplicitPizzaOrPasta<'buf> {
    pub fn as_ref(&self) -> crate::explicit_pizza_or_pasta::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::explicit_pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked()
            }),

            4 => crate::explicit_pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::explicit_pizza_or_pasta::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::explicit_pizza_or_pasta::Mut::Pizza(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            4 => crate::explicit_pizza_or_pasta::Mut::Pasta(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireExplicitPizzaOrPasta<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WirePizza<'buf>: ::fidl_next::Decode<___D>,

    crate::WirePasta<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?
            }

            4 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?
            }

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'buf>>().fmt(f) },
            4 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'buf>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitPizzaOrPasta<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalExplicitPizzaOrPasta<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(WireExplicitPizzaOrPasta {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitPizzaOrPasta<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalExplicitPizzaOrPasta<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WirePizza<'buf>: ::fidl_next::Decode<___D>,

    crate::WirePasta<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?
            }

            4 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitStrictFoo {
    I(i32),

    S(String),
}

impl ::fidl_next::Encodable for ExplicitStrictFoo {
    type Encoded<'buf> = WireExplicitStrictFoo<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitStrictFoo
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,

    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitStrictFoo { raw, _phantom: _ } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitStrictFoo> {
    type EncodedOption<'buf> = WireOptionalExplicitStrictFoo<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitStrictFoo>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ExplicitStrictFoo: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitStrictFoo { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireExplicitStrictFoo<'buf>> for ExplicitStrictFoo {
    fn take_from(from: &mut WireExplicitStrictFoo<'buf>) -> Self {
        match from.raw.ordinal() {
            2 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalExplicitStrictFoo<'buf>>
    for Option<Box<ExplicitStrictFoo>>
{
    fn take_from(from: &mut WireOptionalExplicitStrictFoo<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitStrictFoo`].
#[repr(transparent)]
pub struct WireExplicitStrictFoo<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod explicit_strict_foo {
    pub enum Ref<'union, 'buf> {
        I(&'union ::fidl_next::i32_le),

        S(&'union ::fidl_next::WireString<'buf>),
    }

    pub enum Mut<'union, 'buf> {
        I(&'union mut ::fidl_next::i32_le),

        S(&'union mut ::fidl_next::WireString<'buf>),
    }
}

impl<'buf> WireExplicitStrictFoo<'buf> {
    pub fn as_ref(&self) -> crate::explicit_strict_foo::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            2 => crate::explicit_strict_foo::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::explicit_strict_foo::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::explicit_strict_foo::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            2 => crate::explicit_strict_foo::Mut::I(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => crate::explicit_strict_foo::Mut::S(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireExplicitStrictFoo<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitStrictFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitStrictFoo<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalExplicitStrictFoo<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitStrictFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitStrictFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitStrictFoo<'buf>> {
        if self.is_some() {
            Some(WireExplicitStrictFoo {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitStrictFoo<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalExplicitStrictFoo<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitStrictFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitUnion {
    Primitive(i32),

    StringNeedsConstructor(String),
}

impl ::fidl_next::Encodable for ExplicitUnion {
    type Encoded<'buf> = WireExplicitUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,

    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitUnion { raw, _phantom: _ } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitUnion> {
    type EncodedOption<'buf> = WireOptionalExplicitUnion<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ExplicitUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireExplicitUnion<'buf>> for ExplicitUnion {
    fn take_from(from: &mut WireExplicitUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::StringNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalExplicitUnion<'buf>> for Option<Box<ExplicitUnion>> {
    fn take_from(from: &mut WireOptionalExplicitUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitUnion`].
#[repr(transparent)]
pub struct WireExplicitUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod explicit_union {
    pub enum Ref<'union, 'buf> {
        Primitive(&'union ::fidl_next::i32_le),

        StringNeedsConstructor(&'union ::fidl_next::WireString<'buf>),
    }

    pub enum Mut<'union, 'buf> {
        Primitive(&'union mut ::fidl_next::i32_le),

        StringNeedsConstructor(&'union mut ::fidl_next::WireString<'buf>),
    }
}

impl<'buf> WireExplicitUnion<'buf> {
    pub fn as_ref(&self) -> crate::explicit_union::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::explicit_union::Ref::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::explicit_union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::explicit_union::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::explicit_union::Mut::Primitive(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => crate::explicit_union::Mut::StringNeedsConstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireExplicitUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalExplicitUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitUnion<'buf>> {
        if self.is_some() {
            Some(WireExplicitUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalExplicitUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FieldCollision {
    FieldCollisionTag(i32),
}

impl ::fidl_next::Encodable for FieldCollision {
    type Encoded<'buf> = WireFieldCollision;
}

impl<___E> ::fidl_next::Encode<___E> for FieldCollision
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFieldCollision { raw, _phantom: _ } = slot);

        match self {
            Self::FieldCollisionTag(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<FieldCollision> {
    type EncodedOption<'buf> = WireOptionalFieldCollision;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<FieldCollision>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    FieldCollision: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFieldCollision { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireFieldCollision> for FieldCollision {
    fn take_from(from: &mut WireFieldCollision) -> Self {
        match from.raw.ordinal() {
            1 => Self::FieldCollisionTag(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalFieldCollision> for Option<Box<FieldCollision>> {
    fn take_from(from: &mut WireOptionalFieldCollision) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FieldCollision`].
#[repr(transparent)]
pub struct WireFieldCollision {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod field_collision {
    pub enum Ref<'union> {
        FieldCollisionTag(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        FieldCollisionTag(&'union mut ::fidl_next::i32_le),
    }
}

impl WireFieldCollision {
    pub fn as_ref(&self) -> crate::field_collision::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::field_collision::Ref::FieldCollisionTag(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::field_collision::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::field_collision::Mut::FieldCollisionTag(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireFieldCollision {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireFieldCollision
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireFieldCollision {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFieldCollision {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalFieldCollision {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFieldCollision> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireFieldCollision> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireFieldCollision> {
        if self.is_some() {
            Some(WireFieldCollision {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalFieldCollision {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalFieldCollision {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalFieldCollision {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalFieldCollision
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalFieldCollision {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FlexibleFoo {
    S(String),

    I(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for FlexibleFoo {
    type Encoded<'buf> = WireFlexibleFoo<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for FlexibleFoo
where
    ___E: ::fidl_next::Encoder + ?Sized,

    String: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexibleFoo { raw, _phantom: _ } = slot);

        match self {
            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 1, encoder, raw)?
            }

            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<FlexibleFoo> {
    type EncodedOption<'buf> = WireOptionalFlexibleFoo<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<FlexibleFoo>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    FlexibleFoo: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexibleFoo { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireFlexibleFoo<'buf>> for FlexibleFoo {
    fn take_from(from: &mut WireFlexibleFoo<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalFlexibleFoo<'buf>> for Option<Box<FlexibleFoo>> {
    fn take_from(from: &mut WireOptionalFlexibleFoo<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FlexibleFoo`].
#[repr(transparent)]
pub struct WireFlexibleFoo<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod flexible_foo {
    pub enum Ref<'union, 'buf> {
        S(&'union ::fidl_next::WireString<'buf>),

        I(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union, 'buf> {
        S(&'union mut ::fidl_next::WireString<'buf>),

        I(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl<'buf> WireFlexibleFoo<'buf> {
    pub fn as_ref(&self) -> crate::flexible_foo::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::flexible_foo::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::flexible_foo::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::flexible_foo::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::flexible_foo::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::flexible_foo::Mut::S(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => crate::flexible_foo::Mut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            unknown => crate::flexible_foo::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireFlexibleFoo<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireFlexibleFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexibleFoo<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalFlexibleFoo<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexibleFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireFlexibleFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireFlexibleFoo<'buf>> {
        if self.is_some() {
            Some(WireFlexibleFoo {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalFlexibleFoo<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalFlexibleFoo<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalFlexibleFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FlexiblePizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for FlexiblePizzaOrPasta {
    type Encoded<'buf> = WireFlexiblePizzaOrPasta<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for FlexiblePizzaOrPasta
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::Pizza: ::fidl_next::Encode<___E>,

    crate::Pasta: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexiblePizzaOrPasta { raw, _phantom: _ } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<FlexiblePizzaOrPasta> {
    type EncodedOption<'buf> = WireOptionalFlexiblePizzaOrPasta<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<FlexiblePizzaOrPasta>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    FlexiblePizzaOrPasta: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexiblePizzaOrPasta { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireFlexiblePizzaOrPasta<'buf>> for FlexiblePizzaOrPasta {
    fn take_from(from: &mut WireFlexiblePizzaOrPasta<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Pasta(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalFlexiblePizzaOrPasta<'buf>>
    for Option<Box<FlexiblePizzaOrPasta>>
{
    fn take_from(from: &mut WireOptionalFlexiblePizzaOrPasta<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FlexiblePizzaOrPasta`].
#[repr(transparent)]
pub struct WireFlexiblePizzaOrPasta<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod flexible_pizza_or_pasta {
    pub enum Ref<'union, 'buf> {
        Pizza(&'union crate::WirePizza<'buf>),

        Pasta(&'union crate::WirePasta<'buf>),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union, 'buf> {
        Pizza(&'union mut crate::WirePizza<'buf>),

        Pasta(&'union mut crate::WirePasta<'buf>),

        UnknownOrdinal(u64),
    }
}

impl<'buf> WireFlexiblePizzaOrPasta<'buf> {
    pub fn as_ref(&self) -> crate::flexible_pizza_or_pasta::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::flexible_pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::flexible_pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::flexible_pizza_or_pasta::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::flexible_pizza_or_pasta::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::flexible_pizza_or_pasta::Mut::Pizza(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::flexible_pizza_or_pasta::Mut::Pasta(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            unknown => crate::flexible_pizza_or_pasta::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireFlexiblePizzaOrPasta<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WirePizza<'buf>: ::fidl_next::Decode<___D>,

    crate::WirePasta<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?
            }

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?
            }

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireFlexiblePizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'buf>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexiblePizzaOrPasta<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalFlexiblePizzaOrPasta<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexiblePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireFlexiblePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireFlexiblePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(WireFlexiblePizzaOrPasta {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalFlexiblePizzaOrPasta<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalFlexiblePizzaOrPasta<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WirePizza<'buf>: ::fidl_next::Decode<___D>,

    crate::WirePasta<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?
            }

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalFlexiblePizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FlexibleUnion {
    Primitive(i32),

    StringNeedsConstructor(String),

    VectorStringAlsoNeedsConstructor(Vec<String>),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for FlexibleUnion {
    type Encoded<'buf> = WireFlexibleUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for FlexibleUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,

    String: ::fidl_next::Encode<___E>,

    Vec<String>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexibleUnion { raw, _phantom: _ } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<FlexibleUnion> {
    type EncodedOption<'buf> = WireOptionalFlexibleUnion<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<FlexibleUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    FlexibleUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexibleUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireFlexibleUnion<'buf>> for FlexibleUnion {
    fn take_from(from: &mut WireFlexibleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalFlexibleUnion<'buf>> for Option<Box<FlexibleUnion>> {
    fn take_from(from: &mut WireOptionalFlexibleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FlexibleUnion`].
#[repr(transparent)]
pub struct WireFlexibleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod flexible_union {
    pub enum Ref<'union, 'buf> {
        Primitive(&'union ::fidl_next::i32_le),

        StringNeedsConstructor(&'union ::fidl_next::WireString<'buf>),

        VectorStringAlsoNeedsConstructor(
            &'union ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
        ),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union, 'buf> {
        Primitive(&'union mut ::fidl_next::i32_le),

        StringNeedsConstructor(&'union mut ::fidl_next::WireString<'buf>),

        VectorStringAlsoNeedsConstructor(
            &'union mut ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
        ),

        UnknownOrdinal(u64),
    }
}

impl<'buf> WireFlexibleUnion<'buf> {
    pub fn as_ref(&self) -> crate::flexible_union::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::flexible_union::Ref::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::flexible_union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            3 => crate::flexible_union::Ref::VectorStringAlsoNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::flexible_union::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::flexible_union::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::flexible_union::Mut::Primitive(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::flexible_union::Mut::StringNeedsConstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => crate::flexible_union::Mut::VectorStringAlsoNeedsConstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            unknown => crate::flexible_union::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireFlexibleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
            >(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            2 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<
                            ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>
                        >().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexibleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalFlexibleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(WireFlexibleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalFlexibleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalFlexibleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum NewerSimpleUnion {
    I(i64),

    S(String),

    V(Vec<String>),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for NewerSimpleUnion {
    type Encoded<'buf> = WireNewerSimpleUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for NewerSimpleUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i64: ::fidl_next::Encode<___E>,

    String: ::fidl_next::Encode<___E>,

    Vec<String>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireNewerSimpleUnion { raw, _phantom: _ } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<NewerSimpleUnion> {
    type EncodedOption<'buf> = WireOptionalNewerSimpleUnion<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<NewerSimpleUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    NewerSimpleUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalNewerSimpleUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireNewerSimpleUnion<'buf>> for NewerSimpleUnion {
    fn take_from(from: &mut WireNewerSimpleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::V(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalNewerSimpleUnion<'buf>>
    for Option<Box<NewerSimpleUnion>>
{
    fn take_from(from: &mut WireOptionalNewerSimpleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`NewerSimpleUnion`].
#[repr(transparent)]
pub struct WireNewerSimpleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod newer_simple_union {
    pub enum Ref<'union, 'buf> {
        I(&'union ::fidl_next::i64_le),

        S(&'union ::fidl_next::WireString<'buf>),

        V(&'union ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union, 'buf> {
        I(&'union mut ::fidl_next::i64_le),

        S(&'union mut ::fidl_next::WireString<'buf>),

        V(&'union mut ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>),

        UnknownOrdinal(u64),
    }
}

impl<'buf> WireNewerSimpleUnion<'buf> {
    pub fn as_ref(&self) -> crate::newer_simple_union::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::newer_simple_union::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::newer_simple_union::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::newer_simple_union::Ref::V(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::newer_simple_union::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::newer_simple_union::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::newer_simple_union::Mut::I(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::newer_simple_union::Mut::S(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => crate::newer_simple_union::Mut::V(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            unknown => crate::newer_simple_union::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireNewerSimpleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i64_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
            >(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireNewerSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i64_le>().fmt(f) },
            2 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<
                            ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>
                        >().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalNewerSimpleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalNewerSimpleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireNewerSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireNewerSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireNewerSimpleUnion<'buf>> {
        if self.is_some() {
            Some(WireNewerSimpleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalNewerSimpleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalNewerSimpleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i64_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalNewerSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct NullableUnionStruct {
    pub the_union: Option<Box<crate::Union>>,
}

impl ::fidl_next::Encodable for NullableUnionStruct {
    type Encoded<'buf> = WireNullableUnionStruct<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for NullableUnionStruct
where
    Option<Box<crate::Union>>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                the_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.the_union, encoder, the_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<NullableUnionStruct> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireNullableUnionStruct<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<NullableUnionStruct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    NullableUnionStruct: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireNullableUnionStruct<'buf>> for NullableUnionStruct {
    fn take_from(from: &mut WireNullableUnionStruct<'buf>) -> Self {
        Self { the_union: ::fidl_next::TakeFrom::take_from(&mut from.the_union) }
    }
}

/// The wire type corersponding to [`NullableUnionStruct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireNullableUnionStruct<'buf> {
    pub the_union: crate::WireOptionalUnion<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireNullableUnionStruct<'buf>
where
    ___D: ?Sized,

    crate::WireOptionalUnion<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut the_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(the_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum OlderSimpleUnion {
    I(i64),

    F(f32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for OlderSimpleUnion {
    type Encoded<'buf> = WireOlderSimpleUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for OlderSimpleUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i64: ::fidl_next::Encode<___E>,

    f32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOlderSimpleUnion { raw, _phantom: _ } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, f32>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OlderSimpleUnion> {
    type EncodedOption<'buf> = WireOptionalOlderSimpleUnion<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OlderSimpleUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OlderSimpleUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalOlderSimpleUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOlderSimpleUnion<'buf>> for OlderSimpleUnion {
    fn take_from(from: &mut WireOlderSimpleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::F(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalOlderSimpleUnion<'buf>>
    for Option<Box<OlderSimpleUnion>>
{
    fn take_from(from: &mut WireOptionalOlderSimpleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`OlderSimpleUnion`].
#[repr(transparent)]
pub struct WireOlderSimpleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod older_simple_union {
    pub enum Ref<'union> {
        I(&'union ::fidl_next::i64_le),

        F(&'union ::fidl_next::f32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        I(&'union mut ::fidl_next::i64_le),

        F(&'union mut ::fidl_next::f32_le),

        UnknownOrdinal(u64),
    }
}

impl<'buf> WireOlderSimpleUnion<'buf> {
    pub fn as_ref(&self) -> crate::older_simple_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::older_simple_union::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::older_simple_union::Ref::F(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::older_simple_union::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::older_simple_union::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::older_simple_union::Mut::I(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::older_simple_union::Mut::F(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            unknown => crate::older_simple_union::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOlderSimpleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::f32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i64_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::f32_le>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOlderSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i64_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::f32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalOlderSimpleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalOlderSimpleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireOlderSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireOlderSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireOlderSimpleUnion<'buf>> {
        if self.is_some() {
            Some(WireOlderSimpleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalOlderSimpleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalOlderSimpleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,

    ::fidl_next::f32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i64_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::f32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalOlderSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum PizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),
}

impl ::fidl_next::Encodable for PizzaOrPasta {
    type Encoded<'buf> = WirePizzaOrPasta<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for PizzaOrPasta
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::Pizza: ::fidl_next::Encode<___E>,

    crate::Pasta: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WirePizzaOrPasta { raw, _phantom: _ } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<PizzaOrPasta> {
    type EncodedOption<'buf> = WireOptionalPizzaOrPasta<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<PizzaOrPasta>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    PizzaOrPasta: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalPizzaOrPasta { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WirePizzaOrPasta<'buf>> for PizzaOrPasta {
    fn take_from(from: &mut WirePizzaOrPasta<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Pasta(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalPizzaOrPasta<'buf>> for Option<Box<PizzaOrPasta>> {
    fn take_from(from: &mut WireOptionalPizzaOrPasta<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`PizzaOrPasta`].
#[repr(transparent)]
pub struct WirePizzaOrPasta<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod pizza_or_pasta {
    pub enum Ref<'union, 'buf> {
        Pizza(&'union crate::WirePizza<'buf>),

        Pasta(&'union crate::WirePasta<'buf>),
    }

    pub enum Mut<'union, 'buf> {
        Pizza(&'union mut crate::WirePizza<'buf>),

        Pasta(&'union mut crate::WirePasta<'buf>),
    }
}

impl<'buf> WirePizzaOrPasta<'buf> {
    pub fn as_ref(&self) -> crate::pizza_or_pasta::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::pizza_or_pasta::Ref::Pizza(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::pizza_or_pasta::Ref::Pasta(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::pizza_or_pasta::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::pizza_or_pasta::Mut::Pizza(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::pizza_or_pasta::Mut::Pasta(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WirePizzaOrPasta<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WirePizza<'buf>: ::fidl_next::Decode<___D>,

    crate::WirePasta<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?
            }

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?
            }

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WirePizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'buf>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalPizzaOrPasta<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalPizzaOrPasta<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WirePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WirePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WirePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(WirePizzaOrPasta {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalPizzaOrPasta<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalPizzaOrPasta<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WirePizza<'buf>: ::fidl_next::Decode<___D>,

    crate::WirePasta<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?
            }

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ReverseOrdinalUnion {
    First(u32),

    Second(u32),
}

impl ::fidl_next::Encodable for ReverseOrdinalUnion {
    type Encoded<'buf> = WireReverseOrdinalUnion;
}

impl<___E> ::fidl_next::Encode<___E> for ReverseOrdinalUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    u32: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireReverseOrdinalUnion { raw, _phantom: _ } = slot);

        match self {
            Self::First(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 1, encoder, raw)?
            }

            Self::Second(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ReverseOrdinalUnion> {
    type EncodedOption<'buf> = WireOptionalReverseOrdinalUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ReverseOrdinalUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ReverseOrdinalUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalReverseOrdinalUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireReverseOrdinalUnion> for ReverseOrdinalUnion {
    fn take_from(from: &mut WireReverseOrdinalUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::First(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Second(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalReverseOrdinalUnion> for Option<Box<ReverseOrdinalUnion>> {
    fn take_from(from: &mut WireOptionalReverseOrdinalUnion) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ReverseOrdinalUnion`].
#[repr(transparent)]
pub struct WireReverseOrdinalUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod reverse_ordinal_union {
    pub enum Ref<'union> {
        First(&'union ::fidl_next::u32_le),

        Second(&'union ::fidl_next::u32_le),
    }

    pub enum Mut<'union> {
        First(&'union mut ::fidl_next::u32_le),

        Second(&'union mut ::fidl_next::u32_le),
    }
}

impl WireReverseOrdinalUnion {
    pub fn as_ref(&self) -> crate::reverse_ordinal_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::reverse_ordinal_union::Ref::First(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::reverse_ordinal_union::Ref::Second(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::reverse_ordinal_union::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::reverse_ordinal_union::Mut::First(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::reverse_ordinal_union::Mut::Second(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireReverseOrdinalUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireReverseOrdinalUnion
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireReverseOrdinalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalReverseOrdinalUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalReverseOrdinalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireReverseOrdinalUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireReverseOrdinalUnion> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireReverseOrdinalUnion> {
        if self.is_some() {
            Some(WireReverseOrdinalUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalReverseOrdinalUnion {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalReverseOrdinalUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalReverseOrdinalUnion {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalReverseOrdinalUnion
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalReverseOrdinalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictBoundedUnion {
    V(Vec<u8>),
}

impl ::fidl_next::Encodable for StrictBoundedUnion {
    type Encoded<'buf> = WireStrictBoundedUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for StrictBoundedUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    Vec<u8>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictBoundedUnion { raw, _phantom: _ } = slot);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<u8>>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictBoundedUnion> {
    type EncodedOption<'buf> = WireOptionalStrictBoundedUnion<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictBoundedUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    StrictBoundedUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictBoundedUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireStrictBoundedUnion<'buf>> for StrictBoundedUnion {
    fn take_from(from: &mut WireStrictBoundedUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::V(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalStrictBoundedUnion<'buf>>
    for Option<Box<StrictBoundedUnion>>
{
    fn take_from(from: &mut WireOptionalStrictBoundedUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictBoundedUnion`].
#[repr(transparent)]
pub struct WireStrictBoundedUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod strict_bounded_union {
    pub enum Ref<'union, 'buf> {
        V(&'union ::fidl_next::WireVector<'buf, u8>),
    }

    pub enum Mut<'union, 'buf> {
        V(&'union mut ::fidl_next::WireVector<'buf, u8>),
    }
}

impl<'buf> WireStrictBoundedUnion<'buf> {
    pub fn as_ref(&self) -> crate::strict_bounded_union::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_bounded_union::Ref::V(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::strict_bounded_union::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_bounded_union::Mut::V(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireStrictBoundedUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::WireVector<'buf, u8>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireVector<'buf, u8>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictBoundedUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireVector<'buf, u8>>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictBoundedUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalStrictBoundedUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictBoundedUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictBoundedUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictBoundedUnion<'buf>> {
        if self.is_some() {
            Some(WireStrictBoundedUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictBoundedUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalStrictBoundedUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::WireVector<'buf, u8>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireVector<'buf, u8>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictBoundedUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictFoo {
    S(String),

    I(i32),
}

impl ::fidl_next::Encodable for StrictFoo {
    type Encoded<'buf> = WireStrictFoo<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for StrictFoo
where
    ___E: ::fidl_next::Encoder + ?Sized,

    String: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictFoo { raw, _phantom: _ } = slot);

        match self {
            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 1, encoder, raw)?
            }

            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictFoo> {
    type EncodedOption<'buf> = WireOptionalStrictFoo<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictFoo>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    StrictFoo: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictFoo { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireStrictFoo<'buf>> for StrictFoo {
    fn take_from(from: &mut WireStrictFoo<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalStrictFoo<'buf>> for Option<Box<StrictFoo>> {
    fn take_from(from: &mut WireOptionalStrictFoo<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictFoo`].
#[repr(transparent)]
pub struct WireStrictFoo<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod strict_foo {
    pub enum Ref<'union, 'buf> {
        S(&'union ::fidl_next::WireString<'buf>),

        I(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union, 'buf> {
        S(&'union mut ::fidl_next::WireString<'buf>),

        I(&'union mut ::fidl_next::i32_le),
    }
}

impl<'buf> WireStrictFoo<'buf> {
    pub fn as_ref(&self) -> crate::strict_foo::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_foo::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::strict_foo::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::strict_foo::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_foo::Mut::S(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => crate::strict_foo::Mut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireStrictFoo<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictFoo<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalStrictFoo<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictFoo<'buf>> {
        if self.is_some() {
            Some(WireStrictFoo {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictFoo<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalStrictFoo<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictPizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),
}

impl ::fidl_next::Encodable for StrictPizzaOrPasta {
    type Encoded<'buf> = WireStrictPizzaOrPasta<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for StrictPizzaOrPasta
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::Pizza: ::fidl_next::Encode<___E>,

    crate::Pasta: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictPizzaOrPasta { raw, _phantom: _ } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictPizzaOrPasta> {
    type EncodedOption<'buf> = WireOptionalStrictPizzaOrPasta<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictPizzaOrPasta>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    StrictPizzaOrPasta: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictPizzaOrPasta { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireStrictPizzaOrPasta<'buf>> for StrictPizzaOrPasta {
    fn take_from(from: &mut WireStrictPizzaOrPasta<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Pasta(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalStrictPizzaOrPasta<'buf>>
    for Option<Box<StrictPizzaOrPasta>>
{
    fn take_from(from: &mut WireOptionalStrictPizzaOrPasta<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictPizzaOrPasta`].
#[repr(transparent)]
pub struct WireStrictPizzaOrPasta<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod strict_pizza_or_pasta {
    pub enum Ref<'union, 'buf> {
        Pizza(&'union crate::WirePizza<'buf>),

        Pasta(&'union crate::WirePasta<'buf>),
    }

    pub enum Mut<'union, 'buf> {
        Pizza(&'union mut crate::WirePizza<'buf>),

        Pasta(&'union mut crate::WirePasta<'buf>),
    }
}

impl<'buf> WireStrictPizzaOrPasta<'buf> {
    pub fn as_ref(&self) -> crate::strict_pizza_or_pasta::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::strict_pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::strict_pizza_or_pasta::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_pizza_or_pasta::Mut::Pizza(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::strict_pizza_or_pasta::Mut::Pasta(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireStrictPizzaOrPasta<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WirePizza<'buf>: ::fidl_next::Decode<___D>,

    crate::WirePasta<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?
            }

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?
            }

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'buf>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictPizzaOrPasta<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalStrictPizzaOrPasta<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(WireStrictPizzaOrPasta {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictPizzaOrPasta<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalStrictPizzaOrPasta<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WirePizza<'buf>: ::fidl_next::Decode<___D>,

    crate::WirePasta<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?
            }

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictSimpleUnion {
    I(i32),

    F(f32),

    S(String),
}

impl ::fidl_next::Encodable for StrictSimpleUnion {
    type Encoded<'buf> = WireStrictSimpleUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for StrictSimpleUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,

    f32: ::fidl_next::Encode<___E>,

    String: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictSimpleUnion { raw, _phantom: _ } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, f32>(value, 2, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictSimpleUnion> {
    type EncodedOption<'buf> = WireOptionalStrictSimpleUnion<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictSimpleUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    StrictSimpleUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictSimpleUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireStrictSimpleUnion<'buf>> for StrictSimpleUnion {
    fn take_from(from: &mut WireStrictSimpleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::F(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalStrictSimpleUnion<'buf>>
    for Option<Box<StrictSimpleUnion>>
{
    fn take_from(from: &mut WireOptionalStrictSimpleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictSimpleUnion`].
#[repr(transparent)]
pub struct WireStrictSimpleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod strict_simple_union {
    pub enum Ref<'union, 'buf> {
        I(&'union ::fidl_next::i32_le),

        F(&'union ::fidl_next::f32_le),

        S(&'union ::fidl_next::WireString<'buf>),
    }

    pub enum Mut<'union, 'buf> {
        I(&'union mut ::fidl_next::i32_le),

        F(&'union mut ::fidl_next::f32_le),

        S(&'union mut ::fidl_next::WireString<'buf>),
    }
}

impl<'buf> WireStrictSimpleUnion<'buf> {
    pub fn as_ref(&self) -> crate::strict_simple_union::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_simple_union::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::strict_simple_union::Ref::F(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::strict_simple_union::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::strict_simple_union::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_simple_union::Mut::I(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::strict_simple_union::Mut::F(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => crate::strict_simple_union::Mut::S(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireStrictSimpleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::f32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::f32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::f32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictSimpleUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalStrictSimpleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictSimpleUnion<'buf>> {
        if self.is_some() {
            Some(WireStrictSimpleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictSimpleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalStrictSimpleUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::f32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::f32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictUnion {
    Primitive(i32),

    StringNeedsConstructor(String),

    VectorStringAlsoNeedsConstructor(Vec<String>),
}

impl ::fidl_next::Encodable for StrictUnion {
    type Encoded<'buf> = WireStrictUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for StrictUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,

    String: ::fidl_next::Encode<___E>,

    Vec<String>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictUnion { raw, _phantom: _ } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictUnion> {
    type EncodedOption<'buf> = WireOptionalStrictUnion<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    StrictUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireStrictUnion<'buf>> for StrictUnion {
    fn take_from(from: &mut WireStrictUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalStrictUnion<'buf>> for Option<Box<StrictUnion>> {
    fn take_from(from: &mut WireOptionalStrictUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictUnion`].
#[repr(transparent)]
pub struct WireStrictUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod strict_union {
    pub enum Ref<'union, 'buf> {
        Primitive(&'union ::fidl_next::i32_le),

        StringNeedsConstructor(&'union ::fidl_next::WireString<'buf>),

        VectorStringAlsoNeedsConstructor(
            &'union ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
        ),
    }

    pub enum Mut<'union, 'buf> {
        Primitive(&'union mut ::fidl_next::i32_le),

        StringNeedsConstructor(&'union mut ::fidl_next::WireString<'buf>),

        VectorStringAlsoNeedsConstructor(
            &'union mut ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
        ),
    }
}

impl<'buf> WireStrictUnion<'buf> {
    pub fn as_ref(&self) -> crate::strict_union::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_union::Ref::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::strict_union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            3 => crate::strict_union::Ref::VectorStringAlsoNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::strict_union::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::strict_union::Mut::Primitive(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::strict_union::Mut::StringNeedsConstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => crate::strict_union::Mut::VectorStringAlsoNeedsConstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireStrictUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            2 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<
                            ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>
                        >().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalStrictUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictUnion<'buf>> {
        if self.is_some() {
            Some(WireStrictUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalStrictUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct StructWithNullableUnion {
    pub x1: Option<Box<crate::OlderSimpleUnion>>,
}

impl ::fidl_next::Encodable for StructWithNullableUnion {
    type Encoded<'buf> = WireStructWithNullableUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for StructWithNullableUnion
where
    Option<Box<crate::OlderSimpleUnion>>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                x1,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.x1, encoder, x1)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StructWithNullableUnion> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireStructWithNullableUnion<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StructWithNullableUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    StructWithNullableUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireStructWithNullableUnion<'buf>> for StructWithNullableUnion {
    fn take_from(from: &mut WireStructWithNullableUnion<'buf>) -> Self {
        Self { x1: ::fidl_next::TakeFrom::take_from(&mut from.x1) }
    }
}

/// The wire type corersponding to [`StructWithNullableUnion`].
#[derive(Debug)]
#[repr(C)]
pub struct WireStructWithNullableUnion<'buf> {
    pub x1: crate::WireOptionalOlderSimpleUnion<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireStructWithNullableUnion<'buf>
where
    ___D: ?Sized,

    crate::WireOptionalOlderSimpleUnion<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut x1,

            } = slot;
        }

        ::fidl_next::Decode::decode(x1.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
    pub xu: crate::StrictBoundedUnion,
}

impl ::fidl_next::Encodable for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
    type Encoded<'buf> = WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
where
    crate::StrictBoundedUnion: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                xu,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.xu, encoder, xu)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
{
    fn take_from(
        from: &mut WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>,
    ) -> Self {
        Self { xu: ::fidl_next::TakeFrom::take_from(&mut from.xu) }
    }
}

/// The wire type corersponding to [`TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf> {
    pub xu: crate::WireStrictBoundedUnion<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>
where
    ___D: ?Sized,

    crate::WireStrictBoundedUnion<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut xu,

            } = slot;
        }

        ::fidl_next::Decode::decode(xu.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
    pub xu: crate::OlderSimpleUnion,
}

impl ::fidl_next::Encodable for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
    type Encoded<'buf> =
        WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
where
    crate::OlderSimpleUnion: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                xu,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.xu, encoder, xu)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>,
    > for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
{
    fn take_from(
        from: &mut WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>,
    ) -> Self {
        Self { xu: ::fidl_next::TakeFrom::take_from(&mut from.xu) }
    }
}

/// The wire type corersponding to [`TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf> {
    pub xu: crate::WireOlderSimpleUnion<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>
where
    ___D: ?Sized,

    crate::WireOlderSimpleUnion<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut xu,

            } = slot;
        }

        ::fidl_next::Decode::decode(xu.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the TestProtocol protocol.
#[derive(Debug)]
pub struct TestProtocol;

pub mod test_protocol {

    pub struct StrictUnionHenceResponseMayBeStackAllocated;

    impl ::fidl_next::bind::Method for StrictUnionHenceResponseMayBeStackAllocated {
        const ORDINAL: u64 = 6628358876445129155;

        type Protocol = crate::TestProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>;
    }

    pub struct FlexibleUnionHenceResponseMustBeHeapAllocated;

    impl ::fidl_next::bind::Method for FlexibleUnionHenceResponseMustBeHeapAllocated {
        const ORDINAL: u64 = 7588545459451501794;

        type Protocol = crate::TestProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>;
    }
}

/// A helper trait for the `TestProtocol` client protocol.
pub trait TestProtocolClient<___T: ::fidl_next::protocol::Transport> {
    fn strict_union_hence_response_may_be_stack_allocated(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<
            '_,
            ___T,
            test_protocol::StrictUnionHenceResponseMayBeStackAllocated,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_union_hence_response_must_be_heap_allocated(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<
            '_,
            ___T,
            test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> TestProtocolClient<___T> for ::fidl_next::bind::Client<___T, TestProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_union_hence_response_may_be_stack_allocated(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<
            '_,
            ___T,
            test_protocol::StrictUnionHenceResponseMayBeStackAllocated,
        >,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(6628358876445129155, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }

    fn flexible_union_hence_response_must_be_heap_allocated(
        &self,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<
            '_,
            ___T,
            test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated,
        >,
        ::fidl_next::EncodeError,
    > {
        self.untyped()
            .send_transaction(7588545459451501794, &mut ())
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }
}

/// A client handler for the TestProtocol protocol.

pub trait TestProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for TestProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: TestProtocolClientHandler<___T>,

    for<'buf> crate::WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(handler: &mut ___H, ordinal: u64, buffer: ___T::RecvBuffer) {
        match ordinal {
            ordinal => todo!(),
        }
    }
}

/// A helper trait for the `TestProtocol` server protocol.
pub trait TestProtocolServer<___T: ::fidl_next::protocol::Transport> {}

impl<___T> TestProtocolServer<___T> for ::fidl_next::bind::Server<___T, TestProtocol> where
    ___T: ::fidl_next::protocol::Transport
{
}

/// A server handler for the TestProtocol protocol.

pub trait TestProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn strict_union_hence_response_may_be_stack_allocated(
        &mut self,
        responder: ::fidl_next::bind::Responder<
            test_protocol::StrictUnionHenceResponseMayBeStackAllocated,
        >,
    );

    fn flexible_union_hence_response_must_be_heap_allocated(
        &mut self,
        responder: ::fidl_next::bind::Responder<
            test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated,
        >,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for TestProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: TestProtocolServerHandler<___T>,
{
    fn on_event(handler: &mut ___H, ordinal: u64, buffer: ___T::RecvBuffer) {
        match ordinal {
            ordinal => todo!(),
        }
    }

    fn on_transaction(
        handler: &mut ___H,
        ordinal: u64,
        mut buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            6628358876445129155 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_union_hence_response_may_be_stack_allocated(responder);
            }

            7588545459451501794 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_union_hence_response_must_be_heap_allocated(responder);
            }

            ordinal => todo!(),
        }
    }
}

#[derive(Clone, Debug)]
pub enum Union {
    Primitive(i32),

    StringNeedsConstructor(String),

    VectorStringAlsoNeedsConstructor(Vec<String>),
}

impl ::fidl_next::Encodable for Union {
    type Encoded<'buf> = WireUnion<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Union
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,

    String: ::fidl_next::Encode<___E>,

    Vec<String>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw, _phantom: _ } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Union> {
    type EncodedOption<'buf> = WireOptionalUnion<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Union>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Union: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnion<'buf>> for Union {
    fn take_from(from: &mut WireUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalUnion<'buf>> for Option<Box<Union>> {
    fn take_from(from: &mut WireOptionalUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Union`].
#[repr(transparent)]
pub struct WireUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod r#union {
    pub enum Ref<'union, 'buf> {
        Primitive(&'union ::fidl_next::i32_le),

        StringNeedsConstructor(&'union ::fidl_next::WireString<'buf>),

        VectorStringAlsoNeedsConstructor(
            &'union ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
        ),
    }

    pub enum Mut<'union, 'buf> {
        Primitive(&'union mut ::fidl_next::i32_le),

        StringNeedsConstructor(&'union mut ::fidl_next::WireString<'buf>),

        VectorStringAlsoNeedsConstructor(
            &'union mut ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
        ),
    }
}

impl<'buf> WireUnion<'buf> {
    pub fn as_ref(&self) -> crate::r#union::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::r#union::Ref::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::r#union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            3 => crate::r#union::Ref::VectorStringAlsoNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::r#union::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => {
                crate::r#union::Mut::Primitive(unsafe { self.raw.get_mut().deref_mut_unchecked() })
            }

            2 => crate::r#union::Mut::StringNeedsConstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => crate::r#union::Mut::VectorStringAlsoNeedsConstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            2 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'buf>>().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<
                            ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>
                        >().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnion<'buf>> {
        if self.is_some() {
            Some(WireUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalUnion<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnionContainingEmptyStruct {
    Empty(crate::Empty),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnionContainingEmptyStruct {
    type Encoded<'buf> = WireUnionContainingEmptyStruct;
}

impl<___E> ::fidl_next::Encode<___E> for UnionContainingEmptyStruct
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::Empty: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionContainingEmptyStruct { raw, _phantom: _ } = slot);

        match self {
            Self::Empty(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Empty>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnionContainingEmptyStruct> {
    type EncodedOption<'buf> = WireOptionalUnionContainingEmptyStruct;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnionContainingEmptyStruct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnionContainingEmptyStruct: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionContainingEmptyStruct { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnionContainingEmptyStruct> for UnionContainingEmptyStruct {
    fn take_from(from: &mut WireUnionContainingEmptyStruct) -> Self {
        match from.raw.ordinal() {
            1 => Self::Empty(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnionContainingEmptyStruct>
    for Option<Box<UnionContainingEmptyStruct>>
{
    fn take_from(from: &mut WireOptionalUnionContainingEmptyStruct) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionContainingEmptyStruct`].
#[repr(transparent)]
pub struct WireUnionContainingEmptyStruct {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod union_containing_empty_struct {
    pub enum Ref<'union> {
        Empty(&'union crate::WireEmpty),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        Empty(&'union mut crate::WireEmpty),

        UnknownOrdinal(u64),
    }
}

impl WireUnionContainingEmptyStruct {
    pub fn as_ref(&self) -> crate::union_containing_empty_struct::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union_containing_empty_struct::Ref::Empty(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::union_containing_empty_struct::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::union_containing_empty_struct::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::union_containing_empty_struct::Mut::Empty(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            unknown => crate::union_containing_empty_struct::Mut::UnknownOrdinal(unknown),
        }
    }
}

impl Clone for WireUnionContainingEmptyStruct {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<crate::WireEmpty>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireUnionContainingEmptyStruct
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireEmpty: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireEmpty>(raw, decoder)?
            }

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnionContainingEmptyStruct {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireEmpty>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionContainingEmptyStruct {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnionContainingEmptyStruct {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionContainingEmptyStruct> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnionContainingEmptyStruct> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnionContainingEmptyStruct> {
        if self.is_some() {
            Some(WireUnionContainingEmptyStruct {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnionContainingEmptyStruct {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnionContainingEmptyStruct {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnionContainingEmptyStruct {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<crate::WireEmpty>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalUnionContainingEmptyStruct
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireEmpty: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireEmpty>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnionContainingEmptyStruct {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnionSandwich {
    pub a: u32,

    pub u: crate::ExplicitFlexibleUnion,

    pub b: u32,
}

impl ::fidl_next::Encodable for UnionSandwich {
    type Encoded<'buf> = WireUnionSandwich<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnionSandwich
where
    u32: ::fidl_next::Encode<___E>,

    crate::ExplicitFlexibleUnion: ::fidl_next::Encode<___E>,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                u,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.u, encoder, u)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnionSandwich> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireUnionSandwich<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnionSandwich>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnionSandwich: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnionSandwich<'buf>> for UnionSandwich {
    fn take_from(from: &mut WireUnionSandwich<'buf>) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&mut from.a),

            u: ::fidl_next::TakeFrom::take_from(&mut from.u),

            b: ::fidl_next::TakeFrom::take_from(&mut from.b),
        }
    }
}

/// The wire type corersponding to [`UnionSandwich`].
#[derive(Debug)]
#[repr(C)]
pub struct WireUnionSandwich<'buf> {
    pub a: ::fidl_next::u32_le,

    pub u: crate::WireExplicitFlexibleUnion<'buf>,

    pub b: ::fidl_next::u32_le,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireUnionSandwich<'buf>
where
    ___D: ?Sized,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,

    crate::WireExplicitFlexibleUnion<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut u,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnionWithAttributes {
    X(i64),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnionWithAttributes {
    type Encoded<'buf> = WireUnionWithAttributes<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnionWithAttributes
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i64: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionWithAttributes { raw, _phantom: _ } = slot);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnionWithAttributes> {
    type EncodedOption<'buf> = WireOptionalUnionWithAttributes<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnionWithAttributes>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnionWithAttributes: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionWithAttributes { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnionWithAttributes<'buf>> for UnionWithAttributes {
    fn take_from(from: &mut WireUnionWithAttributes<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::X(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalUnionWithAttributes<'buf>>
    for Option<Box<UnionWithAttributes>>
{
    fn take_from(from: &mut WireOptionalUnionWithAttributes<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionWithAttributes`].
#[repr(transparent)]
pub struct WireUnionWithAttributes<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod union_with_attributes {
    pub enum Ref<'union> {
        X(&'union ::fidl_next::i64_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        X(&'union mut ::fidl_next::i64_le),

        UnknownOrdinal(u64),
    }
}

impl<'buf> WireUnionWithAttributes<'buf> {
    pub fn as_ref(&self) -> crate::union_with_attributes::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union_with_attributes::Ref::X(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::union_with_attributes::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::union_with_attributes::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::union_with_attributes::Mut::X(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            unknown => crate::union_with_attributes::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireUnionWithAttributes<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i64_le>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireUnionWithAttributes<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i64_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionWithAttributes<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnionWithAttributes<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionWithAttributes<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnionWithAttributes<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnionWithAttributes<'buf>> {
        if self.is_some() {
            Some(WireUnionWithAttributes {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnionWithAttributes<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalUnionWithAttributes<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::i64_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i64_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalUnionWithAttributes<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}
