// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

::fidl_next::bitflags! {

    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BitsMember: u32 {
        const BIT_ONE = 1;
        const BIT_TWO = 2;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for BitsMember {
    type Encoded<'buf> = WireBitsMember;
}

impl<___E> ::fidl_next::Encode<___E> for BitsMember
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBitsMember { mut value } = slot);
        *value = ::fidl_next::u32_le::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<WireBitsMember> for BitsMember {
    fn from(wire: WireBitsMember) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBitsMember> for BitsMember {
    fn take_from(from: &mut WireBitsMember) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`BitsMember`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBitsMember {
    value: ::fidl_next::u32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBitsMember
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<BitsMember> for WireBitsMember {
    fn from(natural: BitsMember) -> Self {
        Self { value: ::fidl_next::u32_le::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug)]
#[repr(u32)]
pub enum Op {
    Add = 1,
    Mul = 2,
    Div = 3,
    UnknownOrdinal(u32),
}

impl ::fidl_next::Encodable for Op {
    type Encoded<'buf> = WireOp;
}

impl<___E> ::fidl_next::Encode<___E> for Op
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOp { mut value } = slot);
        *value = ::fidl_next::u32_le::from(match *self {
            Self::Add => 1,

            Self::Mul => 2,

            Self::Div => 3,

            Self::UnknownOrdinal(value) => value,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireOp> for Op {
    fn from(wire: WireOp) -> Self {
        match u32::from(wire.value) {
            1 => Self::Add,

            2 => Self::Mul,

            3 => Self::Div,

            value => Self::UnknownOrdinal(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireOp> for Op {
    fn take_from(from: &mut WireOp) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Op`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireOp {
    value: ::fidl_next::u32_le,
}

impl WireOp {
    pub const ADD: WireOp = WireOp { value: ::fidl_next::u32_le::from_native(1) };

    pub const MUL: WireOp = WireOp { value: ::fidl_next::u32_le::from_native(2) };

    pub const DIV: WireOp = WireOp { value: ::fidl_next::u32_le::from_native(3) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOp
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Op> for WireOp {
    fn from(natural: Op) -> Self {
        match natural {
            Op::Add => WireOp::ADD,

            Op::Mul => WireOp::MUL,

            Op::Div => WireOp::DIV,

            Op::UnknownOrdinal(value) => WireOp { value: ::fidl_next::u32_le::from(value) },
        }
    }
}

#[derive(Clone, Debug)]
pub struct OverrideTest {
    pub op: crate::Op,

    pub left: Option<Box<crate::Expression>>,

    pub right: Option<Box<crate::Expression>>,
}

impl ::fidl_next::Encodable for OverrideTest {
    type Encoded<'buf> = WireOverrideTest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for OverrideTest
where
    crate::Op: ::fidl_next::Encode<___E>,

    Option<Box<crate::Expression>>: ::fidl_next::Encode<___E>,

    Option<Box<crate::Expression>>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                op,
                left,
                right,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.op, encoder, op)?;

        ::fidl_next::Encode::encode(&mut self.left, encoder, left)?;

        ::fidl_next::Encode::encode(&mut self.right, encoder, right)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OverrideTest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireOverrideTest<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OverrideTest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OverrideTest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOverrideTest<'buf>> for OverrideTest {
    fn take_from(from: &mut WireOverrideTest<'buf>) -> Self {
        Self {
            op: ::fidl_next::TakeFrom::take_from(&mut from.op),

            left: ::fidl_next::TakeFrom::take_from(&mut from.left),

            right: ::fidl_next::TakeFrom::take_from(&mut from.right),
        }
    }
}

/// The wire type corersponding to [`OverrideTest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireOverrideTest<'buf> {
    pub op: crate::WireOp,

    pub left: crate::WireOptionalExpression<'buf>,

    pub right: crate::WireOptionalExpression<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOverrideTest<'buf>
where
    ___D: ?Sized,

    crate::WireOp: ::fidl_next::Decode<___D>,

    crate::WireOptionalExpression<'buf>: ::fidl_next::Decode<___D>,

    crate::WireOptionalExpression<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut op,
                mut left,
                mut right,

            } = slot;
        }

        ::fidl_next::Decode::decode(op.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(left.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(right.as_mut(), decoder)?;

        Ok(())
    }
}

::fidl_next::bitflags! {

    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Flags: u16 {
        const INLINE = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Flags {
    type Encoded<'buf> = WireFlags;
}

impl<___E> ::fidl_next::Encode<___E> for Flags
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlags { mut value } = slot);
        *value = ::fidl_next::u16_le::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<WireFlags> for Flags {
    fn from(wire: WireFlags) -> Self {
        Self::from_bits_retain(u16::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireFlags> for Flags {
    fn take_from(from: &mut WireFlags) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Flags`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireFlags {
    value: ::fidl_next::u16_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlags
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Flags> for WireFlags {
    fn from(natural: Flags) -> Self {
        Self { value: ::fidl_next::u16_le::from(natural.bits()) }
    }
}

#[derive(Clone, Debug)]
pub struct FunctionApplication {
    pub func: Option<String>,

    pub args: Option<Vec<Option<Box<crate::Expression>>>>,

    pub flags: Option<crate::Flags>,
}

impl FunctionApplication {
    fn __max_ordinal(&self) -> usize {
        if self.func.is_some() {
            return 1;
        }

        if self.args.is_some() {
            return 3;
        }

        if self.flags.is_some() {
            return 4;
        }

        0
    }
}

impl ::fidl_next::Encodable for FunctionApplication {
    type Encoded<'buf> = WireFunctionApplication<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for FunctionApplication
where
    ___E: ::fidl_next::Encoder + ?Sized,

    String: ::fidl_next::Encode<___E>,

    Vec<Option<Box<crate::Expression>>>: ::fidl_next::Encode<___E>,

    crate::Flags: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFunctionApplication { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                4 => {
                    if let Some(flags) = &mut self.flags {
                        ::fidl_next::WireEnvelope::encode_value(
                            flags,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                3 => {
                    if let Some(args) = &mut self.args {
                        ::fidl_next::WireEnvelope::encode_value(
                            args,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                1 => {
                    if let Some(func) = &mut self.func {
                        ::fidl_next::WireEnvelope::encode_value(
                            func,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireFunctionApplication<'buf>> for FunctionApplication {
    fn take_from(from: &mut WireFunctionApplication<'buf>) -> Self {
        Self {
            func: from.func_mut().map(::fidl_next::TakeFrom::take_from),

            args: from.args_mut().map(::fidl_next::TakeFrom::take_from),

            flags: from.flags_mut().map(::fidl_next::TakeFrom::take_from),
        }
    }
}

/// The wire type corresponding to [`FunctionApplication`].
#[repr(C)]
pub struct WireFunctionApplication<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireFunctionApplication<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::WireString<'buf>: ::fidl_next::Decode<___D>,

    ::fidl_next::WireVector<'buf, crate::WireOptionalExpression<'buf>>: ::fidl_next::Decode<___D>,

    crate::WireFlags: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireString<'buf>>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    let func = unsafe {
                        slot.deref_unchecked().deref_unchecked::<::fidl_next::WireString<'buf>>()
                    };

                    if func.len() > 100 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: func.len() as u64,
                            limit: 100,
                        });
                    }

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<'buf, crate::WireOptionalExpression<'buf>>,
                    >(slot.as_mut(), decoder)?;

                    let args = unsafe {
                        slot
                                            .deref_unchecked()
                                            .deref_unchecked::<
                                                ::fidl_next::WireVector<'buf, crate::WireOptionalExpression<'buf>>
                                            >()
                    };

                    if args.len() > 5 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: args.len() as u64,
                            limit: 5,
                        });
                    }

                    Ok(())
                }

                4 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, crate::WireFlags>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireFunctionApplication<'buf> {
    pub fn func(&self) -> Option<&::fidl_next::WireString<'buf>> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn func_mut(&mut self) -> Option<&mut ::fidl_next::WireString<'buf>> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_func(&mut self) -> Option<::fidl_next::WireString<'buf>> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }

    pub fn args(
        &self,
    ) -> Option<&::fidl_next::WireVector<'buf, crate::WireOptionalExpression<'buf>>> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }

    pub fn args_mut(
        &mut self,
    ) -> Option<&mut ::fidl_next::WireVector<'buf, crate::WireOptionalExpression<'buf>>> {
        unsafe { Some(self.table.get_mut(3)?.deref_mut_unchecked()) }
    }

    pub fn take_args(
        &mut self,
    ) -> Option<::fidl_next::WireVector<'buf, crate::WireOptionalExpression<'buf>>> {
        unsafe { Some(self.table.get_mut(3)?.take_unchecked()) }
    }

    pub fn flags(&self) -> Option<&crate::WireFlags> {
        unsafe { Some(self.table.get(4)?.deref_unchecked()) }
    }

    pub fn flags_mut(&mut self) -> Option<&mut crate::WireFlags> {
        unsafe { Some(self.table.get_mut(4)?.deref_mut_unchecked()) }
    }

    pub fn take_flags(&mut self) -> Option<crate::WireFlags> {
        unsafe { Some(self.table.get_mut(4)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireFunctionApplication<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("FunctionApplication")
            .field("func", &self.func())
            .field("args", &self.args())
            .field("flags", &self.flags())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum Expression {
    Value(u64),

    BinOp(crate::OverrideTest),

    FunctionApplication(crate::FunctionApplication),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for Expression {
    type Encoded<'buf> = WireExpression<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Expression
where
    ___E: ::fidl_next::Encoder + ?Sized,

    u64: ::fidl_next::Encode<___E>,

    crate::OverrideTest: ::fidl_next::Encode<___E>,

    crate::FunctionApplication: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExpression { raw, _phantom: _ } = slot);

        match self {
            Self::Value(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u64>(value, 1, encoder, raw)?
            }

            Self::BinOp(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::OverrideTest>(
                    value, 2, encoder, raw,
                )?
            }

            Self::FunctionApplication(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::FunctionApplication,
            >(value, 3, encoder, raw)?,

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Expression> {
    type EncodedOption<'buf> = WireOptionalExpression<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Expression>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Expression: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExpression { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireExpression<'buf>> for Expression {
    fn take_from(from: &mut WireExpression<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Value(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::BinOp(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FunctionApplication(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalExpression<'buf>> for Option<Box<Expression>> {
    fn take_from(from: &mut WireOptionalExpression<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Expression`].
#[repr(transparent)]
pub struct WireExpression<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod expression {
    pub enum Ref<'union, 'buf> {
        Value(&'union ::fidl_next::u64_le),

        BinOp(&'union crate::WireOverrideTest<'buf>),

        FunctionApplication(&'union crate::WireFunctionApplication<'buf>),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union, 'buf> {
        Value(&'union mut ::fidl_next::u64_le),

        BinOp(&'union mut crate::WireOverrideTest<'buf>),

        FunctionApplication(&'union mut crate::WireFunctionApplication<'buf>),

        UnknownOrdinal(u64),
    }
}

impl<'buf> WireExpression<'buf> {
    pub fn as_ref(&self) -> crate::expression::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::expression::Ref::Value(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::expression::Ref::BinOp(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::expression::Ref::FunctionApplication(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::expression::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::expression::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => crate::expression::Mut::Value(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => crate::expression::Mut::BinOp(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            3 => crate::expression::Mut::FunctionApplication(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            unknown => crate::expression::Mut::UnknownOrdinal(unknown),
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireExpression<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::u64_le: ::fidl_next::Decode<___D>,

    crate::WireOverrideTest<'buf>: ::fidl_next::Decode<___D>,

    crate::WireFunctionApplication<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u64_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireOverrideTest<'buf>>(
                raw, decoder,
            )?,

            3 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireFunctionApplication<'buf>>(
                    raw, decoder,
                )?
            }

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExpression<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u64_le>().fmt(f) },
            2 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireOverrideTest<'buf>>().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireFunctionApplication<'buf>>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExpression<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalExpression<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExpression<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExpression<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExpression<'buf>> {
        if self.is_some() {
            Some(WireExpression {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExpression<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalExpression<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    ::fidl_next::u64_le: ::fidl_next::Decode<___D>,

    crate::WireOverrideTest<'buf>: ::fidl_next::Decode<___D>,

    crate::WireFunctionApplication<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u64_le>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireOverrideTest<'buf>>(
                raw, decoder,
            )?,

            3 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireFunctionApplication<'buf>>(
                    raw, decoder,
                )?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExpression<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnionMember {
    UnionData(u8),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnionMember {
    type Encoded<'buf> = WireUnionMember;
}

impl<___E> ::fidl_next::Encode<___E> for UnionMember
where
    ___E: ::fidl_next::Encoder + ?Sized,

    u8: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionMember { raw, _phantom: _ } = slot);

        match self {
            Self::UnionData(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u8>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnionMember> {
    type EncodedOption<'buf> = WireOptionalUnionMember;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnionMember>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnionMember: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionMember { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnionMember> for UnionMember {
    fn take_from(from: &mut WireUnionMember) -> Self {
        match from.raw.ordinal() {
            2 => Self::UnionData(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnionMember> for Option<Box<UnionMember>> {
    fn take_from(from: &mut WireOptionalUnionMember) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionMember`].
#[repr(transparent)]
pub struct WireUnionMember {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod union_member {
    pub enum Ref<'union> {
        UnionData(&'union u8),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        UnionData(&'union mut u8),

        UnknownOrdinal(u64),
    }
}

impl WireUnionMember {
    pub fn as_ref(&self) -> crate::union_member::Ref<'_> {
        match self.raw.ordinal() {
            2 => crate::union_member::Ref::UnionData(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::union_member::Ref::UnknownOrdinal(unknown),
        }
    }

    pub fn as_mut(&mut self) -> crate::union_member::Mut<'_> {
        match self.raw.ordinal() {
            2 => crate::union_member::Mut::UnionData(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            unknown => crate::union_member::Mut::UnknownOrdinal(unknown),
        }
    }
}

impl Clone for WireUnionMember {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<u8>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireUnionMember
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    u8: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, u8>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnionMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            2 => unsafe { self.raw.get().deref_unchecked::<u8>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionMember {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnionMember {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionMember> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnionMember> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnionMember> {
        if self.is_some() {
            Some(WireUnionMember {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnionMember {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnionMember {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnionMember {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<u8>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalUnionMember
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    u8: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, u8>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnionMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct TableData {
    pub data: u8,
}

impl ::fidl_next::Encodable for TableData {
    type Encoded<'buf> = WireTableData;
}

impl<___E> ::fidl_next::Encode<___E> for TableData
where
    u8: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                data,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.data, encoder, data)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<TableData> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireTableData>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<TableData>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TableData: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTableData> for TableData {
    fn take_from(from: &mut WireTableData) -> Self {
        Self { data: ::fidl_next::TakeFrom::take_from(&mut from.data) }
    }
}

/// The wire type corersponding to [`TableData`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireTableData {
    pub data: u8,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTableData
where
    ___D: ?Sized,

    u8: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut data,

            } = slot;
        }

        ::fidl_next::Decode::decode(data.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TableMember {
    pub table_data: Option<Vec<crate::TableData>>,
}

impl TableMember {
    fn __max_ordinal(&self) -> usize {
        if self.table_data.is_some() {
            return 2;
        }

        0
    }
}

impl ::fidl_next::Encodable for TableMember {
    type Encoded<'buf> = WireTableMember<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for TableMember
where
    ___E: ::fidl_next::Encoder + ?Sized,

    Vec<crate::TableData>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTableMember { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                2 => {
                    if let Some(table_data) = &mut self.table_data {
                        ::fidl_next::WireEnvelope::encode_value(
                            table_data,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireTableMember<'buf>> for TableMember {
    fn take_from(from: &mut WireTableMember<'buf>) -> Self {
        Self { table_data: from.table_data_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`TableMember`].
#[repr(C)]
pub struct WireTableMember<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireTableMember<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::WireVector<'buf, crate::WireTableData>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<'buf, crate::WireTableData>,
                    >(slot.as_mut(), decoder)?;

                    let table_data = unsafe {
                        slot.deref_unchecked()
                            .deref_unchecked::<::fidl_next::WireVector<'buf, crate::WireTableData>>(
                            )
                    };

                    if table_data.len() > 10 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: table_data.len() as u64,
                            limit: 10,
                        });
                    }

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireTableMember<'buf> {
    pub fn table_data(&self) -> Option<&::fidl_next::WireVector<'buf, crate::WireTableData>> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }

    pub fn table_data_mut(
        &mut self,
    ) -> Option<&mut ::fidl_next::WireVector<'buf, crate::WireTableData>> {
        unsafe { Some(self.table.get_mut(2)?.deref_mut_unchecked()) }
    }

    pub fn take_table_data(
        &mut self,
    ) -> Option<::fidl_next::WireVector<'buf, crate::WireTableData>> {
        unsafe { Some(self.table.get_mut(2)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireTableMember<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("TableMember").field("table_data", &self.table_data()).finish()
    }
}

#[derive(Clone, Debug)]
pub struct SomeProtocolSomeMethodRequest {
    pub union_member: crate::UnionMember,

    pub table_member: crate::TableMember,
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodRequest {
    type Encoded<'buf> = WireSomeProtocolSomeMethodRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodRequest
where
    crate::UnionMember: ::fidl_next::Encode<___E>,

    crate::TableMember: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                union_member,
                table_member,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.union_member, encoder, union_member)?;

        ::fidl_next::Encode::encode(&mut self.table_member, encoder, table_member)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SomeProtocolSomeMethodRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireSomeProtocolSomeMethodRequest<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<SomeProtocolSomeMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodRequest<'buf>>
    for SomeProtocolSomeMethodRequest
{
    fn take_from(from: &mut WireSomeProtocolSomeMethodRequest<'buf>) -> Self {
        Self {
            union_member: ::fidl_next::TakeFrom::take_from(&mut from.union_member),

            table_member: ::fidl_next::TakeFrom::take_from(&mut from.table_member),
        }
    }
}

/// The wire type corersponding to [`SomeProtocolSomeMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireSomeProtocolSomeMethodRequest<'buf> {
    pub union_member: crate::WireUnionMember,

    pub table_member: crate::WireTableMember<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodRequest<'buf>
where
    ___D: ?Sized,

    crate::WireUnionMember: ::fidl_next::Decode<___D>,

    crate::WireTableMember<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut union_member,
                mut table_member,

            } = slot;
        }

        ::fidl_next::Decode::decode(union_member.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table_member.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct SomeProtocolSomeMethodResponse {
    pub bits_member: crate::BitsMember,
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodResponse {
    type Encoded<'buf> = WireSomeProtocolSomeMethodResponse;
}

impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodResponse
where
    crate::BitsMember: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits_member,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.bits_member, encoder, bits_member)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SomeProtocolSomeMethodResponse> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireSomeProtocolSomeMethodResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<SomeProtocolSomeMethodResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodResponse> for SomeProtocolSomeMethodResponse {
    fn take_from(from: &mut WireSomeProtocolSomeMethodResponse) -> Self {
        Self { bits_member: ::fidl_next::TakeFrom::take_from(&mut from.bits_member) }
    }
}

/// The wire type corersponding to [`SomeProtocolSomeMethodResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireSomeProtocolSomeMethodResponse {
    pub bits_member: crate::WireBitsMember,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodResponse
where
    ___D: ?Sized,

    crate::WireBitsMember: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut bits_member,

            } = slot;
        }

        ::fidl_next::Decode::decode(bits_member.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Copy, Debug)]
#[repr(u32)]
pub enum SomeProtocolSomeMethodError {
    ErrorOne = 1,
    ErrorTwo = 2,
    UnknownOrdinal(u32),
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodError {
    type Encoded<'buf> = WireSomeProtocolSomeMethodError;
}

impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodError
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSomeProtocolSomeMethodError { mut value } = slot);
        *value = ::fidl_next::u32_le::from(match *self {
            Self::ErrorOne => 1,

            Self::ErrorTwo => 2,

            Self::UnknownOrdinal(value) => value,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireSomeProtocolSomeMethodError> for SomeProtocolSomeMethodError {
    fn from(wire: WireSomeProtocolSomeMethodError) -> Self {
        match u32::from(wire.value) {
            1 => Self::ErrorOne,

            2 => Self::ErrorTwo,

            value => Self::UnknownOrdinal(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodError> for SomeProtocolSomeMethodError {
    fn take_from(from: &mut WireSomeProtocolSomeMethodError) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodError`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireSomeProtocolSomeMethodError {
    value: ::fidl_next::u32_le,
}

impl WireSomeProtocolSomeMethodError {
    pub const ERROR_ONE: WireSomeProtocolSomeMethodError =
        WireSomeProtocolSomeMethodError { value: ::fidl_next::u32_le::from_native(1) };

    pub const ERROR_TWO: WireSomeProtocolSomeMethodError =
        WireSomeProtocolSomeMethodError { value: ::fidl_next::u32_le::from_native(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodError
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<SomeProtocolSomeMethodError> for WireSomeProtocolSomeMethodError {
    fn from(natural: SomeProtocolSomeMethodError) -> Self {
        match natural {
            SomeProtocolSomeMethodError::ErrorOne => WireSomeProtocolSomeMethodError::ERROR_ONE,

            SomeProtocolSomeMethodError::ErrorTwo => WireSomeProtocolSomeMethodError::ERROR_TWO,

            SomeProtocolSomeMethodError::UnknownOrdinal(value) => {
                WireSomeProtocolSomeMethodError { value: ::fidl_next::u32_le::from(value) }
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum SomeProtocolSomeMethodResult {
    Response(crate::SomeProtocolSomeMethodResponse),

    Err(crate::SomeProtocolSomeMethodError),
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodResult {
    type Encoded<'buf> = WireSomeProtocolSomeMethodResult;
}

impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::SomeProtocolSomeMethodResponse: ::fidl_next::Encode<___E>,

    crate::SomeProtocolSomeMethodError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSomeProtocolSomeMethodResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::SomeProtocolSomeMethodResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::SomeProtocolSomeMethodError,
            >(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SomeProtocolSomeMethodResult> {
    type EncodedOption<'buf> = WireOptionalSomeProtocolSomeMethodResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<SomeProtocolSomeMethodResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalSomeProtocolSomeMethodResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodResult> for SomeProtocolSomeMethodResult {
    fn take_from(from: &mut WireSomeProtocolSomeMethodResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalSomeProtocolSomeMethodResult>
    for Option<Box<SomeProtocolSomeMethodResult>>
{
    fn take_from(from: &mut WireOptionalSomeProtocolSomeMethodResult) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodResult`].
#[repr(transparent)]
pub struct WireSomeProtocolSomeMethodResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod some_protocol_some_method_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireSomeProtocolSomeMethodResponse),

        Err(&'union crate::WireSomeProtocolSomeMethodError),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireSomeProtocolSomeMethodResponse),

        Err(&'union mut crate::WireSomeProtocolSomeMethodError),
    }
}

impl WireSomeProtocolSomeMethodResult {
    pub fn as_ref(&self) -> crate::some_protocol_some_method_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::some_protocol_some_method_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::some_protocol_some_method_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> crate::some_protocol_some_method_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::some_protocol_some_method_result::Mut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => crate::some_protocol_some_method_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireSomeProtocolSomeMethodResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireSomeProtocolSomeMethodResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireSomeProtocolSomeMethodError>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireSomeProtocolSomeMethodResponse: ::fidl_next::Decode<___D>,

    crate::WireSomeProtocolSomeMethodError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireSomeProtocolSomeMethodResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireSomeProtocolSomeMethodError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireSomeProtocolSomeMethodResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireSomeProtocolSomeMethodResponse>().fmt(f)
            },
            2 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireSomeProtocolSomeMethodError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalSomeProtocolSomeMethodResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalSomeProtocolSomeMethodResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireSomeProtocolSomeMethodResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireSomeProtocolSomeMethodResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireSomeProtocolSomeMethodResult> {
        if self.is_some() {
            Some(WireSomeProtocolSomeMethodResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalSomeProtocolSomeMethodResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalSomeProtocolSomeMethodResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalSomeProtocolSomeMethodResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireSomeProtocolSomeMethodResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireSomeProtocolSomeMethodError>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D> for WireOptionalSomeProtocolSomeMethodResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireSomeProtocolSomeMethodResponse: ::fidl_next::Decode<___D>,

    crate::WireSomeProtocolSomeMethodError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireSomeProtocolSomeMethodResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireSomeProtocolSomeMethodError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalSomeProtocolSomeMethodResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the SomeProtocol protocol.
#[derive(Debug)]
pub struct SomeProtocol;

pub mod some_protocol {

    pub struct SomeMethod;

    impl ::fidl_next::bind::Method for SomeMethod {
        const ORDINAL: u64 = 2515914517457749720;

        type Protocol = crate::SomeProtocol;

        type Request<'buf> = crate::WireSomeProtocolSomeMethodRequest<'buf>;

        type Response<'buf> = crate::WireSomeProtocolSomeMethodResult;
    }
}

/// A helper trait for the `SomeProtocol` client protocol.
pub trait SomeProtocolClient<___T: ::fidl_next::protocol::Transport> {
    fn some_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, some_protocol::SomeMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireSomeProtocolSomeMethodRequest<'buf>,
        >;
}

impl<___T> SomeProtocolClient<___T> for ::fidl_next::bind::Client<___T, SomeProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn some_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::TransactionFuture<'_, ___T, some_protocol::SomeMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::Encoder<'buf>,
            Encoded<'buf> = crate::WireSomeProtocolSomeMethodRequest<'buf>,
        >,
    {
        self.untyped()
            .send_transaction(2515914517457749720, request)
            .map(::fidl_next::bind::TransactionFuture::from_untyped)
    }
}

/// A client handler for the SomeProtocol protocol.

pub trait SomeProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for SomeProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: SomeProtocolClientHandler<___T>,

    for<'buf> crate::WireSomeProtocolSomeMethodResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(handler: &mut ___H, ordinal: u64, buffer: ___T::RecvBuffer) {
        match ordinal {
            ordinal => todo!(),
        }
    }
}

/// A helper trait for the `SomeProtocol` server protocol.
pub trait SomeProtocolServer<___T: ::fidl_next::protocol::Transport> {}

impl<___T> SomeProtocolServer<___T> for ::fidl_next::bind::Server<___T, SomeProtocol> where
    ___T: ::fidl_next::protocol::Transport
{
}

/// A server handler for the SomeProtocol protocol.

pub trait SomeProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn some_method(
        &mut self,
        request: ::fidl_next::bind::RequestBuffer<___T, some_protocol::SomeMethod>,
        responder: ::fidl_next::bind::Responder<some_protocol::SomeMethod>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for SomeProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: SomeProtocolServerHandler<___T>,

    for<'buf> crate::WireSomeProtocolSomeMethodRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(handler: &mut ___H, ordinal: u64, buffer: ___T::RecvBuffer) {
        match ordinal {
            ordinal => todo!(),
        }
    }

    fn on_transaction(
        handler: &mut ___H,
        ordinal: u64,
        mut buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2515914517457749720 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.some_method(buffer, responder);
            }

            ordinal => todo!(),
        }
    }
}
