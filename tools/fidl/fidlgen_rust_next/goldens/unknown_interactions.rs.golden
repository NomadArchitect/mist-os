// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'buf>>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
    ) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
        ),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse),
        
            Err(&'union mut ::fidl_next::i32_le),
        
        
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<
            'buf,
        >,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
        ),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse),
        
            Err(&'union mut ::fidl_next::i32_le),
        
        
    }
}

impl<'buf> WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>>
    {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    type Encoded<'buf> =
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>,
    > for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'_>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
    type Encoded<'buf> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<
            'buf,
        >,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union, 'buf> {
        Response(
            &'union crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<
                'buf,
            >,
        ),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>),
        
            Err(&'union mut ::fidl_next::i32_le),
        
        
    }
}

impl<'buf> WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result::Ref<
        '_,
        'buf,
    > {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result::Mut<
        '_,
        'buf,
    > {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>>
    {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the UnknownInteractionsAjarDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsAjarDriverProtocol;

pub mod unknown_interactions_ajar_driver_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::bind::Method for StrictOneWay {
        const ORDINAL: u64 = 200845620698173917;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::bind::Method for FlexibleOneWay {
        const ORDINAL: u64 = 3790953144423004126;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::bind::Method for StrictTwoWay {
        const ORDINAL: u64 = 523076268125513549;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::bind::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 902155904889801604;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::bind::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 8952307689721713673;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::bind::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 3114064683372134045;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'buf>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::bind::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 7057260423103547829;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::bind::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 6490530264582540031;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::bind::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 2319476129312263555;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::bind::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 6883106306697493305;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>;
    }
}

/// A helper trait for the `UnknownInteractionsAjarDriverProtocol` client sender.
pub trait UnknownInteractionsAjarDriverProtocolClientSender<___T: ::fidl_next::protocol::Transport>
{
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsAjarDriverProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarDriverProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(200845620698173917, &mut ())
    }

    fn flexible_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(3790953144423004126, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(523076268125513549, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(902155904889801604, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8952307689721713673, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3114064683372134045, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7057260423103547829, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6490530264582540031, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2319476129312263555, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6883106306697493305, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsAjarDriverProtocol protocol.

pub trait UnknownInteractionsAjarDriverProtocolClientHandler<___T: ::fidl_next::protocol::Transport>
{
    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H>
    for UnknownInteractionsAjarDriverProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsAjarDriverProtocolClientHandler<___T>,

    for<'buf> crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsAjarDriverProtocol` server sender.
pub trait UnknownInteractionsAjarDriverProtocolServerSender<___T: ::fidl_next::protocol::Transport>
{
}

impl<___T> UnknownInteractionsAjarDriverProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the UnknownInteractionsAjarDriverProtocol protocol.

pub trait UnknownInteractionsAjarDriverProtocolServerHandler<___T: ::fidl_next::protocol::Transport>
{
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWay,
        >,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H>
    for UnknownInteractionsAjarDriverProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsAjarDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            200845620698173917 => {
                handler.strict_one_way(sender);
            }

            3790953144423004126 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            523076268125513549 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            902155904889801604 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            8952307689721713673 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            3114064683372134045 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            7057260423103547829 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            6490530264582540031 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            2319476129312263555 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            6883106306697493305 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
{
    fn take_from(from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
{
    fn take_from(from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'buf>>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayErrResponse {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayErrResponse
{
    fn take_from(from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResult> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult>
    for UnknownInteractionsAjarProtocolStrictTwoWayErrResult
{
    fn take_from(from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_ajar_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_ajar_protocol_strict_two_way_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_err_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_ajar_protocol_strict_two_way_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() },
                )
            }

            2 => crate::unknown_interactions_ajar_protocol_strict_two_way_err_result::Mut::Err(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_fields_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_fields_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_protocol_strict_two_way_fields_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>,
    > for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl<'buf> WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>,
    > for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union, 'buf> {
        Response(
            &'union crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>,
        ),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(
            &'union mut crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<
                'buf,
            >,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl<'buf> WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_table_err_result::Ref<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_table_err_result::Mut<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_table_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_ajar_protocol_strict_two_way_table_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictEventFieldsRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
{
    fn take_from(from: &mut WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictEventUnionRequest>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
{
    fn take_from(from: &mut WireUnknownInteractionsAjarProtocolStrictEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest>
    for Option<Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_protocol_strict_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_event_union_request::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsAjarProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventTableRequest {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'buf>>
    for UnknownInteractionsAjarProtocolStrictEventTableRequest
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
{
    fn take_from(from: &mut WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
{
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventUnionRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
{
    fn take_from(from: &mut WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
    for Option<Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_ajar_protocol_flexible_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    type Encoded<'buf> = WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'buf>>
    for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
{
    fn take_from(
        from: &mut WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolFlexibleEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsAjarProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsAjarProtocol;

pub mod unknown_interactions_ajar_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::bind::Method for StrictOneWay {
        const ORDINAL: u64 = 956561744635167883;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::bind::Method for FlexibleOneWay {
        const ORDINAL: u64 = 2483093178939638607;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::bind::Method for StrictTwoWay {
        const ORDINAL: u64 = 364341676962177080;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::bind::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 1821674633227946298;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::bind::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 5870221221557233361;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::bind::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 8038805778859962068;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'buf>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::bind::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 6577335136969723910;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::bind::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 595881957484758745;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::bind::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 3224530777258896533;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::bind::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 3515589146717969463;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>;
    }

    pub struct StrictEvent;

    impl ::fidl_next::bind::Method for StrictEvent {
        const ORDINAL: u64 = 6927291151663612592;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::bind::Method for StrictEventFields {
        const ORDINAL: u64 = 5838220329633564521;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::bind::Method for StrictEventUnion {
        const ORDINAL: u64 = 6303151946645602671;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::bind::Method for StrictEventTable {
        const ORDINAL: u64 = 659277224687564957;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'buf>;
    }

    pub struct FlexibleEvent;

    impl ::fidl_next::bind::Method for FlexibleEvent {
        const ORDINAL: u64 = 1281760452005010931;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = ();
    }

    pub struct FlexibleEventFields;

    impl ::fidl_next::bind::Method for FlexibleEventFields {
        const ORDINAL: u64 = 4298964238728681570;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;
    }

    pub struct FlexibleEventUnion;

    impl ::fidl_next::bind::Method for FlexibleEventUnion {
        const ORDINAL: u64 = 8950943792372972717;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
    }

    pub struct FlexibleEventTable;

    impl ::fidl_next::bind::Method for FlexibleEventTable {
        const ORDINAL: u64 = 705539350563403440;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> =
            crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'buf>;
    }
}

/// A helper trait for the `UnknownInteractionsAjarProtocol` client sender.
pub trait UnknownInteractionsAjarProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsAjarProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(956561744635167883, &mut ())
    }

    fn flexible_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(2483093178939638607, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(364341676962177080, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1821674633227946298, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5870221221557233361, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8038805778859962068, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6577335136969723910, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(595881957484758745, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3224530777258896533, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_ajar_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3515589146717969463, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsAjarProtocol protocol.

pub trait UnknownInteractionsAjarProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::StrictEventFields,
        >,
    );

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::StrictEventUnion,
        >,
    );

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::StrictEventTable,
        >,
    );

    fn flexible_event(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn flexible_event_fields(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::FlexibleEventFields,
        >,
    );

    fn flexible_event_union(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::FlexibleEventUnion,
        >,
    );

    fn flexible_event_table(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::FlexibleEventTable,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsAjarProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for UnknownInteractionsAjarProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsAjarProtocolClientHandler<___T>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6927291151663612592 => {
                handler.strict_event(sender);
            }

            5838220329633564521 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_fields(sender, buffer);
            }

            6303151946645602671 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_union(sender, buffer);
            }

            659277224687564957 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_table(sender, buffer);
            }

            1281760452005010931 => {
                handler.flexible_event(sender);
            }

            4298964238728681570 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_fields(sender, buffer);
            }

            8950943792372972717 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_union(sender, buffer);
            }

            705539350563403440 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_table(sender, buffer);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsAjarProtocol` server sender.
pub trait UnknownInteractionsAjarProtocolServerSender<___T: ::fidl_next::protocol::Transport> {
    fn strict_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;
}

impl<___T> UnknownInteractionsAjarProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(6927291151663612592, &mut ())
    }

    fn strict_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(5838220329633564521, &mut ())
    }

    fn strict_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(6303151946645602671, &mut ())
    }

    fn strict_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(659277224687564957, &mut ())
    }

    fn flexible_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(1281760452005010931, &mut ())
    }

    fn flexible_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(4298964238728681570, &mut ())
    }

    fn flexible_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(8950943792372972717, &mut ())
    }

    fn flexible_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(705539350563403440, &mut ())
    }
}

/// A server handler for the UnknownInteractionsAjarProtocol protocol.

pub trait UnknownInteractionsAjarProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_ajar_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayFields,
        >,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayUnion,
        >,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayTable,
        >,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayErr,
        >,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayTableErr,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsAjarProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for UnknownInteractionsAjarProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsAjarProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            956561744635167883 => {
                handler.strict_one_way(sender);
            }

            2483093178939638607 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            364341676962177080 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            1821674633227946298 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            5870221221557233361 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            8038805778859962068 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            6577335136969723910 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            595881957484758745 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            3224530777258896533 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            3515589146717969463 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'buf>,
    > for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'_>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
    ) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    type Encoded<'buf> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    type Encoded<'buf> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    type Encoded<'buf> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
        ),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse),
        
            Err(&'union mut ::fidl_next::i32_le),
        
        
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
                    raw: ::fidl_next::RawWireUnion::null(),
                    _phantom: ::core::marker::PhantomData,
                };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    type Encoded<'buf> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
                    raw: ::fidl_next::RawWireUnion::null(),
                    _phantom: ::core::marker::PhantomData,
                };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
    type Encoded<'buf> =
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>,
    > for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<
            'buf,
        >,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
        ),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse),
        
            Err(&'union mut ::fidl_next::i32_le),
        
        
    }
}

impl<'buf> WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>>
    {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    type Encoded<'buf> =
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf>,
    > for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'_>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
    type Encoded<'buf> =
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>,
    > for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<
            'buf,
        >,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union, 'buf> {
        Response(
            &'union crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<
                'buf,
            >,
        ),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(&'union mut crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf>),
        
            Err(&'union mut ::fidl_next::i32_le),
        
        
    }
}

impl<'buf> WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result::Ref<
        '_,
        'buf,
    > {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result::Mut<
        '_,
        'buf,
    > {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<
                    'buf,
                >,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf>
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>>
    {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<
                    'buf,
                >,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the UnknownInteractionsClosedDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsClosedDriverProtocol;

pub mod unknown_interactions_closed_driver_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::bind::Method for StrictOneWay {
        const ORDINAL: u64 = 9111839835597799810;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::bind::Method for StrictTwoWay {
        const ORDINAL: u64 = 2815690661228737027;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::bind::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 5761316743698652038;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::bind::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 7235351480214368636;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::bind::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 1839495150551777151;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'buf>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::bind::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 4350840352076287137;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::bind::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 3933117456632607830;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::bind::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 4598950031783776653;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::bind::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 1456858375973362525;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>;
    }
}

/// A helper trait for the `UnknownInteractionsClosedDriverProtocol` client sender.
pub trait UnknownInteractionsClosedDriverProtocolClientSender<
    ___T: ::fidl_next::protocol::Transport,
>
{
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsClosedDriverProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, UnknownInteractionsClosedDriverProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(9111839835597799810, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2815690661228737027, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5761316743698652038, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7235351480214368636, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1839495150551777151, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4350840352076287137, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3933117456632607830, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4598950031783776653, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1456858375973362525, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsClosedDriverProtocol protocol.

pub trait UnknownInteractionsClosedDriverProtocolClientHandler<
    ___T: ::fidl_next::protocol::Transport,
>
{
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H>
    for UnknownInteractionsClosedDriverProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsClosedDriverProtocolClientHandler<___T>,

    for<'buf> crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `UnknownInteractionsClosedDriverProtocol` server sender.
pub trait UnknownInteractionsClosedDriverProtocolServerSender<
    ___T: ::fidl_next::protocol::Transport,
>
{
}

impl<___T> UnknownInteractionsClosedDriverProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the UnknownInteractionsClosedDriverProtocol protocol.

pub trait UnknownInteractionsClosedDriverProtocolServerHandler<
    ___T: ::fidl_next::protocol::Transport,
>
{
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H>
    for UnknownInteractionsClosedDriverProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsClosedDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            9111839835597799810 => {
                handler.strict_one_way(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2815690661228737027 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            5761316743698652038 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            7235351480214368636 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            1839495150551777151 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            4350840352076287137 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            3933117456632607830 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            4598950031783776653 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            1456858375973362525 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'buf>>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayErrResponse {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayErrResponse
{
    fn take_from(from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResult> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult>
    for UnknownInteractionsClosedProtocolStrictTwoWayErrResult
{
    fn take_from(from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_closed_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_closed_protocol_strict_two_way_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_err_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_closed_protocol_strict_two_way_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() },
                )
            }

            2 => crate::unknown_interactions_closed_protocol_strict_two_way_err_result::Mut::Err(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_fields_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_fields_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_protocol_strict_two_way_fields_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>,
    > for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl<'buf> WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>,
    > for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union, 'buf> {
        Response(
            &'union crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>,
        ),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(
            &'union mut crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<
                'buf,
            >,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl<'buf> WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_table_err_result::Ref<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_table_err_result::Mut<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_two_way_table_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_closed_protocol_strict_two_way_table_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
{
    fn take_from(from: &mut WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>
{
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictEventUnionRequest>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
{
    fn take_from(from: &mut WireUnknownInteractionsClosedProtocolStrictEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest>
    for Option<Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_closed_protocol_strict_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_closed_protocol_strict_event_union_request::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_closed_protocol_strict_event_union_request::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_closed_protocol_strict_event_union_request::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsClosedProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsClosedProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsClosedProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventTableRequest {
    type Encoded<'buf> = WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'buf>>
    for UnknownInteractionsClosedProtocolStrictEventTableRequest
{
    fn take_from(
        from: &mut WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsClosedProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsClosedProtocol;

pub mod unknown_interactions_closed_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::bind::Method for StrictOneWay {
        const ORDINAL: u64 = 401526495318825508;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::bind::Method for StrictTwoWay {
        const ORDINAL: u64 = 6834828562275693047;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::bind::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 1379139029283639891;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::bind::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 7544414847426850727;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::bind::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 7947328131967870853;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'buf>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::bind::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 5738532966428790074;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::bind::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 802395819586836733;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::bind::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 925029359463709824;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::bind::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 1260407702860823440;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>;
    }

    pub struct StrictEvent;

    impl ::fidl_next::bind::Method for StrictEvent {
        const ORDINAL: u64 = 760799297757210939;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::bind::Method for StrictEventFields {
        const ORDINAL: u64 = 6736355582617074292;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::bind::Method for StrictEventUnion {
        const ORDINAL: u64 = 4288682345454280036;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::bind::Method for StrictEventTable {
        const ORDINAL: u64 = 2871682464255309246;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> =
            crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'buf>;
    }
}

/// A helper trait for the `UnknownInteractionsClosedProtocol` client sender.
pub trait UnknownInteractionsClosedProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsClosedProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, UnknownInteractionsClosedProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(401526495318825508, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6834828562275693047, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1379139029283639891, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7544414847426850727, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7947328131967870853, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5738532966428790074, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(802395819586836733, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(925029359463709824, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1260407702860823440, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsClosedProtocol protocol.

pub trait UnknownInteractionsClosedProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsClosedProtocol>,
    );

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsClosedProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_closed_protocol::StrictEventFields,
        >,
    );

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsClosedProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_closed_protocol::StrictEventUnion,
        >,
    );

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsClosedProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_closed_protocol::StrictEventTable,
        >,
    );
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for UnknownInteractionsClosedProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsClosedProtocolClientHandler<___T>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            760799297757210939 => {
                handler.strict_event(sender);
            }

            6736355582617074292 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_fields(sender, buffer);
            }

            4288682345454280036 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_union(sender, buffer);
            }

            2871682464255309246 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_table(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `UnknownInteractionsClosedProtocol` server sender.
pub trait UnknownInteractionsClosedProtocolServerSender<___T: ::fidl_next::protocol::Transport> {
    fn strict_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;
}

impl<___T> UnknownInteractionsClosedProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(760799297757210939, &mut ())
    }

    fn strict_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(6736355582617074292, &mut ())
    }

    fn strict_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(4288682345454280036, &mut ())
    }

    fn strict_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(2871682464255309246, &mut ())
    }
}

/// A server handler for the UnknownInteractionsClosedProtocol protocol.

pub trait UnknownInteractionsClosedProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_closed_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayFields,
        >,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayUnion,
        >,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayTable,
        >,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayErr,
        >,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for UnknownInteractionsClosedProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsClosedProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            401526495318825508 => {
                handler.strict_one_way(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            6834828562275693047 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            1379139029283639891 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            7544414847426850727 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            7947328131967870853 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            5738532966428790074 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            802395819586836733 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            925029359463709824 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            1260407702860823440 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'buf>>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayErrResponse {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayErrResponse
{
    fn take_from(from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResult> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult>
    for UnknownInteractionsDriverProtocolStrictTwoWayErrResult
{
    fn take_from(from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_driver_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_driver_protocol_strict_two_way_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_err_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_driver_protocol_strict_two_way_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() },
                )
            }

            2 => crate::unknown_interactions_driver_protocol_strict_two_way_err_result::Mut::Err(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_fields_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_fields_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_strict_two_way_fields_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>,
    > for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>,
    > for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union, 'buf> {
        Response(
            &'union crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>,
        ),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(
            &'union mut crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<
                'buf,
            >,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_table_err_result::Ref<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_table_err_result::Mut<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_strict_two_way_table_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_strict_two_way_table_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayResponse {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayResponse
{
    fn take_from(from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResult> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayResult
{
    fn take_from(from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_fields_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
        ),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_fields_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_fields_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>,
    > for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
        ),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>,
    > for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_table_result {
    pub enum Ref<'union, 'buf> {
        Response(
            &'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>,
        ),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union, 'buf> {
        Response(
            &'union mut crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<
                'buf,
            >,
        ),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_table_result::Ref<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_table_result::Mut<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'buf>,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse,
    ) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>
{
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult
{
    fn take_from(from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse),

        Err(&'union ::fidl_next::i32_le),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse),

        Err(&'union mut ::fidl_next::i32_le),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
{
    type EncodedOption<'buf> = ::fidl_next::WireBox<
        'buf,
        WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult,
    > for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
        ),

        Err(&'union ::fidl_next::i32_le),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    > for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>,
    > for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
        ),

        Err(&'union ::fidl_next::i32_le),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(
            &'union mut crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
        ),

        Err(&'union mut ::fidl_next::i32_le),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Ref<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Mut<'_>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf>>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'_>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
    type Encoded<'buf> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse:
        ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>,
    > for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_table_err_result {
    pub enum Ref<'union, 'buf> {
        Response(
            &'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<
                'buf,
            >,
        ),

        Err(&'union ::fidl_next::i32_le),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union, 'buf> {
        Response(
            &'union mut crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<
                'buf,
            >,
        ),

        Err(&'union mut ::fidl_next::i32_le),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl<'buf> WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Ref<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Mut<'_, 'buf>
    {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf>
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>
{
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the UnknownInteractionsDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsDriverProtocol;

pub mod unknown_interactions_driver_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::bind::Method for StrictOneWay {
        const ORDINAL: u64 = 6982839851953080288;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::bind::Method for FlexibleOneWay {
        const ORDINAL: u64 = 1083620022582160398;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::bind::Method for StrictTwoWay {
        const ORDINAL: u64 = 1481114722667499972;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::bind::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 6841797014773573215;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::bind::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 1451514501977162287;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::bind::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 3330693085881435529;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'buf>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::bind::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 8222960355260037542;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::bind::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 225387363174180470;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::bind::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 3066880266580913088;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::bind::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 708169949929096689;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>;
    }

    pub struct FlexibleTwoWay;

    impl ::fidl_next::bind::Method for FlexibleTwoWay {
        const ORDINAL: u64 = 2929398860738426482;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult;
    }

    pub struct FlexibleTwoWayFields;

    impl ::fidl_next::bind::Method for FlexibleTwoWayFields {
        const ORDINAL: u64 = 8423663794424433896;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult;
    }

    pub struct FlexibleTwoWayUnion;

    impl ::fidl_next::bind::Method for FlexibleTwoWayUnion {
        const ORDINAL: u64 = 8216450897182897849;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>;
    }

    pub struct FlexibleTwoWayTable;

    impl ::fidl_next::bind::Method for FlexibleTwoWayTable {
        const ORDINAL: u64 = 1049265954148894210;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>;
    }

    pub struct FlexibleTwoWayErr;

    impl ::fidl_next::bind::Method for FlexibleTwoWayErr {
        const ORDINAL: u64 = 5583489590753947170;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;
    }

    pub struct FlexibleTwoWayFieldsErr;

    impl ::fidl_next::bind::Method for FlexibleTwoWayFieldsErr {
        const ORDINAL: u64 = 6033174601748665003;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult;
    }

    pub struct FlexibleTwoWayUnionErr;

    impl ::fidl_next::bind::Method for FlexibleTwoWayUnionErr {
        const ORDINAL: u64 = 6235121653537390575;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>;
    }

    pub struct FlexibleTwoWayTableErr;

    impl ::fidl_next::bind::Method for FlexibleTwoWayTableErr {
        const ORDINAL: u64 = 940887795361350656;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>;
    }
}

/// A helper trait for the `UnknownInteractionsDriverProtocol` client sender.
pub trait UnknownInteractionsDriverProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsDriverProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, UnknownInteractionsDriverProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(6982839851953080288, &mut ())
    }

    fn flexible_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(1083620022582160398, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1481114722667499972, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6841797014773573215, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1451514501977162287, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3330693085881435529, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8222960355260037542, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(225387363174180470, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3066880266580913088, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(708169949929096689, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2929398860738426482, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8423663794424433896, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8216450897182897849, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1049265954148894210, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5583489590753947170, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6033174601748665003, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6235121653537390575, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(940887795361350656, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsDriverProtocol protocol.

pub trait UnknownInteractionsDriverProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for UnknownInteractionsDriverProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsDriverProtocolClientHandler<___T>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsDriverProtocol` server sender.
pub trait UnknownInteractionsDriverProtocolServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> UnknownInteractionsDriverProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the UnknownInteractionsDriverProtocol protocol.

pub trait UnknownInteractionsDriverProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_driver_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayFields,
        >,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayUnion,
        >,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayTable,
        >,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayErr,
        >,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
    );

    fn flexible_two_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWay,
        >,
    );

    fn flexible_two_way_fields(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
    );

    fn flexible_two_way_union(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
    );

    fn flexible_two_way_table(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
    );

    fn flexible_two_way_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayErr,
        >,
    );

    fn flexible_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
    );

    fn flexible_two_way_union_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
    );

    fn flexible_two_way_table_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for UnknownInteractionsDriverProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6982839851953080288 => {
                handler.strict_one_way(sender);
            }

            1083620022582160398 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            1481114722667499972 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            6841797014773573215 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            1451514501977162287 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            3330693085881435529 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            8222960355260037542 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            225387363174180470 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            3066880266580913088 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            708169949929096689 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            2929398860738426482 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way(sender, responder);
            }

            8423663794424433896 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_fields(sender, responder);
            }

            8216450897182897849 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_union(sender, responder);
            }

            1049265954148894210 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_table(sender, responder);
            }

            5583489590753947170 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_err(sender, responder);
            }

            6033174601748665003 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_fields_err(sender, responder);
            }

            6235121653537390575 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_union_err(sender, responder);
            }

            940887795361350656 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayFieldsResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_response::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_strict_two_way_union_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_strict_two_way_union_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'buf>>
    for UnknownInteractionsProtocolStrictTwoWayTableResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayErrResponse {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayErrResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayErrResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayErrResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayErrResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayErrResult> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnknownInteractionsProtocolStrictTwoWayErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayErrResult>
    for UnknownInteractionsProtocolStrictTwoWayErrResult
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayErrResult>>
{
    fn take_from(from: &mut WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_strict_two_way_err_result::Ref::Response(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            2 => crate::unknown_interactions_protocol_strict_two_way_err_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_err_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_strict_two_way_err_result::Mut::Response(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            2 => crate::unknown_interactions_protocol_strict_two_way_err_result::Mut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnknownInteractionsProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictTwoWayErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResult> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResult
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_protocol_strict_two_way_fields_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_fields_err_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_protocol_strict_two_way_fields_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() },
                )
            }

            2 => crate::unknown_interactions_protocol_strict_two_way_fields_err_result::Mut::Err(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_err_response::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResult> {
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl<'buf> WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_protocol_strict_two_way_union_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_err_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_protocol_strict_two_way_union_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() },
                )
            }

            2 => crate::unknown_interactions_protocol_strict_two_way_union_err_result::Mut::Err(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableErrResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolStrictTwoWayTableErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayTableErrResult> {
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayTableErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayTableErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>),

        Err(&'union ::fidl_next::i32_le),
    }

    pub enum Mut<'union, 'buf> {
        Response(
            &'union mut crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>,
        ),

        Err(&'union mut ::fidl_next::i32_le),
    }
}

impl<'buf> WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_table_err_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_protocol_strict_two_way_table_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_table_err_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_protocol_strict_two_way_table_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() },
                )
            }

            2 => crate::unknown_interactions_protocol_strict_two_way_table_err_result::Mut::Err(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictTwoWayTableErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayResponse {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsProtocolFlexibleTwoWayResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleTwoWayResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolFlexibleTwoWayResponse: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayResult> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnknownInteractionsProtocolFlexibleTwoWayResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayResult>
    for UnknownInteractionsProtocolFlexibleTwoWayResult
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayResult>>
{
    fn take_from(from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_flexible_two_way_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayResult {
    pub fn as_ref(&self) -> crate::unknown_interactions_protocol_flexible_two_way_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_flexible_two_way_result::Ref::Response(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            3 => crate::unknown_interactions_protocol_flexible_two_way_result::Ref::FrameworkErr(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_flexible_two_way_result::Mut::Response(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            3 => crate::unknown_interactions_protocol_flexible_two_way_result::Mut::FrameworkErr(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayFieldsResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResult> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResult
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_flexible_two_way_fields_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_fields_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_fields_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_fields_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_fields_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_fields_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_fields_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_flexible_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_response::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_union_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayUnionResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResult> {
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_protocol_flexible_two_way_union_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl<'buf> WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_union_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_union_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_union_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_union_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayTableResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayTableResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayTableResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolFlexibleTwoWayTableResponse: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayTableResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayTableResult> {
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayTableResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayTableResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayTableResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_protocol_flexible_two_way_table_result {
    pub enum Ref<'union, 'buf> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union, 'buf> {
        Response(
            &'union mut crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>,
        ),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl<'buf> WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_table_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_table_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_table_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_table_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_table_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_table_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayTableResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'buf>,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayErrResponse {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayErrResponse> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayErrResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayErrResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayErrResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolFlexibleTwoWayErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayErrResult> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayErrResult>
    for UnknownInteractionsProtocolFlexibleTwoWayErrResult
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_flexible_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse),

        Err(&'union ::fidl_next::i32_le),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse),

        Err(&'union mut ::fidl_next::i32_le),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_flexible_two_way_err_result::Ref::Response(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            2 => {
                crate::unknown_interactions_protocol_flexible_two_way_err_result::Ref::Err(unsafe {
                    self.raw.get().deref_unchecked()
                })
            }

            3 => {
                crate::unknown_interactions_protocol_flexible_two_way_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_err_result::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_flexible_two_way_err_result::Mut::Response(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            2 => {
                crate::unknown_interactions_protocol_flexible_two_way_err_result::Mut::Err(unsafe {
                    self.raw.get_mut().deref_mut_unchecked()
                })
            }

            3 => {
                crate::unknown_interactions_protocol_flexible_two_way_err_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() },
                )
            }

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
{
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>
{
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_flexible_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::i32_le),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse),

        Err(&'union mut ::fidl_next::i32_le),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>()
                },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
{
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_flexible_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> {
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_protocol_flexible_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::i32_le),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union> {
        Response(&'union mut crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse),

        Err(&'union mut ::fidl_next::i32_le),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl<'buf> WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayTableErrResult
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse: ::fidl_next::Encode<___E>,

    i32: ::fidl_next::Encode<___E>,

    ::fidl_next::FrameworkError: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult { raw, _phantom: _ } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayTableErrResult> {
    type EncodedOption<'buf> =
        WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayTableErrResult>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResult
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf>
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayTableErrResult>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

pub mod unknown_interactions_protocol_flexible_two_way_table_err_result {
    pub enum Ref<'union, 'buf> {
        Response(
            &'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>,
        ),

        Err(&'union ::fidl_next::i32_le),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }

    pub enum Mut<'union, 'buf> {
        Response(
            &'union mut crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>,
        ),

        Err(&'union mut ::fidl_next::i32_le),

        FrameworkErr(&'union mut ::fidl_next::WireFrameworkError),
    }
}

impl<'buf> WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf> {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Ref<'_, 'buf> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                2 => crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Mut<'_, 'buf> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Mut::Response(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                2 => crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Mut::Err(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
                3 => crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Mut::FrameworkErr(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            
        }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'buf mut [::fidl_next::Chunk]>,
}

impl<'buf> WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(
        &mut self,
    ) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

unsafe impl<'buf, ___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>
where
    ___D: ::fidl_next::Decoder<'buf>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>:
        ::fidl_next::Decode<___D>,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,

    ::fidl_next::WireFrameworkError: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'buf>,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::i32_le>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventFieldsRequest {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventFieldsRequest
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictEventFieldsRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsProtocolStrictEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictEventFieldsRequest>
    for UnknownInteractionsProtocolStrictEventFieldsRequest
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventUnionRequest {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventUnionRequest { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictEventUnionRequest> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictEventUnionRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictEventUnionRequest>
    for UnknownInteractionsProtocolStrictEventUnionRequest
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest>
    for Option<Box<UnknownInteractionsProtocolStrictEventUnionRequest>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_strict_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_strict_event_union_request::Ref::SomeField(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            unknown => {
                crate::unknown_interactions_protocol_strict_event_union_request::Ref::UnknownOrdinal(
                    unknown,
                )
            }
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_strict_event_union_request::Mut<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_strict_event_union_request::Mut::SomeField(
                unsafe { self.raw.get_mut().deref_mut_unchecked() },
            ),

            unknown => {
                crate::unknown_interactions_protocol_strict_event_union_request::Mut::UnknownOrdinal(
                    unknown,
                )
            }
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictEventUnionRequest {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventTableRequest {
    type Encoded<'buf> = WireUnknownInteractionsProtocolStrictEventTableRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictEventTableRequest<'buf>>
    for UnknownInteractionsProtocolStrictEventTableRequest
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolStrictEventTableRequest<'buf>) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictEventTableRequest<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventTableRequest<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsProtocolStrictEventTableRequest<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictEventTableRequest<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleEventFieldsRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&mut from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleEventFieldsRequest {
    pub some_field: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventUnionRequest {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleEventUnionRequest> {
    type EncodedOption<'buf> = WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleEventUnionRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleEventUnionRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsProtocolFlexibleEventUnionRequest
{
    fn take_from(from: &mut WireUnknownInteractionsProtocolFlexibleEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for Option<Box<UnknownInteractionsProtocolFlexibleEventUnionRequest>>
{
    fn take_from(
        from: &mut WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

pub mod unknown_interactions_protocol_flexible_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }

    pub enum Mut<'union> {
        SomeField(&'union mut ::fidl_next::i32_le),

        UnknownOrdinal(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_event_union_request::Ref<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_flexible_event_union_request::Ref::UnknownOrdinal(unknown),
            
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> crate::unknown_interactions_protocol_flexible_event_union_request::Mut<'_> {
        match self.raw.ordinal() {
            
                1 => crate::unknown_interactions_protocol_flexible_event_union_request::Mut::SomeField(
                    unsafe { self.raw.get_mut().deref_mut_unchecked() }
                ),
            
            
                unknown => crate::unknown_interactions_protocol_flexible_event_union_request::Mut::UnknownOrdinal(unknown),
            
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::i32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(
        &mut self,
    ) -> Option<&mut WireUnknownInteractionsProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnknownInteractionsProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Default for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null(), _phantom: ::core::marker::PhantomData }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::null(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::i32_le>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D: ?Sized> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___D: fidl_next::decoder::InternalHandleDecoder,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::i32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventTableRequest {
    type Encoded<'buf> = WireUnknownInteractionsProtocolFlexibleEventTableRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,

    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleEventTableRequest<'buf>>
    for UnknownInteractionsProtocolFlexibleEventTableRequest
{
    fn take_from(
        from: &mut WireUnknownInteractionsProtocolFlexibleEventTableRequest<'buf>,
    ) -> Self {
        Self { some_field: from.some_field_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleEventTableRequest<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventTableRequest<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i32_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireUnknownInteractionsProtocolFlexibleEventTableRequest<'buf> {
    pub fn some_field(&self) -> Option<&::fidl_next::i32_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn some_field_mut(&mut self) -> Option<&mut ::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_some_field(&mut self) -> Option<::fidl_next::i32_le> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleEventTableRequest<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsProtocol;

pub mod unknown_interactions_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::bind::Method for StrictOneWay {
        const ORDINAL: u64 = 5652707722400962470;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::bind::Method for FlexibleOneWay {
        const ORDINAL: u64 = 583422011583300678;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ::fidl_next::bind::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::bind::Method for StrictTwoWay {
        const ORDINAL: u64 = 8308184097687583042;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::bind::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 3697260130745060067;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::bind::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 2455165891480464557;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::bind::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 8389853739594228663;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'buf>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::bind::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 7862264614495172967;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::bind::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 2414673307948662059;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::bind::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 4988571416540160202;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::bind::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 5487292735562672344;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>;
    }

    pub struct FlexibleTwoWay;

    impl ::fidl_next::bind::Method for FlexibleTwoWay {
        const ORDINAL: u64 = 334879577560091516;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolFlexibleTwoWayResult;
    }

    pub struct FlexibleTwoWayFields;

    impl ::fidl_next::bind::Method for FlexibleTwoWayFields {
        const ORDINAL: u64 = 4257018954691721778;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult;
    }

    pub struct FlexibleTwoWayUnion;

    impl ::fidl_next::bind::Method for FlexibleTwoWayUnion {
        const ORDINAL: u64 = 4913460516188409782;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>;
    }

    pub struct FlexibleTwoWayTable;

    impl ::fidl_next::bind::Method for FlexibleTwoWayTable {
        const ORDINAL: u64 = 9171907422498283911;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>;
    }

    pub struct FlexibleTwoWayErr;

    impl ::fidl_next::bind::Method for FlexibleTwoWayErr {
        const ORDINAL: u64 = 6999736795697216519;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResult;
    }

    pub struct FlexibleTwoWayFieldsErr;

    impl ::fidl_next::bind::Method for FlexibleTwoWayFieldsErr {
        const ORDINAL: u64 = 1093132337162001157;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> = crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult;
    }

    pub struct FlexibleTwoWayUnionErr;

    impl ::fidl_next::bind::Method for FlexibleTwoWayUnionErr {
        const ORDINAL: u64 = 2410151523245950935;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>;
    }

    pub struct FlexibleTwoWayTableErr;

    impl ::fidl_next::bind::Method for FlexibleTwoWayTableErr {
        const ORDINAL: u64 = 7893309626427980786;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ();

        type Response<'buf> =
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>;
    }

    pub struct StrictEvent;

    impl ::fidl_next::bind::Method for StrictEvent {
        const ORDINAL: u64 = 685715276307386305;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::bind::Method for StrictEventFields {
        const ORDINAL: u64 = 8896208255987935026;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::bind::Method for StrictEventUnion {
        const ORDINAL: u64 = 3919175221694221274;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::bind::Method for StrictEventTable {
        const ORDINAL: u64 = 2711448698318579984;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsProtocolStrictEventTableRequest<'buf>;
    }

    pub struct FlexibleEvent;

    impl ::fidl_next::bind::Method for FlexibleEvent {
        const ORDINAL: u64 = 7042257263728687206;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = ();
    }

    pub struct FlexibleEventFields;

    impl ::fidl_next::bind::Method for FlexibleEventFields {
        const ORDINAL: u64 = 3613822014516746241;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest;
    }

    pub struct FlexibleEventUnion;

    impl ::fidl_next::bind::Method for FlexibleEventUnion {
        const ORDINAL: u64 = 2499446536152409191;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest;
    }

    pub struct FlexibleEventTable;

    impl ::fidl_next::bind::Method for FlexibleEventTable {
        const ORDINAL: u64 = 5724881371349617120;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request<'buf> = ::fidl_next::bind::Never;

        type Response<'buf> = crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest<'buf>;
    }
}

/// A helper trait for the `UnknownInteractionsProtocol` client sender.
pub trait UnknownInteractionsProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, unknown_interactions_protocol::StrictTwoWay>,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, unknown_interactions_protocol::StrictTwoWayErr>,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, unknown_interactions_protocol::FlexibleTwoWay>,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(5652707722400962470, &mut ())
    }

    fn flexible_one_way(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(583422011583300678, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, unknown_interactions_protocol::StrictTwoWay>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8308184097687583042, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3697260130745060067, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2455165891480464557, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8389853739594228663, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, unknown_interactions_protocol::StrictTwoWayErr>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7862264614495172967, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2414673307948662059, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4988571416540160202, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5487292735562672344, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, unknown_interactions_protocol::FlexibleTwoWay>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(334879577560091516, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4257018954691721778, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4913460516188409782, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9171907422498283911, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6999736795697216519, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1093132337162001157, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2410151523245950935, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            unknown_interactions_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7893309626427980786, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsProtocol protocol.

pub trait UnknownInteractionsProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>,
    );

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::StrictEventFields,
        >,
    );

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::StrictEventUnion,
        >,
    );

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::StrictEventTable,
        >,
    );

    fn flexible_event(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>,
    );

    fn flexible_event_fields(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::FlexibleEventFields,
        >,
    );

    fn flexible_event_union(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::FlexibleEventUnion,
        >,
    );

    fn flexible_event_table(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::FlexibleEventTable,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, UnknownInteractionsProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for UnknownInteractionsProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsProtocolClientHandler<___T>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleTwoWayResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolStrictEventTableRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,

    for<'buf> crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest<'buf>:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::Decoder<'buf>>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            685715276307386305 => {
                handler.strict_event(sender);
            }

            8896208255987935026 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_fields(sender, buffer);
            }

            3919175221694221274 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_union(sender, buffer);
            }

            2711448698318579984 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_table(sender, buffer);
            }

            7042257263728687206 => {
                handler.flexible_event(sender);
            }

            3613822014516746241 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_fields(sender, buffer);
            }

            2499446536152409191 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_union(sender, buffer);
            }

            5724881371349617120 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_table(sender, buffer);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsProtocol` server sender.
pub trait UnknownInteractionsProtocolServerSender<___T: ::fidl_next::protocol::Transport> {
    fn strict_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn strict_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn flexible_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;
}

impl<___T> UnknownInteractionsProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn strict_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(685715276307386305, &mut ())
    }

    fn strict_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(8896208255987935026, &mut ())
    }

    fn strict_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(3919175221694221274, &mut ())
    }

    fn strict_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(2711448698318579984, &mut ())
    }

    fn flexible_event(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(7042257263728687206, &mut ())
    }

    fn flexible_event_fields(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(3613822014516746241, &mut ())
    }

    fn flexible_event_union(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(2499446536152409191, &mut ())
    }

    fn flexible_event_table(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(5724881371349617120, &mut ())
    }
}

/// A server handler for the UnknownInteractionsProtocol protocol.

pub trait UnknownInteractionsProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_protocol::StrictTwoWayFields>,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_protocol::StrictTwoWayUnion>,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_protocol::StrictTwoWayTable>,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_protocol::StrictTwoWayErr>,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_protocol::StrictTwoWayTableErr,
        >,
    );

    fn flexible_two_way(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_protocol::FlexibleTwoWay>,
    );

    fn flexible_two_way_fields(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_protocol::FlexibleTwoWayFields,
        >,
    );

    fn flexible_two_way_union(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_protocol::FlexibleTwoWayUnion>,
    );

    fn flexible_two_way_table(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_protocol::FlexibleTwoWayTable>,
    );

    fn flexible_two_way_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<unknown_interactions_protocol::FlexibleTwoWayErr>,
    );

    fn flexible_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_protocol::FlexibleTwoWayFieldsErr,
        >,
    );

    fn flexible_two_way_union_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_protocol::FlexibleTwoWayUnionErr,
        >,
    );

    fn flexible_two_way_table_err(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::bind::Responder<
            unknown_interactions_protocol::FlexibleTwoWayTableErr,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, UnknownInteractionsProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for UnknownInteractionsProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: UnknownInteractionsProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5652707722400962470 => {
                handler.strict_one_way(sender);
            }

            583422011583300678 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            8308184097687583042 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            3697260130745060067 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            2455165891480464557 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            8389853739594228663 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            7862264614495172967 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            2414673307948662059 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            4988571416540160202 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            5487292735562672344 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            334879577560091516 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way(sender, responder);
            }

            4257018954691721778 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_fields(sender, responder);
            }

            4913460516188409782 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_union(sender, responder);
            }

            9171907422498283911 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_table(sender, responder);
            }

            6999736795697216519 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_err(sender, responder);
            }

            1093132337162001157 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_fields_err(sender, responder);
            }

            2410151523245950935 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_union_err(sender, responder);
            }

            7893309626427980786 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.flexible_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}
