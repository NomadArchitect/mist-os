// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(
    unused_parens,
    unused_variables,
    unused_mut,
    unused_imports,
    unreachable_code,
    nonstandard_style
)]

pub type U32 = u32;
pub type WireU32 = ::fidl_next::u32_le;
pub type VecOfStrings = Vec<String>;
pub type WireVecOfStrings<'buf> = ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>;
pub type VecOfStringsAtMost5 = Vec<String>;
pub type WireVecOfStringsAtMost5<'buf> =
    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>;
pub type Referenceme = fidl_test_someotherlibrary::ReferenceMe;
pub type WireReferenceme = fidl_test_someotherlibrary::WireReferenceMe;
#[derive(Clone, Copy, Debug)]
#[repr(u32)]
pub enum obj_type {
    None = 0,
    Channel = 4,
}

impl ::fidl_next::Encodable for obj_type {
    type Encoded<'buf> = Wireobj_type;
}

impl<___E> ::fidl_next::Encode<___E> for obj_type
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let Wireobj_type { mut value } = slot);
        *value = ::fidl_next::u32_le::from(match *self {
            obj_type::None => 0,
            obj_type::Channel => 4,
        });

        Ok(())
    }
}

impl ::core::convert::From<Wireobj_type> for obj_type {
    fn from(wire: Wireobj_type) -> Self {
        match u32::from(wire.value) {
            0 => obj_type::None,
            4 => obj_type::Channel,
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<Wireobj_type> for obj_type {
    fn take_from(from: &mut Wireobj_type) -> Self {
        obj_type::from(*from)
    }
}

#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct Wireobj_type {
    value: ::fidl_next::u32_le,
}

impl Wireobj_type {
    pub const NONE: Wireobj_type = Wireobj_type { value: ::fidl_next::u32_le::from_native(0) };
    pub const CHANNEL: Wireobj_type = Wireobj_type { value: ::fidl_next::u32_le::from_native(4) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for Wireobj_type
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            0 | 4 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as usize)),
        }

        Ok(())
    }
}

impl ::core::convert::From<obj_type> for Wireobj_type {
    fn from(natural: obj_type) -> Self {
        match natural {
            obj_type::None => Wireobj_type::NONE,
            obj_type::Channel => Wireobj_type::CHANNEL,
        }
    }
}

pub type Channel = ::fidl_next::Handle;
pub type WireChannel = ::fidl_next::WireHandle;
pub type AliasOfChannel = ::fidl_next::Handle;
pub type WireAliasOfChannel = ::fidl_next::WireHandle;
#[derive(Debug)]
pub struct ExampleOfUseOfAliases {
    pub field_of_u32: u32,
    pub field_of_vec_of_strings: Vec<String>,
    pub field_of_vec_of_strings_at_most_nine: Vec<String>,
    pub field_of_vec_of_strings_at_most_5: Vec<String>,
    pub field_of_vec_of_ref_me_at_most_5: Vec<fidl_test_someotherlibrary::ReferenceMe>,
    pub field_of_channel: ::fidl_next::Handle,
    pub field_of_client_end: ::fidl_next::Handle,
    pub field_of_nullable_client_end: Option<::fidl_next::Handle>,
}

impl ::fidl_next::Encodable for ExampleOfUseOfAliases {
    type Encoded<'buf> = WireExampleOfUseOfAliases<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ExampleOfUseOfAliases
where
    u32: ::fidl_next::Encode<___E>,
    Vec<String>: ::fidl_next::Encode<___E>,
    Vec<String>: ::fidl_next::Encode<___E>,
    Vec<String>: ::fidl_next::Encode<___E>,
    Vec<fidl_test_someotherlibrary::ReferenceMe>: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    Option<::fidl_next::Handle>: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                field_of_u32,
                field_of_vec_of_strings,
                field_of_vec_of_strings_at_most_nine,
                field_of_vec_of_strings_at_most_5,
                field_of_vec_of_ref_me_at_most_5,
                field_of_channel,
                field_of_client_end,
                field_of_nullable_client_end,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.field_of_u32, encoder, field_of_u32)?;
        ::fidl_next::Encode::encode(
            &mut self.field_of_vec_of_strings,
            encoder,
            field_of_vec_of_strings,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.field_of_vec_of_strings_at_most_nine,
            encoder,
            field_of_vec_of_strings_at_most_nine,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.field_of_vec_of_strings_at_most_5,
            encoder,
            field_of_vec_of_strings_at_most_5,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.field_of_vec_of_ref_me_at_most_5,
            encoder,
            field_of_vec_of_ref_me_at_most_5,
        )?;
        ::fidl_next::Encode::encode(&mut self.field_of_channel, encoder, field_of_channel)?;
        ::fidl_next::Encode::encode(&mut self.field_of_client_end, encoder, field_of_client_end)?;
        ::fidl_next::Encode::encode(
            &mut self.field_of_nullable_client_end,
            encoder,
            field_of_nullable_client_end,
        )?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExampleOfUseOfAliases> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireExampleOfUseOfAliases<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExampleOfUseOfAliases>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ExampleOfUseOfAliases: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireExampleOfUseOfAliases<'buf>> for ExampleOfUseOfAliases {
    fn take_from(from: &mut WireExampleOfUseOfAliases<'buf>) -> Self {
        Self {
            field_of_u32: ::fidl_next::TakeFrom::take_from(&mut from.field_of_u32),
            field_of_vec_of_strings: ::fidl_next::TakeFrom::take_from(
                &mut from.field_of_vec_of_strings,
            ),
            field_of_vec_of_strings_at_most_nine: ::fidl_next::TakeFrom::take_from(
                &mut from.field_of_vec_of_strings_at_most_nine,
            ),
            field_of_vec_of_strings_at_most_5: ::fidl_next::TakeFrom::take_from(
                &mut from.field_of_vec_of_strings_at_most_5,
            ),
            field_of_vec_of_ref_me_at_most_5: ::fidl_next::TakeFrom::take_from(
                &mut from.field_of_vec_of_ref_me_at_most_5,
            ),
            field_of_channel: ::fidl_next::TakeFrom::take_from(&mut from.field_of_channel),
            field_of_client_end: ::fidl_next::TakeFrom::take_from(&mut from.field_of_client_end),
            field_of_nullable_client_end: ::fidl_next::TakeFrom::take_from(
                &mut from.field_of_nullable_client_end,
            ),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireExampleOfUseOfAliases<'buf> {
    pub field_of_u32: ::fidl_next::u32_le,
    pub field_of_vec_of_strings: ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
    pub field_of_vec_of_strings_at_most_nine:
        ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
    pub field_of_vec_of_strings_at_most_5:
        ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>,
    pub field_of_vec_of_ref_me_at_most_5:
        ::fidl_next::WireVector<'buf, fidl_test_someotherlibrary::WireReferenceMe>,
    pub field_of_channel: ::fidl_next::WireHandle,
    pub field_of_client_end: ::fidl_next::WireHandle,
    pub field_of_nullable_client_end: ::fidl_next::WireOptionalHandle,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireExampleOfUseOfAliases<'buf>
where
    ___D: ?Sized,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
    ::fidl_next::WireVector<'buf, ::fidl_next::WireString<'buf>>: ::fidl_next::Decode<___D>,
    ::fidl_next::WireVector<'buf, fidl_test_someotherlibrary::WireReferenceMe>:
        ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireOptionalHandle: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut field_of_u32,
                mut field_of_vec_of_strings,
                mut field_of_vec_of_strings_at_most_nine,
                mut field_of_vec_of_strings_at_most_5,
                mut field_of_vec_of_ref_me_at_most_5,
                mut field_of_channel,
                mut field_of_client_end,
                mut field_of_nullable_client_end,
            } = slot;
        }
        ::fidl_next::Decode::decode(field_of_u32.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(field_of_vec_of_strings.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(field_of_vec_of_strings_at_most_nine.as_mut(), decoder)?;
        let field_of_vec_of_strings_at_most_nine =
            unsafe { field_of_vec_of_strings_at_most_nine.deref_unchecked() };

        if field_of_vec_of_strings_at_most_nine.len() > 9 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: field_of_vec_of_strings_at_most_nine.len() as u64,
                limit: 9,
            });
        }

        ::fidl_next::Decode::decode(field_of_vec_of_strings_at_most_5.as_mut(), decoder)?;
        let field_of_vec_of_strings_at_most_5 =
            unsafe { field_of_vec_of_strings_at_most_5.deref_unchecked() };

        if field_of_vec_of_strings_at_most_5.len() > 5 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: field_of_vec_of_strings_at_most_5.len() as u64,
                limit: 5,
            });
        }

        ::fidl_next::Decode::decode(field_of_vec_of_ref_me_at_most_5.as_mut(), decoder)?;
        let field_of_vec_of_ref_me_at_most_5 =
            unsafe { field_of_vec_of_ref_me_at_most_5.deref_unchecked() };

        if field_of_vec_of_ref_me_at_most_5.len() > 5 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: field_of_vec_of_ref_me_at_most_5.len() as u64,
                limit: 5,
            });
        }

        ::fidl_next::Decode::decode(field_of_channel.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(field_of_client_end.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(field_of_nullable_client_end.as_mut(), decoder)?;
        Ok(())
    }
}
