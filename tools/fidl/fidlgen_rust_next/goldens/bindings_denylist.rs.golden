// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(
    unused_parens,
    unused_variables,
    unused_mut,
    unused_imports,
    unreachable_code,
    nonstandard_style
)]

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding4 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding4;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding4
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding4> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireShouldNeverAppearInAnyBinding4>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding4>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding4: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding4> for ShouldNeverAppearInAnyBinding4 {
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding4) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding4
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding5 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding5 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding5 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding5<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding5
where
    ___E: ::fidl_next::Encoder + ?Sized,

    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding5 { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope<'_>>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope<'_>>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl_next::WireEnvelope::encode_value(
                            a,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding5<'buf>>
    for ShouldNeverAppearInAnyBinding5
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding5<'buf>) -> Self {
        Self { a: from.a_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding5<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding5<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireShouldNeverAppearInAnyBinding5<'buf> {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn a_mut(&mut self) -> Option<&mut bool> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_a(&mut self) -> Option<bool> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding5<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding5").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]

pub enum ShouldNeverAppearInAnyBinding6 {
    A(bool),
    Unknown(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding6 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding6<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding6
where
    ___E: ::fidl_next::Encoder + ?Sized,

    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding6 { raw } = slot);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::Unknown(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding6> {
    type EncodedOption<'buf> = WireOptionalShouldNeverAppearInAnyBinding6<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding6>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding6: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding6 { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding6<'buf>>
    for ShouldNeverAppearInAnyBinding6
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding6<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding6<'buf>>
    for Option<Box<ShouldNeverAppearInAnyBinding6>>
{
    fn take_from(from: &mut WireOptionalShouldNeverAppearInAnyBinding6<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding6<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireShouldNeverAppearInAnyBinding6Ref<'buf> {
    A(&'buf bool),
    Unknown(u64),
}

pub enum WireShouldNeverAppearInAnyBinding6Mut<'buf> {
    A(&'buf mut bool),
    Unknown(u64),
}

impl WireShouldNeverAppearInAnyBinding6<'_> {
    pub fn as_ref(&self) -> WireShouldNeverAppearInAnyBinding6Ref<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding6Ref::A(unsafe {
                self.raw.get().deref_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding6Ref::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireShouldNeverAppearInAnyBinding6Mut<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding6Mut::A(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding6Mut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding6<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, bool>(raw, decoder)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding6<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding6<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalShouldNeverAppearInAnyBinding6<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding6<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireShouldNeverAppearInAnyBinding6<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireShouldNeverAppearInAnyBinding6<'buf>> {
        if self.is_some() {
            Some(WireShouldNeverAppearInAnyBinding6 {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalShouldNeverAppearInAnyBinding6<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalShouldNeverAppearInAnyBinding6<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding6<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct Allowed_Denied_Response {
    pub should_never_appear_in_any_binding_4: crate::ShouldNeverAppearInAnyBinding4,
    pub should_never_appear_in_any_binding_5: crate::ShouldNeverAppearInAnyBinding5,
    pub should_never_appear_in_any_binding_6: crate::ShouldNeverAppearInAnyBinding6,
}

impl ::fidl_next::Encodable for Allowed_Denied_Response {
    type Encoded<'buf> = WireAllowed_Denied_Response<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Allowed_Denied_Response
where
    crate::ShouldNeverAppearInAnyBinding4: ::fidl_next::Encode<___E>,
    crate::ShouldNeverAppearInAnyBinding5: ::fidl_next::Encode<___E>,
    crate::ShouldNeverAppearInAnyBinding6: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_4,
                should_never_appear_in_any_binding_5,
                should_never_appear_in_any_binding_6,
            } = slot;
        }
        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_4,
            encoder,
            should_never_appear_in_any_binding_4,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_5,
            encoder,
            should_never_appear_in_any_binding_5,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_6,
            encoder,
            should_never_appear_in_any_binding_6,
        )?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Allowed_Denied_Response> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireAllowed_Denied_Response<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Allowed_Denied_Response>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Allowed_Denied_Response: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireAllowed_Denied_Response<'buf>> for Allowed_Denied_Response {
    fn take_from(from: &mut WireAllowed_Denied_Response<'buf>) -> Self {
        Self {
            should_never_appear_in_any_binding_4: ::fidl_next::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_4,
            ),
            should_never_appear_in_any_binding_5: ::fidl_next::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_5,
            ),
            should_never_appear_in_any_binding_6: ::fidl_next::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_6,
            ),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireAllowed_Denied_Response<'buf> {
    pub should_never_appear_in_any_binding_4: crate::WireShouldNeverAppearInAnyBinding4,
    pub should_never_appear_in_any_binding_5: crate::WireShouldNeverAppearInAnyBinding5<'buf>,
    pub should_never_appear_in_any_binding_6: crate::WireShouldNeverAppearInAnyBinding6<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireAllowed_Denied_Response<'buf>
where
    ___D: ?Sized,

    crate::WireShouldNeverAppearInAnyBinding4: ::fidl_next::Decode<___D>,
    crate::WireShouldNeverAppearInAnyBinding5<'buf>: ::fidl_next::Decode<___D>,
    crate::WireShouldNeverAppearInAnyBinding6<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_4,
                mut should_never_appear_in_any_binding_5,
                mut should_never_appear_in_any_binding_6,
            } = slot;
        }
        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_4.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_5.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_6.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum Allowed_Denied_Result {
    Response(crate::Allowed_Denied_Response),
    Err(u32),
}

impl ::fidl_next::Encodable for Allowed_Denied_Result {
    type Encoded<'buf> = WireAllowed_Denied_Result<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for Allowed_Denied_Result
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::Allowed_Denied_Response: ::fidl_next::Encode<___E>,
    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireAllowed_Denied_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::Allowed_Denied_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Allowed_Denied_Result> {
    type EncodedOption<'buf> = WireOptionalAllowed_Denied_Result<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Allowed_Denied_Result>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Allowed_Denied_Result: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalAllowed_Denied_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireAllowed_Denied_Result<'buf>> for Allowed_Denied_Result {
    fn take_from(from: &mut WireAllowed_Denied_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalAllowed_Denied_Result<'buf>>
    for Option<Box<Allowed_Denied_Result>>
{
    fn take_from(from: &mut WireOptionalAllowed_Denied_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireAllowed_Denied_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireAllowed_Denied_ResultRef<'buf> {
    Response(&'buf crate::WireAllowed_Denied_Response<'buf>),
    Err(&'buf ::fidl_next::u32_le),
}

pub enum WireAllowed_Denied_ResultMut<'buf> {
    Response(&'buf mut crate::WireAllowed_Denied_Response<'buf>),
    Err(&'buf mut ::fidl_next::u32_le),
}

impl WireAllowed_Denied_Result<'_> {
    pub fn as_ref(&self) -> WireAllowed_Denied_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => {
                WireAllowed_Denied_ResultRef::Response(unsafe { self.raw.get().deref_unchecked() })
            }

            2 => WireAllowed_Denied_ResultRef::Err(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireAllowed_Denied_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireAllowed_Denied_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireAllowed_Denied_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireAllowed_Denied_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireAllowed_Denied_Response<'buf>: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireAllowed_Denied_Response<'buf>,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireAllowed_Denied_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireAllowed_Denied_Response<'buf>>().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalAllowed_Denied_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalAllowed_Denied_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireAllowed_Denied_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireAllowed_Denied_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireAllowed_Denied_Result<'buf>> {
        if self.is_some() {
            Some(WireAllowed_Denied_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalAllowed_Denied_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalAllowed_Denied_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireAllowed_Denied_Response<'buf>: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireAllowed_Denied_Response<'buf>,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalAllowed_Denied_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding1 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding1;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding1
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding1> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireShouldNeverAppearInAnyBinding1>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding1>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding1: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding1> for ShouldNeverAppearInAnyBinding1 {
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding1) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding1
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding2 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding2 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding2 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding2<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding2
where
    ___E: ::fidl_next::Encoder + ?Sized,

    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding2 { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope<'_>>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope<'_>>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl_next::WireEnvelope::encode_value(
                            a,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding2<'buf>>
    for ShouldNeverAppearInAnyBinding2
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding2<'buf>) -> Self {
        Self { a: from.a_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding2<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding2<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireShouldNeverAppearInAnyBinding2<'buf> {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn a_mut(&mut self) -> Option<&mut bool> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_a(&mut self) -> Option<bool> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding2<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding2").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]

pub enum ShouldNeverAppearInAnyBinding3 {
    A(bool),
    Unknown(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding3 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding3<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding3
where
    ___E: ::fidl_next::Encoder + ?Sized,

    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding3 { raw } = slot);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::Unknown(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding3> {
    type EncodedOption<'buf> = WireOptionalShouldNeverAppearInAnyBinding3<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding3>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding3: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding3 { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding3<'buf>>
    for ShouldNeverAppearInAnyBinding3
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding3<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding3<'buf>>
    for Option<Box<ShouldNeverAppearInAnyBinding3>>
{
    fn take_from(from: &mut WireOptionalShouldNeverAppearInAnyBinding3<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding3<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireShouldNeverAppearInAnyBinding3Ref<'buf> {
    A(&'buf bool),
    Unknown(u64),
}

pub enum WireShouldNeverAppearInAnyBinding3Mut<'buf> {
    A(&'buf mut bool),
    Unknown(u64),
}

impl WireShouldNeverAppearInAnyBinding3<'_> {
    pub fn as_ref(&self) -> WireShouldNeverAppearInAnyBinding3Ref<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding3Ref::A(unsafe {
                self.raw.get().deref_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding3Ref::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireShouldNeverAppearInAnyBinding3Mut<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding3Mut::A(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding3Mut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding3<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, bool>(raw, decoder)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding3<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding3<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalShouldNeverAppearInAnyBinding3<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding3<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireShouldNeverAppearInAnyBinding3<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireShouldNeverAppearInAnyBinding3<'buf>> {
        if self.is_some() {
            Some(WireShouldNeverAppearInAnyBinding3 {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalShouldNeverAppearInAnyBinding3<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalShouldNeverAppearInAnyBinding3<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding3<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedShouldNeverAppearInAnyBindingRequest {
    pub should_never_appear_in_any_binding_1: crate::ShouldNeverAppearInAnyBinding1,
    pub should_never_appear_in_any_binding_2: crate::ShouldNeverAppearInAnyBinding2,
    pub should_never_appear_in_any_binding_3: crate::ShouldNeverAppearInAnyBinding3,
}

impl ::fidl_next::Encodable for DeniedShouldNeverAppearInAnyBindingRequest {
    type Encoded<'buf> = WireDeniedShouldNeverAppearInAnyBindingRequest<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for DeniedShouldNeverAppearInAnyBindingRequest
where
    crate::ShouldNeverAppearInAnyBinding1: ::fidl_next::Encode<___E>,
    crate::ShouldNeverAppearInAnyBinding2: ::fidl_next::Encode<___E>,
    crate::ShouldNeverAppearInAnyBinding3: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_1,
                should_never_appear_in_any_binding_2,
                should_never_appear_in_any_binding_3,
            } = slot;
        }
        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_1,
            encoder,
            should_never_appear_in_any_binding_1,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_2,
            encoder,
            should_never_appear_in_any_binding_2,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_3,
            encoder,
            should_never_appear_in_any_binding_3,
        )?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DeniedShouldNeverAppearInAnyBindingRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireDeniedShouldNeverAppearInAnyBindingRequest<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DeniedShouldNeverAppearInAnyBindingRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedShouldNeverAppearInAnyBindingRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireDeniedShouldNeverAppearInAnyBindingRequest<'buf>>
    for DeniedShouldNeverAppearInAnyBindingRequest
{
    fn take_from(from: &mut WireDeniedShouldNeverAppearInAnyBindingRequest<'buf>) -> Self {
        Self {
            should_never_appear_in_any_binding_1: ::fidl_next::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_1,
            ),
            should_never_appear_in_any_binding_2: ::fidl_next::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_2,
            ),
            should_never_appear_in_any_binding_3: ::fidl_next::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_3,
            ),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedShouldNeverAppearInAnyBindingRequest<'buf> {
    pub should_never_appear_in_any_binding_1: crate::WireShouldNeverAppearInAnyBinding1,
    pub should_never_appear_in_any_binding_2: crate::WireShouldNeverAppearInAnyBinding2<'buf>,
    pub should_never_appear_in_any_binding_3: crate::WireShouldNeverAppearInAnyBinding3<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireDeniedShouldNeverAppearInAnyBindingRequest<'buf>
where
    ___D: ?Sized,

    crate::WireShouldNeverAppearInAnyBinding1: ::fidl_next::Decode<___D>,
    crate::WireShouldNeverAppearInAnyBinding2<'buf>: ::fidl_next::Decode<___D>,
    crate::WireShouldNeverAppearInAnyBinding3<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_1,
                mut should_never_appear_in_any_binding_2,
                mut should_never_appear_in_any_binding_3,
            } = slot;
        }
        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_1.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_2.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_3.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding7 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding7;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding7
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding7> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireShouldNeverAppearInAnyBinding7>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding7>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding7: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding7> for ShouldNeverAppearInAnyBinding7 {
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding7) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding7
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding8 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding8 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding8 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding8<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding8
where
    ___E: ::fidl_next::Encoder + ?Sized,

    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding8 { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope<'_>>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope<'_>>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl_next::WireEnvelope::encode_value(
                            a,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding8<'buf>>
    for ShouldNeverAppearInAnyBinding8
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding8<'buf>) -> Self {
        Self { a: from.a_mut().map(::fidl_next::TakeFrom::take_from) }
    }
}

#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding8<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding8<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireShouldNeverAppearInAnyBinding8<'buf> {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn a_mut(&mut self) -> Option<&mut bool> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_a(&mut self) -> Option<bool> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding8<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding8").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]

pub enum ShouldNeverAppearInAnyBinding9 {
    A(bool),
    Unknown(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding9 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding9<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding9
where
    ___E: ::fidl_next::Encoder + ?Sized,

    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding9 { raw } = slot);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::Unknown(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding9> {
    type EncodedOption<'buf> = WireOptionalShouldNeverAppearInAnyBinding9<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding9>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding9: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding9 { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding9<'buf>>
    for ShouldNeverAppearInAnyBinding9
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding9<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding9<'buf>>
    for Option<Box<ShouldNeverAppearInAnyBinding9>>
{
    fn take_from(from: &mut WireOptionalShouldNeverAppearInAnyBinding9<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding9<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireShouldNeverAppearInAnyBinding9Ref<'buf> {
    A(&'buf bool),
    Unknown(u64),
}

pub enum WireShouldNeverAppearInAnyBinding9Mut<'buf> {
    A(&'buf mut bool),
    Unknown(u64),
}

impl WireShouldNeverAppearInAnyBinding9<'_> {
    pub fn as_ref(&self) -> WireShouldNeverAppearInAnyBinding9Ref<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding9Ref::A(unsafe {
                self.raw.get().deref_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding9Ref::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireShouldNeverAppearInAnyBinding9Mut<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding9Mut::A(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding9Mut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding9<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, bool>(raw, decoder)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding9<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding9<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalShouldNeverAppearInAnyBinding9<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding9<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireShouldNeverAppearInAnyBinding9<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireShouldNeverAppearInAnyBinding9<'buf>> {
        if self.is_some() {
            Some(WireShouldNeverAppearInAnyBinding9 {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalShouldNeverAppearInAnyBinding9<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalShouldNeverAppearInAnyBinding9<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding9<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedAnonymous {
    pub should_never_appear_in_any_binding_7: crate::ShouldNeverAppearInAnyBinding7,
    pub should_never_appear_in_any_binding_8: crate::ShouldNeverAppearInAnyBinding8,
    pub should_never_appear_in_any_binding_9: crate::ShouldNeverAppearInAnyBinding9,
}

impl ::fidl_next::Encodable for DeniedAnonymous {
    type Encoded<'buf> = WireDeniedAnonymous<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for DeniedAnonymous
where
    crate::ShouldNeverAppearInAnyBinding7: ::fidl_next::Encode<___E>,
    crate::ShouldNeverAppearInAnyBinding8: ::fidl_next::Encode<___E>,
    crate::ShouldNeverAppearInAnyBinding9: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_7,
                should_never_appear_in_any_binding_8,
                should_never_appear_in_any_binding_9,
            } = slot;
        }
        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_7,
            encoder,
            should_never_appear_in_any_binding_7,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_8,
            encoder,
            should_never_appear_in_any_binding_8,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_9,
            encoder,
            should_never_appear_in_any_binding_9,
        )?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DeniedAnonymous> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireDeniedAnonymous<'buf>>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DeniedAnonymous>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedAnonymous: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireDeniedAnonymous<'buf>> for DeniedAnonymous {
    fn take_from(from: &mut WireDeniedAnonymous<'buf>) -> Self {
        Self {
            should_never_appear_in_any_binding_7: ::fidl_next::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_7,
            ),
            should_never_appear_in_any_binding_8: ::fidl_next::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_8,
            ),
            should_never_appear_in_any_binding_9: ::fidl_next::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_9,
            ),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedAnonymous<'buf> {
    pub should_never_appear_in_any_binding_7: crate::WireShouldNeverAppearInAnyBinding7,
    pub should_never_appear_in_any_binding_8: crate::WireShouldNeverAppearInAnyBinding8<'buf>,
    pub should_never_appear_in_any_binding_9: crate::WireShouldNeverAppearInAnyBinding9<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireDeniedAnonymous<'buf>
where
    ___D: ?Sized,

    crate::WireShouldNeverAppearInAnyBinding7: ::fidl_next::Decode<___D>,
    crate::WireShouldNeverAppearInAnyBinding8<'buf>: ::fidl_next::Decode<___D>,
    crate::WireShouldNeverAppearInAnyBinding9<'buf>: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_7,
                mut should_never_appear_in_any_binding_8,
                mut should_never_appear_in_any_binding_9,
            } = slot;
        }
        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_7.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_8.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_9.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyCppRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyCppRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyCppRequest
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyCppRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireDenyEachBindingOnlyDenyCppRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyCppRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyCppRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyCppRequest>
    for DenyEachBindingOnlyDenyCppRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyCppRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyCppRequest
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyCpp_Response {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyCpp_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyCpp_Response;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyCpp_Response
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyCpp_Response> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireDenyEachBinding_OnlyDenyCpp_Response>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyCpp_Response>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyCpp_Response: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyCpp_Response>
    for DenyEachBinding_OnlyDenyCpp_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyCpp_Response) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyCpp_Response {
    pub b: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenyCpp_Response
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyCpp_Result {
    Response(crate::DenyEachBinding_OnlyDenyCpp_Response),
    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyCpp_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyCpp_Result<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyCpp_Result
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::DenyEachBinding_OnlyDenyCpp_Response: ::fidl_next::Encode<___E>,
    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBinding_OnlyDenyCpp_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::DenyEachBinding_OnlyDenyCpp_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyCpp_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyCpp_Result>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyCpp_Result: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBinding_OnlyDenyCpp_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyCpp_Result<'buf>>
    for DenyEachBinding_OnlyDenyCpp_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyCpp_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyCpp_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyCpp_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyCpp_Response),
    Err(&'buf ::fidl_next::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyCpp_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyCpp_Response),
    Err(&'buf mut ::fidl_next::u32_le),
}

impl WireDenyEachBinding_OnlyDenyCpp_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyCpp_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyCpp_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyCpp_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyCpp_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyCpp_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyCpp_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenyCpp_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyCpp_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyCpp_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyCpp_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyCpp_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyCpp_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyCpp_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyCpp_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyCpp_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyCpp_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyDartRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyDartRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyDartRequest
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyDartRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireDenyEachBindingOnlyDenyDartRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyDartRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyDartRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyDartRequest>
    for DenyEachBindingOnlyDenyDartRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyDartRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyDartRequest
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyDart_Response {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyDart_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyDart_Response;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyDart_Response
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyDart_Response> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireDenyEachBinding_OnlyDenyDart_Response>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyDart_Response>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyDart_Response: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyDart_Response>
    for DenyEachBinding_OnlyDenyDart_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyDart_Response) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyDart_Response {
    pub b: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenyDart_Response
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyDart_Result {
    Response(crate::DenyEachBinding_OnlyDenyDart_Response),
    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyDart_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyDart_Result<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyDart_Result
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::DenyEachBinding_OnlyDenyDart_Response: ::fidl_next::Encode<___E>,
    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBinding_OnlyDenyDart_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::DenyEachBinding_OnlyDenyDart_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyDart_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyDart_Result>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyDart_Result: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBinding_OnlyDenyDart_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyDart_Result<'buf>>
    for DenyEachBinding_OnlyDenyDart_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyDart_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyDart_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyDart_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyDart_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyDart_Response),
    Err(&'buf ::fidl_next::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyDart_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyDart_Response),
    Err(&'buf mut ::fidl_next::u32_le),
}

impl WireDenyEachBinding_OnlyDenyDart_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyDart_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyDart_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyDart_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyDart_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyDart_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyDart_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenyDart_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyDart_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyDart_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyDart_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyDart_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyDart_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyDart_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyDart_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyDart_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyDart_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyDart_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyGoRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyGoRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyGoRequest
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyGoRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireDenyEachBindingOnlyDenyGoRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyGoRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyGoRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyGoRequest>
    for DenyEachBindingOnlyDenyGoRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyGoRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyGoRequest
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyGo_Response {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyGo_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyGo_Response;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyGo_Response
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyGo_Response> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireDenyEachBinding_OnlyDenyGo_Response>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyGo_Response>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyGo_Response: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyGo_Response>
    for DenyEachBinding_OnlyDenyGo_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyGo_Response) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyGo_Response {
    pub b: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenyGo_Response
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyGo_Result {
    Response(crate::DenyEachBinding_OnlyDenyGo_Response),
    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyGo_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyGo_Result<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyGo_Result
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::DenyEachBinding_OnlyDenyGo_Response: ::fidl_next::Encode<___E>,
    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBinding_OnlyDenyGo_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::DenyEachBinding_OnlyDenyGo_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyGo_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyGo_Result>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyGo_Result: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBinding_OnlyDenyGo_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyGo_Result<'buf>>
    for DenyEachBinding_OnlyDenyGo_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyGo_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyGo_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyGo_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyGo_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyGo_Response),
    Err(&'buf ::fidl_next::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyGo_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyGo_Response),
    Err(&'buf mut ::fidl_next::u32_le),
}

impl WireDenyEachBinding_OnlyDenyGo_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyGo_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyGo_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyGo_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyGo_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyGo_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyGo_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenyGo_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyGo_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyGo_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyGo_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyGo_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyGo_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyGo_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyGo_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyGo_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyGo_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyGo_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyLibfuzzerRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyLibfuzzerRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyLibfuzzerRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyLibfuzzerRequest
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyLibfuzzerRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireDenyEachBindingOnlyDenyLibfuzzerRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyLibfuzzerRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyLibfuzzerRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyLibfuzzerRequest>
    for DenyEachBindingOnlyDenyLibfuzzerRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyLibfuzzerRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyLibfuzzerRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyLibfuzzerRequest
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyLibfuzzer_Response {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyLibfuzzer_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyLibfuzzer_Response;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyLibfuzzer_Response
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyLibfuzzer_Response> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireDenyEachBinding_OnlyDenyLibfuzzer_Response>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyLibfuzzer_Response>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyLibfuzzer_Response: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyLibfuzzer_Response>
    for DenyEachBinding_OnlyDenyLibfuzzer_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyLibfuzzer_Response) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyLibfuzzer_Response {
    pub b: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenyLibfuzzer_Response
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyLibfuzzer_Result {
    Response(crate::DenyEachBinding_OnlyDenyLibfuzzer_Response),
    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyLibfuzzer_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyLibfuzzer_Result
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::DenyEachBinding_OnlyDenyLibfuzzer_Response: ::fidl_next::Encode<___E>,
    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBinding_OnlyDenyLibfuzzer_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::DenyEachBinding_OnlyDenyLibfuzzer_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyLibfuzzer_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyLibfuzzer_Result>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyLibfuzzer_Result: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>>
    for DenyEachBinding_OnlyDenyLibfuzzer_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyLibfuzzer_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyLibfuzzer_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response),
    Err(&'buf ::fidl_next::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyLibfuzzer_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response),
    Err(&'buf mut ::fidl_next::u32_le),
}

impl WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyLibfuzzer_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyLibfuzzer_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyLibfuzzer_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyLibfuzzer_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyLibfuzzer_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyLibfuzzer_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyLibfuzzer_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyRustRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyRustRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyRustRequest
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyRustRequest> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireDenyEachBindingOnlyDenyRustRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyRustRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyRustRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyRustRequest>
    for DenyEachBindingOnlyDenyRustRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyRustRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyRustRequest
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyRust_Response {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyRust_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyRust_Response;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyRust_Response
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyRust_Response> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireDenyEachBinding_OnlyDenyRust_Response>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyRust_Response>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyRust_Response: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyRust_Response>
    for DenyEachBinding_OnlyDenyRust_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyRust_Response) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyRust_Response {
    pub b: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenyRust_Response
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyRust_Result {
    Response(crate::DenyEachBinding_OnlyDenyRust_Response),
    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenyRust_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyRust_Result<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenyRust_Result
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::DenyEachBinding_OnlyDenyRust_Response: ::fidl_next::Encode<___E>,
    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBinding_OnlyDenyRust_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::DenyEachBinding_OnlyDenyRust_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenyRust_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenyRust_Result>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenyRust_Result: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBinding_OnlyDenyRust_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenyRust_Result<'buf>>
    for DenyEachBinding_OnlyDenyRust_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyRust_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyRust_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyRust_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyRust_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyRust_Response),
    Err(&'buf ::fidl_next::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyRust_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyRust_Response),
    Err(&'buf mut ::fidl_next::u32_le),
}

impl WireDenyEachBinding_OnlyDenyRust_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyRust_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyRust_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyRust_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyRust_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyRust_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyRust_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenyRust_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyRust_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyRust_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyRust_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyRust_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyRust_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyRust_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyRust_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyRust_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenyRust_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenyRust_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenySyzkallerRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenySyzkallerRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenySyzkallerRequest
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenySyzkallerRequest> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireDenyEachBindingOnlyDenySyzkallerRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenySyzkallerRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenySyzkallerRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenySyzkallerRequest>
    for DenyEachBindingOnlyDenySyzkallerRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenySyzkallerRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenySyzkallerRequest
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenySyzkaller_Response {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenySyzkaller_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenySyzkaller_Response;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenySyzkaller_Response
where
    i32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenySyzkaller_Response> {
    type EncodedOption<'buf> =
        ::fidl_next::WireBox<'buf, WireDenyEachBinding_OnlyDenySyzkaller_Response>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenySyzkaller_Response>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenySyzkaller_Response: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenySyzkaller_Response>
    for DenyEachBinding_OnlyDenySyzkaller_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenySyzkaller_Response) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenySyzkaller_Response {
    pub b: ::fidl_next::i32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBinding_OnlyDenySyzkaller_Response
where
    ___D: ?Sized,

    ::fidl_next::i32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenySyzkaller_Result {
    Response(crate::DenyEachBinding_OnlyDenySyzkaller_Response),
    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBinding_OnlyDenySyzkaller_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBinding_OnlyDenySyzkaller_Result
where
    ___E: ::fidl_next::Encoder + ?Sized,

    crate::DenyEachBinding_OnlyDenySyzkaller_Response: ::fidl_next::Encode<___E>,
    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBinding_OnlyDenySyzkaller_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::DenyEachBinding_OnlyDenySyzkaller_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBinding_OnlyDenySyzkaller_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBinding_OnlyDenySyzkaller_Result>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBinding_OnlyDenySyzkaller_Result: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>>
    for DenyEachBinding_OnlyDenySyzkaller_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenySyzkaller_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenySyzkaller_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenySyzkaller_Response),
    Err(&'buf ::fidl_next::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenySyzkaller_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenySyzkaller_Response),
    Err(&'buf mut ::fidl_next::u32_le),
}

impl WireDenyEachBinding_OnlyDenySyzkaller_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenySyzkaller_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenySyzkaller_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenySyzkaller_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenySyzkaller_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenySyzkaller_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenySyzkaller_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenySyzkaller_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenySyzkaller_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenySyzkaller_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenySyzkaller_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    crate::WireDenyEachBinding_OnlyDenySyzkaller_Response: ::fidl_next::Decode<___D>,
    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireDenyEachBinding_OnlyDenySyzkaller_Response,
            >(raw, decoder)?,
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct MemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

impl ::fidl_next::Encodable for MemberOnlyAppearsInImportingLibrary {
    type Encoded<'buf> = WireMemberOnlyAppearsInImportingLibrary;
}

impl<___E> ::fidl_next::Encode<___E> for MemberOnlyAppearsInImportingLibrary
where
    bool: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<MemberOnlyAppearsInImportingLibrary> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireMemberOnlyAppearsInImportingLibrary>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<MemberOnlyAppearsInImportingLibrary>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MemberOnlyAppearsInImportingLibrary: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireMemberOnlyAppearsInImportingLibrary>
    for MemberOnlyAppearsInImportingLibrary
{
    fn take_from(from: &mut WireMemberOnlyAppearsInImportingLibrary) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMemberOnlyAppearsInImportingLibrary
where
    ___D: ?Sized,

    bool: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct OnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::MemberOnlyAppearsInImportingLibrary,
}

impl ::fidl_next::Encodable for OnlyAppearsInImportingLibrary {
    type Encoded<'buf> = WireOnlyAppearsInImportingLibrary;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyAppearsInImportingLibrary
where
    crate::MemberOnlyAppearsInImportingLibrary: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                member_only_appears_in_importing_library,
            } = slot;
        }
        ::fidl_next::Encode::encode(
            &mut self.member_only_appears_in_importing_library,
            encoder,
            member_only_appears_in_importing_library,
        )?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OnlyAppearsInImportingLibrary> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireOnlyAppearsInImportingLibrary>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OnlyAppearsInImportingLibrary>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyAppearsInImportingLibrary: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyAppearsInImportingLibrary> for OnlyAppearsInImportingLibrary {
    fn take_from(from: &mut WireOnlyAppearsInImportingLibrary) -> Self {
        Self {
            member_only_appears_in_importing_library: ::fidl_next::TakeFrom::take_from(
                &mut from.member_only_appears_in_importing_library,
            ),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::WireMemberOnlyAppearsInImportingLibrary,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyAppearsInImportingLibrary
where
    ___D: ?Sized,

    crate::WireMemberOnlyAppearsInImportingLibrary: ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut member_only_appears_in_importing_library,
            } = slot;
        }
        ::fidl_next::Decode::decode(member_only_appears_in_importing_library.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Copy, Debug)]
#[repr(u32)]
pub enum OnlyDart {
    A = 1,
}

impl ::fidl_next::Encodable for OnlyDart {
    type Encoded<'buf> = WireOnlyDart;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyDart
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyDart { mut value } = slot);
        *value = ::fidl_next::u32_le::from(match *self {
            OnlyDart::A => 1,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireOnlyDart> for OnlyDart {
    fn from(wire: WireOnlyDart) -> Self {
        match u32::from(wire.value) {
            1 => OnlyDart::A,
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOnlyDart> for OnlyDart {
    fn take_from(from: &mut WireOnlyDart) -> Self {
        OnlyDart::from(*from)
    }
}

#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireOnlyDart {
    value: ::fidl_next::u32_le,
}

impl WireOnlyDart {
    pub const A: WireOnlyDart = WireOnlyDart { value: ::fidl_next::u32_le::from_native(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyDart
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as usize)),
        }

        Ok(())
    }
}

impl ::core::convert::From<OnlyDart> for WireOnlyDart {
    fn from(natural: OnlyDart) -> Self {
        match natural {
            OnlyDart::A => WireOnlyDart::A,
        }
    }
}

#[derive(Clone, Debug)]
pub struct OnlyGo {}

impl ::fidl_next::Encodable for OnlyGo {
    type Encoded<'buf> = WireOnlyGo;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyGo {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OnlyGo> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireOnlyGo>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OnlyGo>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyGo: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyGo> for OnlyGo {
    fn take_from(from: &mut WireOnlyGo) -> Self {
        Self {}
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyGo {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyGo
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum OnlyLlcpp {
    X(u32),
}

impl ::fidl_next::Encodable for OnlyLlcpp {
    type Encoded<'buf> = WireOnlyLlcpp<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyLlcpp
where
    ___E: ::fidl_next::Encoder + ?Sized,

    u32: ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyLlcpp { raw } = slot);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OnlyLlcpp> {
    type EncodedOption<'buf> = WireOptionalOnlyLlcpp<'buf>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OnlyLlcpp>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyLlcpp: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalOnlyLlcpp { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOnlyLlcpp<'buf>> for OnlyLlcpp {
    fn take_from(from: &mut WireOnlyLlcpp<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::X(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOptionalOnlyLlcpp<'buf>> for Option<Box<OnlyLlcpp>> {
    fn take_from(from: &mut WireOptionalOnlyLlcpp<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireOnlyLlcpp<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

pub enum WireOnlyLlcppRef<'buf> {
    X(&'buf ::fidl_next::u32_le),
}

pub enum WireOnlyLlcppMut<'buf> {
    X(&'buf mut ::fidl_next::u32_le),
}

impl WireOnlyLlcpp<'_> {
    pub fn as_ref(&self) -> WireOnlyLlcppRef<'_> {
        match self.raw.ordinal() {
            1 => WireOnlyLlcppRef::X(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireOnlyLlcppMut<'_> {
        match self.raw.ordinal() {
            1 => WireOnlyLlcppMut::X(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOnlyLlcpp<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOnlyLlcpp<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalOnlyLlcpp<'buf> {
    raw: ::fidl_next::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalOnlyLlcpp<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireOnlyLlcpp<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireOnlyLlcpp<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireOnlyLlcpp<'buf>> {
        if self.is_some() {
            Some(WireOnlyLlcpp {
                raw: ::core::mem::replace(&mut self.raw, ::fidl_next::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalOnlyLlcpp<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl_next::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalOnlyLlcpp<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,

    ::fidl_next::u32_le: ::fidl_next::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalOnlyLlcpp<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct OnlyRust {}

impl OnlyRust {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for OnlyRust {
    type Encoded<'buf> = WireOnlyRust<'buf>;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyRust
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyRust { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope<'_>>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope<'_>>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl_next::TakeFrom<WireOnlyRust<'buf>> for OnlyRust {
    fn take_from(from: &mut WireOnlyRust<'buf>) -> Self {
        Self {}
    }
}

#[repr(C)]
pub struct WireOnlyRust<'buf> {
    table: ::fidl_next::WireTable<'buf>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOnlyRust<'buf>
where
    ___D: ::fidl_next::Decoder<'buf> + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'buf> WireOnlyRust<'buf> {}

impl ::core::fmt::Debug for WireOnlyRust<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("OnlyRust").finish()
    }
}
