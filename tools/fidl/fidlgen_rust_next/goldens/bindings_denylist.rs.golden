// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(
    unused_parens,
    unused_variables,
    unused_mut,
    unused_imports,
    unreachable_code,
    nonstandard_style
)]

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

impl ::fidl::Encode for ShouldNeverAppearInAnyBinding4 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding4;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<ShouldNeverAppearInAnyBinding4> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireShouldNeverAppearInAnyBinding4>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireShouldNeverAppearInAnyBinding4> for ShouldNeverAppearInAnyBinding4 {
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding4) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireShouldNeverAppearInAnyBinding4 {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding5 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding5 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl::Encode for ShouldNeverAppearInAnyBinding5 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding5<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireShouldNeverAppearInAnyBinding5 { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl::WireEnvelope<'_>>::uninit();
        let mut preallocated = encoder.preallocate::<::fidl::WireEnvelope<'_>>(max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl::WireEnvelope::encode_value(a, preallocated.encoder, slot.as_mut())?;
                    } else {
                        ::fidl::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireShouldNeverAppearInAnyBinding5<'buf>>
    for ShouldNeverAppearInAnyBinding5
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding5<'buf>) -> Self {
        Self { a: from.a_mut().map(::fidl::TakeFrom::take_from) }
    }
}

#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding5<'buf> {
    table: ::fidl::WireTable<'buf>,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireShouldNeverAppearInAnyBinding5<'buf> {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { table } = slot);

        ::fidl::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| match ordinal {
            0 => unsafe { ::core::hint::unreachable_unchecked() },

            1 => {
                ::fidl::WireEnvelope::decode_as::<bool>(slot.as_mut(), decoder)?;

                Ok(())
            }

            _ => ::fidl::WireEnvelope::decode_unknown(slot, decoder),
        })
    }
}

impl<'buf> WireShouldNeverAppearInAnyBinding5<'buf> {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn a_mut(&mut self) -> Option<&mut bool> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_a(&mut self) -> Option<bool> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding5<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding5").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]

pub enum ShouldNeverAppearInAnyBinding6 {
    A(bool),
    Unknown(u64),
}

impl ::fidl::Encode for ShouldNeverAppearInAnyBinding6 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding6<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireShouldNeverAppearInAnyBinding6 { raw } = slot);

        match self {
            Self::A(value) => ::fidl::RawWireUnion::encode_as::<bool>(value, 1, encoder, raw)?,

            Self::Unknown(ordinal) => {
                return Err(::fidl::encode::Error::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<ShouldNeverAppearInAnyBinding6> {
    type EncodedOption<'buf> = WireOptionalShouldNeverAppearInAnyBinding6<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalShouldNeverAppearInAnyBinding6 { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireShouldNeverAppearInAnyBinding6<'buf>>
    for ShouldNeverAppearInAnyBinding6
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding6<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding6<'buf>>
    for Option<Box<ShouldNeverAppearInAnyBinding6>>
{
    fn take_from(from: &mut WireOptionalShouldNeverAppearInAnyBinding6<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding6<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireShouldNeverAppearInAnyBinding6Ref<'buf> {
    A(&'buf bool),
    Unknown(u64),
}

pub enum WireShouldNeverAppearInAnyBinding6Mut<'buf> {
    A(&'buf mut bool),
    Unknown(u64),
}

impl WireShouldNeverAppearInAnyBinding6<'_> {
    pub fn as_ref(&self) -> WireShouldNeverAppearInAnyBinding6Ref<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding6Ref::A(unsafe {
                self.raw.get().deref_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding6Ref::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireShouldNeverAppearInAnyBinding6Mut<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding6Mut::A(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding6Mut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireShouldNeverAppearInAnyBinding6<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<bool>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding6<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding6<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalShouldNeverAppearInAnyBinding6<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding6<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireShouldNeverAppearInAnyBinding6<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireShouldNeverAppearInAnyBinding6<'buf>> {
        if self.is_some() {
            Some(WireShouldNeverAppearInAnyBinding6 {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalShouldNeverAppearInAnyBinding6<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOptionalShouldNeverAppearInAnyBinding6<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<bool>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding6<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct Allowed_Denied_Response {
    pub should_never_appear_in_any_binding_4: crate::ShouldNeverAppearInAnyBinding4,
    pub should_never_appear_in_any_binding_5: crate::ShouldNeverAppearInAnyBinding5,
    pub should_never_appear_in_any_binding_6: crate::ShouldNeverAppearInAnyBinding6,
}

impl ::fidl::Encode for Allowed_Denied_Response {
    type Encoded<'buf> = WireAllowed_Denied_Response<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_4,
                should_never_appear_in_any_binding_5,
                should_never_appear_in_any_binding_6,
            } = slot;
        }
        ::fidl::Encode::encode(
            &mut self.should_never_appear_in_any_binding_4,
            encoder,
            should_never_appear_in_any_binding_4,
        )?;
        ::fidl::Encode::encode(
            &mut self.should_never_appear_in_any_binding_5,
            encoder,
            should_never_appear_in_any_binding_5,
        )?;
        ::fidl::Encode::encode(
            &mut self.should_never_appear_in_any_binding_6,
            encoder,
            should_never_appear_in_any_binding_6,
        )?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<Allowed_Denied_Response> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireAllowed_Denied_Response<'buf>>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireAllowed_Denied_Response<'buf>> for Allowed_Denied_Response {
    fn take_from(from: &mut WireAllowed_Denied_Response<'buf>) -> Self {
        Self {
            should_never_appear_in_any_binding_4: ::fidl::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_4,
            ),
            should_never_appear_in_any_binding_5: ::fidl::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_5,
            ),
            should_never_appear_in_any_binding_6: ::fidl::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_6,
            ),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireAllowed_Denied_Response<'buf> {
    pub should_never_appear_in_any_binding_4: crate::WireShouldNeverAppearInAnyBinding4,
    pub should_never_appear_in_any_binding_5: crate::WireShouldNeverAppearInAnyBinding5<'buf>,
    pub should_never_appear_in_any_binding_6: crate::WireShouldNeverAppearInAnyBinding6<'buf>,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireAllowed_Denied_Response<'buf> {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut should_never_appear_in_any_binding_4,
                mut should_never_appear_in_any_binding_5,
                mut should_never_appear_in_any_binding_6,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(should_never_appear_in_any_binding_4.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(should_never_appear_in_any_binding_5.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(should_never_appear_in_any_binding_6.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum Allowed_Denied_Result {
    Response(crate::Allowed_Denied_Response),
    Err(u32),
}

impl ::fidl::Encode for Allowed_Denied_Result {
    type Encoded<'buf> = WireAllowed_Denied_Result<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireAllowed_Denied_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl::RawWireUnion::encode_as::<
                crate::Allowed_Denied_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => ::fidl::RawWireUnion::encode_as::<u32>(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<Allowed_Denied_Result> {
    type EncodedOption<'buf> = WireOptionalAllowed_Denied_Result<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalAllowed_Denied_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireAllowed_Denied_Result<'buf>> for Allowed_Denied_Result {
    fn take_from(from: &mut WireAllowed_Denied_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalAllowed_Denied_Result<'buf>>
    for Option<Box<Allowed_Denied_Result>>
{
    fn take_from(from: &mut WireOptionalAllowed_Denied_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireAllowed_Denied_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireAllowed_Denied_ResultRef<'buf> {
    Response(&'buf crate::WireAllowed_Denied_Response<'buf>),
    Err(&'buf ::fidl::u32_le),
}

pub enum WireAllowed_Denied_ResultMut<'buf> {
    Response(&'buf mut crate::WireAllowed_Denied_Response<'buf>),
    Err(&'buf mut ::fidl::u32_le),
}

impl WireAllowed_Denied_Result<'_> {
    pub fn as_ref(&self) -> WireAllowed_Denied_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => {
                WireAllowed_Denied_ResultRef::Response(unsafe { self.raw.get().deref_unchecked() })
            }

            2 => WireAllowed_Denied_ResultRef::Err(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireAllowed_Denied_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireAllowed_Denied_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireAllowed_Denied_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireAllowed_Denied_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<crate::WireAllowed_Denied_Response<'buf>>(
                raw, decoder,
            )?,
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            ord => return Err(fidl::decode::Error::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireAllowed_Denied_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireAllowed_Denied_Response<'buf>>().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalAllowed_Denied_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalAllowed_Denied_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireAllowed_Denied_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireAllowed_Denied_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireAllowed_Denied_Result<'buf>> {
        if self.is_some() {
            Some(WireAllowed_Denied_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalAllowed_Denied_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOptionalAllowed_Denied_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<crate::WireAllowed_Denied_Response<'buf>>(
                raw, decoder,
            )?,
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalAllowed_Denied_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

impl ::fidl::Encode for ShouldNeverAppearInAnyBinding1 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding1;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<ShouldNeverAppearInAnyBinding1> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireShouldNeverAppearInAnyBinding1>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireShouldNeverAppearInAnyBinding1> for ShouldNeverAppearInAnyBinding1 {
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding1) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireShouldNeverAppearInAnyBinding1 {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding2 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding2 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl::Encode for ShouldNeverAppearInAnyBinding2 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding2<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireShouldNeverAppearInAnyBinding2 { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl::WireEnvelope<'_>>::uninit();
        let mut preallocated = encoder.preallocate::<::fidl::WireEnvelope<'_>>(max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl::WireEnvelope::encode_value(a, preallocated.encoder, slot.as_mut())?;
                    } else {
                        ::fidl::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireShouldNeverAppearInAnyBinding2<'buf>>
    for ShouldNeverAppearInAnyBinding2
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding2<'buf>) -> Self {
        Self { a: from.a_mut().map(::fidl::TakeFrom::take_from) }
    }
}

#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding2<'buf> {
    table: ::fidl::WireTable<'buf>,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireShouldNeverAppearInAnyBinding2<'buf> {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { table } = slot);

        ::fidl::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| match ordinal {
            0 => unsafe { ::core::hint::unreachable_unchecked() },

            1 => {
                ::fidl::WireEnvelope::decode_as::<bool>(slot.as_mut(), decoder)?;

                Ok(())
            }

            _ => ::fidl::WireEnvelope::decode_unknown(slot, decoder),
        })
    }
}

impl<'buf> WireShouldNeverAppearInAnyBinding2<'buf> {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn a_mut(&mut self) -> Option<&mut bool> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_a(&mut self) -> Option<bool> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding2<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding2").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]

pub enum ShouldNeverAppearInAnyBinding3 {
    A(bool),
    Unknown(u64),
}

impl ::fidl::Encode for ShouldNeverAppearInAnyBinding3 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding3<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireShouldNeverAppearInAnyBinding3 { raw } = slot);

        match self {
            Self::A(value) => ::fidl::RawWireUnion::encode_as::<bool>(value, 1, encoder, raw)?,

            Self::Unknown(ordinal) => {
                return Err(::fidl::encode::Error::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<ShouldNeverAppearInAnyBinding3> {
    type EncodedOption<'buf> = WireOptionalShouldNeverAppearInAnyBinding3<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalShouldNeverAppearInAnyBinding3 { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireShouldNeverAppearInAnyBinding3<'buf>>
    for ShouldNeverAppearInAnyBinding3
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding3<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding3<'buf>>
    for Option<Box<ShouldNeverAppearInAnyBinding3>>
{
    fn take_from(from: &mut WireOptionalShouldNeverAppearInAnyBinding3<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding3<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireShouldNeverAppearInAnyBinding3Ref<'buf> {
    A(&'buf bool),
    Unknown(u64),
}

pub enum WireShouldNeverAppearInAnyBinding3Mut<'buf> {
    A(&'buf mut bool),
    Unknown(u64),
}

impl WireShouldNeverAppearInAnyBinding3<'_> {
    pub fn as_ref(&self) -> WireShouldNeverAppearInAnyBinding3Ref<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding3Ref::A(unsafe {
                self.raw.get().deref_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding3Ref::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireShouldNeverAppearInAnyBinding3Mut<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding3Mut::A(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding3Mut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireShouldNeverAppearInAnyBinding3<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<bool>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding3<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding3<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalShouldNeverAppearInAnyBinding3<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding3<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireShouldNeverAppearInAnyBinding3<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireShouldNeverAppearInAnyBinding3<'buf>> {
        if self.is_some() {
            Some(WireShouldNeverAppearInAnyBinding3 {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalShouldNeverAppearInAnyBinding3<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOptionalShouldNeverAppearInAnyBinding3<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<bool>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding3<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedShouldNeverAppearInAnyBindingRequest {
    pub should_never_appear_in_any_binding_1: crate::ShouldNeverAppearInAnyBinding1,
    pub should_never_appear_in_any_binding_2: crate::ShouldNeverAppearInAnyBinding2,
    pub should_never_appear_in_any_binding_3: crate::ShouldNeverAppearInAnyBinding3,
}

impl ::fidl::Encode for DeniedShouldNeverAppearInAnyBindingRequest {
    type Encoded<'buf> = WireDeniedShouldNeverAppearInAnyBindingRequest<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_1,
                should_never_appear_in_any_binding_2,
                should_never_appear_in_any_binding_3,
            } = slot;
        }
        ::fidl::Encode::encode(
            &mut self.should_never_appear_in_any_binding_1,
            encoder,
            should_never_appear_in_any_binding_1,
        )?;
        ::fidl::Encode::encode(
            &mut self.should_never_appear_in_any_binding_2,
            encoder,
            should_never_appear_in_any_binding_2,
        )?;
        ::fidl::Encode::encode(
            &mut self.should_never_appear_in_any_binding_3,
            encoder,
            should_never_appear_in_any_binding_3,
        )?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DeniedShouldNeverAppearInAnyBindingRequest> {
    type EncodedOption<'buf> =
        ::fidl::WireBox<'buf, WireDeniedShouldNeverAppearInAnyBindingRequest<'buf>>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireDeniedShouldNeverAppearInAnyBindingRequest<'buf>>
    for DeniedShouldNeverAppearInAnyBindingRequest
{
    fn take_from(from: &mut WireDeniedShouldNeverAppearInAnyBindingRequest<'buf>) -> Self {
        Self {
            should_never_appear_in_any_binding_1: ::fidl::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_1,
            ),
            should_never_appear_in_any_binding_2: ::fidl::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_2,
            ),
            should_never_appear_in_any_binding_3: ::fidl::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_3,
            ),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedShouldNeverAppearInAnyBindingRequest<'buf> {
    pub should_never_appear_in_any_binding_1: crate::WireShouldNeverAppearInAnyBinding1,
    pub should_never_appear_in_any_binding_2: crate::WireShouldNeverAppearInAnyBinding2<'buf>,
    pub should_never_appear_in_any_binding_3: crate::WireShouldNeverAppearInAnyBinding3<'buf>,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDeniedShouldNeverAppearInAnyBindingRequest<'buf> {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut should_never_appear_in_any_binding_1,
                mut should_never_appear_in_any_binding_2,
                mut should_never_appear_in_any_binding_3,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(should_never_appear_in_any_binding_1.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(should_never_appear_in_any_binding_2.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(should_never_appear_in_any_binding_3.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

impl ::fidl::Encode for ShouldNeverAppearInAnyBinding7 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding7;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<ShouldNeverAppearInAnyBinding7> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireShouldNeverAppearInAnyBinding7>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireShouldNeverAppearInAnyBinding7> for ShouldNeverAppearInAnyBinding7 {
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding7) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireShouldNeverAppearInAnyBinding7 {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding8 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding8 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl::Encode for ShouldNeverAppearInAnyBinding8 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding8<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireShouldNeverAppearInAnyBinding8 { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl::WireEnvelope<'_>>::uninit();
        let mut preallocated = encoder.preallocate::<::fidl::WireEnvelope<'_>>(max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl::WireEnvelope::encode_value(a, preallocated.encoder, slot.as_mut())?;
                    } else {
                        ::fidl::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireShouldNeverAppearInAnyBinding8<'buf>>
    for ShouldNeverAppearInAnyBinding8
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding8<'buf>) -> Self {
        Self { a: from.a_mut().map(::fidl::TakeFrom::take_from) }
    }
}

#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding8<'buf> {
    table: ::fidl::WireTable<'buf>,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireShouldNeverAppearInAnyBinding8<'buf> {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { table } = slot);

        ::fidl::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| match ordinal {
            0 => unsafe { ::core::hint::unreachable_unchecked() },

            1 => {
                ::fidl::WireEnvelope::decode_as::<bool>(slot.as_mut(), decoder)?;

                Ok(())
            }

            _ => ::fidl::WireEnvelope::decode_unknown(slot, decoder),
        })
    }
}

impl<'buf> WireShouldNeverAppearInAnyBinding8<'buf> {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn a_mut(&mut self) -> Option<&mut bool> {
        unsafe { Some(self.table.get_mut(1)?.deref_mut_unchecked()) }
    }

    pub fn take_a(&mut self) -> Option<bool> {
        unsafe { Some(self.table.get_mut(1)?.take_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding8<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding8").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]

pub enum ShouldNeverAppearInAnyBinding9 {
    A(bool),
    Unknown(u64),
}

impl ::fidl::Encode for ShouldNeverAppearInAnyBinding9 {
    type Encoded<'buf> = WireShouldNeverAppearInAnyBinding9<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireShouldNeverAppearInAnyBinding9 { raw } = slot);

        match self {
            Self::A(value) => ::fidl::RawWireUnion::encode_as::<bool>(value, 1, encoder, raw)?,

            Self::Unknown(ordinal) => {
                return Err(::fidl::encode::Error::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<ShouldNeverAppearInAnyBinding9> {
    type EncodedOption<'buf> = WireOptionalShouldNeverAppearInAnyBinding9<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalShouldNeverAppearInAnyBinding9 { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireShouldNeverAppearInAnyBinding9<'buf>>
    for ShouldNeverAppearInAnyBinding9
{
    fn take_from(from: &mut WireShouldNeverAppearInAnyBinding9<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding9<'buf>>
    for Option<Box<ShouldNeverAppearInAnyBinding9>>
{
    fn take_from(from: &mut WireOptionalShouldNeverAppearInAnyBinding9<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding9<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireShouldNeverAppearInAnyBinding9Ref<'buf> {
    A(&'buf bool),
    Unknown(u64),
}

pub enum WireShouldNeverAppearInAnyBinding9Mut<'buf> {
    A(&'buf mut bool),
    Unknown(u64),
}

impl WireShouldNeverAppearInAnyBinding9<'_> {
    pub fn as_ref(&self) -> WireShouldNeverAppearInAnyBinding9Ref<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding9Ref::A(unsafe {
                self.raw.get().deref_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding9Ref::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireShouldNeverAppearInAnyBinding9Mut<'_> {
        match self.raw.ordinal() {
            1 => WireShouldNeverAppearInAnyBinding9Mut::A(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            unknown => WireShouldNeverAppearInAnyBinding9Mut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireShouldNeverAppearInAnyBinding9<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<bool>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding9<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding9<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalShouldNeverAppearInAnyBinding9<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding9<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireShouldNeverAppearInAnyBinding9<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireShouldNeverAppearInAnyBinding9<'buf>> {
        if self.is_some() {
            Some(WireShouldNeverAppearInAnyBinding9 {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalShouldNeverAppearInAnyBinding9<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOptionalShouldNeverAppearInAnyBinding9<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<bool>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding9<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedAnonymous {
    pub should_never_appear_in_any_binding_7: crate::ShouldNeverAppearInAnyBinding7,
    pub should_never_appear_in_any_binding_8: crate::ShouldNeverAppearInAnyBinding8,
    pub should_never_appear_in_any_binding_9: crate::ShouldNeverAppearInAnyBinding9,
}

impl ::fidl::Encode for DeniedAnonymous {
    type Encoded<'buf> = WireDeniedAnonymous<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_7,
                should_never_appear_in_any_binding_8,
                should_never_appear_in_any_binding_9,
            } = slot;
        }
        ::fidl::Encode::encode(
            &mut self.should_never_appear_in_any_binding_7,
            encoder,
            should_never_appear_in_any_binding_7,
        )?;
        ::fidl::Encode::encode(
            &mut self.should_never_appear_in_any_binding_8,
            encoder,
            should_never_appear_in_any_binding_8,
        )?;
        ::fidl::Encode::encode(
            &mut self.should_never_appear_in_any_binding_9,
            encoder,
            should_never_appear_in_any_binding_9,
        )?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DeniedAnonymous> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDeniedAnonymous<'buf>>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireDeniedAnonymous<'buf>> for DeniedAnonymous {
    fn take_from(from: &mut WireDeniedAnonymous<'buf>) -> Self {
        Self {
            should_never_appear_in_any_binding_7: ::fidl::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_7,
            ),
            should_never_appear_in_any_binding_8: ::fidl::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_8,
            ),
            should_never_appear_in_any_binding_9: ::fidl::TakeFrom::take_from(
                &mut from.should_never_appear_in_any_binding_9,
            ),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedAnonymous<'buf> {
    pub should_never_appear_in_any_binding_7: crate::WireShouldNeverAppearInAnyBinding7,
    pub should_never_appear_in_any_binding_8: crate::WireShouldNeverAppearInAnyBinding8<'buf>,
    pub should_never_appear_in_any_binding_9: crate::WireShouldNeverAppearInAnyBinding9<'buf>,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDeniedAnonymous<'buf> {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut should_never_appear_in_any_binding_7,
                mut should_never_appear_in_any_binding_8,
                mut should_never_appear_in_any_binding_9,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(should_never_appear_in_any_binding_7.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(should_never_appear_in_any_binding_8.as_mut(), decoder)?;
        ::fidl::Decode::<'buf>::decode(should_never_appear_in_any_binding_9.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

impl ::fidl::Encode for DenyEachBindingOnlyDenyCppRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyCppRequest;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBindingOnlyDenyCppRequest> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBindingOnlyDenyCppRequest>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBindingOnlyDenyCppRequest> for DenyEachBindingOnlyDenyCppRequest {
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyCppRequest) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBindingOnlyDenyCppRequest {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyCpp_Response {
    pub b: i32,
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyCpp_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyCpp_Response;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBinding_OnlyDenyCpp_Response> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBinding_OnlyDenyCpp_Response>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyCpp_Response>
    for DenyEachBinding_OnlyDenyCpp_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyCpp_Response) -> Self {
        Self { b: ::fidl::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyCpp_Response {
    pub b: ::fidl::i32_le,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyCpp_Response {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyCpp_Result {
    Response(crate::DenyEachBinding_OnlyDenyCpp_Response),
    Err(u32),
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyCpp_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyCpp_Result<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireDenyEachBinding_OnlyDenyCpp_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl::RawWireUnion::encode_as::<
                crate::DenyEachBinding_OnlyDenyCpp_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => ::fidl::RawWireUnion::encode_as::<u32>(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<DenyEachBinding_OnlyDenyCpp_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalDenyEachBinding_OnlyDenyCpp_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyCpp_Result<'buf>>
    for DenyEachBinding_OnlyDenyCpp_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyCpp_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyCpp_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyCpp_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyCpp_Response),
    Err(&'buf ::fidl::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyCpp_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyCpp_Response),
    Err(&'buf mut ::fidl::u32_le),
}

impl WireDenyEachBinding_OnlyDenyCpp_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyCpp_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyCpp_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyCpp_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyCpp_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyCpp_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyCpp_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl::RawWireUnion::decode_as::<crate::WireDenyEachBinding_OnlyDenyCpp_Response>(
                    raw, decoder,
                )?
            }
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            ord => return Err(fidl::decode::Error::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyCpp_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyCpp_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyCpp_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyCpp_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyCpp_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl::RawWireUnion::decode_as::<crate::WireDenyEachBinding_OnlyDenyCpp_Response>(
                    raw, decoder,
                )?
            }
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyCpp_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

impl ::fidl::Encode for DenyEachBindingOnlyDenyDartRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyDartRequest;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBindingOnlyDenyDartRequest> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBindingOnlyDenyDartRequest>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBindingOnlyDenyDartRequest>
    for DenyEachBindingOnlyDenyDartRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyDartRequest) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBindingOnlyDenyDartRequest {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyDart_Response {
    pub b: i32,
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyDart_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyDart_Response;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBinding_OnlyDenyDart_Response> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBinding_OnlyDenyDart_Response>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyDart_Response>
    for DenyEachBinding_OnlyDenyDart_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyDart_Response) -> Self {
        Self { b: ::fidl::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyDart_Response {
    pub b: ::fidl::i32_le,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyDart_Response {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyDart_Result {
    Response(crate::DenyEachBinding_OnlyDenyDart_Response),
    Err(u32),
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyDart_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyDart_Result<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireDenyEachBinding_OnlyDenyDart_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl::RawWireUnion::encode_as::<
                crate::DenyEachBinding_OnlyDenyDart_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => ::fidl::RawWireUnion::encode_as::<u32>(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<DenyEachBinding_OnlyDenyDart_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalDenyEachBinding_OnlyDenyDart_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyDart_Result<'buf>>
    for DenyEachBinding_OnlyDenyDart_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyDart_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyDart_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyDart_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyDart_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyDart_Response),
    Err(&'buf ::fidl::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyDart_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyDart_Response),
    Err(&'buf mut ::fidl::u32_le),
}

impl WireDenyEachBinding_OnlyDenyDart_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyDart_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyDart_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyDart_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyDart_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyDart_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyDart_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyDart_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl::RawWireUnion::decode_as::<crate::WireDenyEachBinding_OnlyDenyDart_Response>(
                    raw, decoder,
                )?
            }
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            ord => return Err(fidl::decode::Error::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyDart_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyDart_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyDart_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyDart_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyDart_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyDart_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl::RawWireUnion::decode_as::<crate::WireDenyEachBinding_OnlyDenyDart_Response>(
                    raw, decoder,
                )?
            }
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyDart_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

impl ::fidl::Encode for DenyEachBindingOnlyDenyGoRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyGoRequest;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBindingOnlyDenyGoRequest> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBindingOnlyDenyGoRequest>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBindingOnlyDenyGoRequest> for DenyEachBindingOnlyDenyGoRequest {
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyGoRequest) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBindingOnlyDenyGoRequest {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyGo_Response {
    pub b: i32,
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyGo_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyGo_Response;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBinding_OnlyDenyGo_Response> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBinding_OnlyDenyGo_Response>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyGo_Response>
    for DenyEachBinding_OnlyDenyGo_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyGo_Response) -> Self {
        Self { b: ::fidl::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyGo_Response {
    pub b: ::fidl::i32_le,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyGo_Response {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyGo_Result {
    Response(crate::DenyEachBinding_OnlyDenyGo_Response),
    Err(u32),
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyGo_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyGo_Result<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireDenyEachBinding_OnlyDenyGo_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl::RawWireUnion::encode_as::<
                crate::DenyEachBinding_OnlyDenyGo_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => ::fidl::RawWireUnion::encode_as::<u32>(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<DenyEachBinding_OnlyDenyGo_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalDenyEachBinding_OnlyDenyGo_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyGo_Result<'buf>>
    for DenyEachBinding_OnlyDenyGo_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyGo_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyGo_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyGo_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyGo_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyGo_Response),
    Err(&'buf ::fidl::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyGo_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyGo_Response),
    Err(&'buf mut ::fidl::u32_le),
}

impl WireDenyEachBinding_OnlyDenyGo_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyGo_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyGo_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyGo_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyGo_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyGo_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyGo_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyGo_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<crate::WireDenyEachBinding_OnlyDenyGo_Response>(
                raw, decoder,
            )?,
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            ord => return Err(fidl::decode::Error::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyGo_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyGo_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyGo_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyGo_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyGo_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyGo_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<crate::WireDenyEachBinding_OnlyDenyGo_Response>(
                raw, decoder,
            )?,
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyGo_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyLibfuzzerRequest {
    pub a: bool,
}

impl ::fidl::Encode for DenyEachBindingOnlyDenyLibfuzzerRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyLibfuzzerRequest;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBindingOnlyDenyLibfuzzerRequest> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBindingOnlyDenyLibfuzzerRequest>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBindingOnlyDenyLibfuzzerRequest>
    for DenyEachBindingOnlyDenyLibfuzzerRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyLibfuzzerRequest) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyLibfuzzerRequest {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBindingOnlyDenyLibfuzzerRequest {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyLibfuzzer_Response {
    pub b: i32,
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyLibfuzzer_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyLibfuzzer_Response;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBinding_OnlyDenyLibfuzzer_Response> {
    type EncodedOption<'buf> =
        ::fidl::WireBox<'buf, WireDenyEachBinding_OnlyDenyLibfuzzer_Response>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyLibfuzzer_Response>
    for DenyEachBinding_OnlyDenyLibfuzzer_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyLibfuzzer_Response) -> Self {
        Self { b: ::fidl::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyLibfuzzer_Response {
    pub b: ::fidl::i32_le,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyLibfuzzer_Response {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyLibfuzzer_Result {
    Response(crate::DenyEachBinding_OnlyDenyLibfuzzer_Response),
    Err(u32),
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyLibfuzzer_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireDenyEachBinding_OnlyDenyLibfuzzer_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl::RawWireUnion::encode_as::<
                crate::DenyEachBinding_OnlyDenyLibfuzzer_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => ::fidl::RawWireUnion::encode_as::<u32>(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<DenyEachBinding_OnlyDenyLibfuzzer_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>>
    for DenyEachBinding_OnlyDenyLibfuzzer_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyLibfuzzer_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyLibfuzzer_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response),
    Err(&'buf ::fidl::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyLibfuzzer_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response),
    Err(&'buf mut ::fidl::u32_le),
}

impl WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyLibfuzzer_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyLibfuzzer_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyLibfuzzer_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyLibfuzzer_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyLibfuzzer_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyLibfuzzer_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<
                crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response,
            >(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            ord => return Err(fidl::decode::Error::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyLibfuzzer_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf>
    for WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf>
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<
                crate::WireDenyEachBinding_OnlyDenyLibfuzzer_Response,
            >(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyLibfuzzer_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

impl ::fidl::Encode for DenyEachBindingOnlyDenyRustRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenyRustRequest;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBindingOnlyDenyRustRequest> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBindingOnlyDenyRustRequest>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBindingOnlyDenyRustRequest>
    for DenyEachBindingOnlyDenyRustRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenyRustRequest) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBindingOnlyDenyRustRequest {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenyRust_Response {
    pub b: i32,
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyRust_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyRust_Response;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBinding_OnlyDenyRust_Response> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBinding_OnlyDenyRust_Response>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyRust_Response>
    for DenyEachBinding_OnlyDenyRust_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyRust_Response) -> Self {
        Self { b: ::fidl::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenyRust_Response {
    pub b: ::fidl::i32_le,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyRust_Response {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenyRust_Result {
    Response(crate::DenyEachBinding_OnlyDenyRust_Response),
    Err(u32),
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenyRust_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenyRust_Result<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireDenyEachBinding_OnlyDenyRust_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl::RawWireUnion::encode_as::<
                crate::DenyEachBinding_OnlyDenyRust_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => ::fidl::RawWireUnion::encode_as::<u32>(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<DenyEachBinding_OnlyDenyRust_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalDenyEachBinding_OnlyDenyRust_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenyRust_Result<'buf>>
    for DenyEachBinding_OnlyDenyRust_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenyRust_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenyRust_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenyRust_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenyRust_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenyRust_Response),
    Err(&'buf ::fidl::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenyRust_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenyRust_Response),
    Err(&'buf mut ::fidl::u32_le),
}

impl WireDenyEachBinding_OnlyDenyRust_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenyRust_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyRust_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyRust_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenyRust_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenyRust_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenyRust_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenyRust_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl::RawWireUnion::decode_as::<crate::WireDenyEachBinding_OnlyDenyRust_Response>(
                    raw, decoder,
                )?
            }
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            ord => return Err(fidl::decode::Error::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenyRust_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenyRust_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenyRust_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenyRust_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenyRust_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenyRust_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl::RawWireUnion::decode_as::<crate::WireDenyEachBinding_OnlyDenyRust_Response>(
                    raw, decoder,
                )?
            }
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenyRust_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

impl ::fidl::Encode for DenyEachBindingOnlyDenySyzkallerRequest {
    type Encoded<'buf> = WireDenyEachBindingOnlyDenySyzkallerRequest;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBindingOnlyDenySyzkallerRequest> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireDenyEachBindingOnlyDenySyzkallerRequest>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBindingOnlyDenySyzkallerRequest>
    for DenyEachBindingOnlyDenySyzkallerRequest
{
    fn take_from(from: &mut WireDenyEachBindingOnlyDenySyzkallerRequest) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBindingOnlyDenySyzkallerRequest {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct DenyEachBinding_OnlyDenySyzkaller_Response {
    pub b: i32,
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenySyzkaller_Response {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenySyzkaller_Response;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<DenyEachBinding_OnlyDenySyzkaller_Response> {
    type EncodedOption<'buf> =
        ::fidl::WireBox<'buf, WireDenyEachBinding_OnlyDenySyzkaller_Response>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenySyzkaller_Response>
    for DenyEachBinding_OnlyDenySyzkaller_Response
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenySyzkaller_Response) -> Self {
        Self { b: ::fidl::TakeFrom::take_from(&mut from.b) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBinding_OnlyDenySyzkaller_Response {
    pub b: ::fidl::i32_le,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenySyzkaller_Response {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut b,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum DenyEachBinding_OnlyDenySyzkaller_Result {
    Response(crate::DenyEachBinding_OnlyDenySyzkaller_Response),
    Err(u32),
}

impl ::fidl::Encode for DenyEachBinding_OnlyDenySyzkaller_Result {
    type Encoded<'buf> = WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireDenyEachBinding_OnlyDenySyzkaller_Result { raw } = slot);

        match self {
            Self::Response(value) => ::fidl::RawWireUnion::encode_as::<
                crate::DenyEachBinding_OnlyDenySyzkaller_Response,
            >(value, 1, encoder, raw)?,
            Self::Err(value) => ::fidl::RawWireUnion::encode_as::<u32>(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<DenyEachBinding_OnlyDenySyzkaller_Result> {
    type EncodedOption<'buf> = WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>>
    for DenyEachBinding_OnlyDenySyzkaller_Result
{
    fn take_from(from: &mut WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Err(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf>>
    for Option<Box<DenyEachBinding_OnlyDenySyzkaller_Result>>
{
    fn take_from(from: &mut WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireDenyEachBinding_OnlyDenySyzkaller_ResultRef<'buf> {
    Response(&'buf crate::WireDenyEachBinding_OnlyDenySyzkaller_Response),
    Err(&'buf ::fidl::u32_le),
}

pub enum WireDenyEachBinding_OnlyDenySyzkaller_ResultMut<'buf> {
    Response(&'buf mut crate::WireDenyEachBinding_OnlyDenySyzkaller_Response),
    Err(&'buf mut ::fidl::u32_le),
}

impl WireDenyEachBinding_OnlyDenySyzkaller_Result<'_> {
    pub fn as_ref(&self) -> WireDenyEachBinding_OnlyDenySyzkaller_ResultRef<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenySyzkaller_ResultRef::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenySyzkaller_ResultRef::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireDenyEachBinding_OnlyDenySyzkaller_ResultMut<'_> {
        match self.raw.ordinal() {
            1 => WireDenyEachBinding_OnlyDenySyzkaller_ResultMut::Response(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireDenyEachBinding_OnlyDenySyzkaller_ResultMut::Err(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<
                crate::WireDenyEachBinding_OnlyDenySyzkaller_Response,
            >(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            ord => return Err(fidl::decode::Error::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBinding_OnlyDenySyzkaller_Response>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireDenyEachBinding_OnlyDenySyzkaller_Result<'buf>> {
        if self.is_some() {
            Some(WireDenyEachBinding_OnlyDenySyzkaller_Result {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf>
    for WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf>
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<
                crate::WireDenyEachBinding_OnlyDenySyzkaller_Response,
            >(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalDenyEachBinding_OnlyDenySyzkaller_Result<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct MemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

impl ::fidl::Encode for MemberOnlyAppearsInImportingLibrary {
    type Encoded<'buf> = WireMemberOnlyAppearsInImportingLibrary;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<MemberOnlyAppearsInImportingLibrary> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireMemberOnlyAppearsInImportingLibrary>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireMemberOnlyAppearsInImportingLibrary>
    for MemberOnlyAppearsInImportingLibrary
{
    fn take_from(from: &mut WireMemberOnlyAppearsInImportingLibrary) -> Self {
        Self { a: ::fidl::TakeFrom::take_from(&mut from.a) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireMemberOnlyAppearsInImportingLibrary {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut a,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(a.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct OnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::MemberOnlyAppearsInImportingLibrary,
}

impl ::fidl::Encode for OnlyAppearsInImportingLibrary {
    type Encoded<'buf> = WireOnlyAppearsInImportingLibrary;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
                member_only_appears_in_importing_library,
            } = slot;
        }
        ::fidl::Encode::encode(
            &mut self.member_only_appears_in_importing_library,
            encoder,
            member_only_appears_in_importing_library,
        )?;
        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<OnlyAppearsInImportingLibrary> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireOnlyAppearsInImportingLibrary>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireOnlyAppearsInImportingLibrary> for OnlyAppearsInImportingLibrary {
    fn take_from(from: &mut WireOnlyAppearsInImportingLibrary) -> Self {
        Self {
            member_only_appears_in_importing_library: ::fidl::TakeFrom::take_from(
                &mut from.member_only_appears_in_importing_library,
            ),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::WireMemberOnlyAppearsInImportingLibrary,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOnlyAppearsInImportingLibrary {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
                mut member_only_appears_in_importing_library,
            } = slot;
        }
        ::fidl::Decode::<'buf>::decode(member_only_appears_in_importing_library.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Copy, Debug)]
#[repr(u32)]
pub enum OnlyDart {
    A = 1,
}

impl ::fidl::Encode for OnlyDart {
    type Encoded<'buf> = WireOnlyDart;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOnlyDart { mut value } = slot);
        *value = ::fidl::u32_le::from(match *self {
            OnlyDart::A => 1,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireOnlyDart> for OnlyDart {
    fn from(wire: WireOnlyDart) -> Self {
        match u32::from(wire.value) {
            1 => OnlyDart::A,
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl::TakeFrom<WireOnlyDart> for OnlyDart {
    fn take_from(from: &mut WireOnlyDart) -> Self {
        OnlyDart::from(*from)
    }
}

#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireOnlyDart {
    value: ::fidl::u32_le,
}

impl WireOnlyDart {
    pub const A: WireOnlyDart = WireOnlyDart { value: ::fidl::u32_le::from_native(1) };
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOnlyDart {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 => (),
            unknown => return Err(::fidl::decode::Error::InvalidEnumOrdinal(unknown as usize)),
        }

        Ok(())
    }
}

impl ::core::convert::From<OnlyDart> for WireOnlyDart {
    fn from(natural: OnlyDart) -> Self {
        match natural {
            OnlyDart::A => WireOnlyDart::A,
        }
    }
}

#[derive(Clone, Debug)]
pub struct OnlyGo {}

impl ::fidl::Encode for OnlyGo {
    type Encoded<'buf> = WireOnlyGo;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge! {
            let Self::Encoded {
            } = slot;
        }

        Ok(())
    }
}

impl ::fidl::EncodeOption for Box<OnlyGo> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireOnlyGo>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        if let Some(inner) = this {
            encoder.encode(inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireOnlyGo> for OnlyGo {
    fn take_from(from: &mut WireOnlyGo) -> Self {
        Self {}
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyGo {}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOnlyGo {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge! {
            let Self {
            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum OnlyLlcpp {
    X(u32),
}

impl ::fidl::Encode for OnlyLlcpp {
    type Encoded<'buf> = WireOnlyLlcpp<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOnlyLlcpp { raw } = slot);

        match self {
            Self::X(value) => ::fidl::RawWireUnion::encode_as::<u32>(value, 1, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl::encode::EncodeOption for Box<OnlyLlcpp> {
    type EncodedOption<'buf> = WireOptionalOnlyLlcpp<'buf>;

    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ::fidl::encode::Encoder,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOptionalOnlyLlcpp { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::encode::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireOnlyLlcpp<'buf>> for OnlyLlcpp {
    fn take_from(from: &mut WireOnlyLlcpp<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::X(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalOnlyLlcpp<'buf>> for Option<Box<OnlyLlcpp>> {
    fn take_from(from: &mut WireOptionalOnlyLlcpp<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireOnlyLlcpp<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireOnlyLlcppRef<'buf> {
    X(&'buf ::fidl::u32_le),
}

pub enum WireOnlyLlcppMut<'buf> {
    X(&'buf mut ::fidl::u32_le),
}

impl WireOnlyLlcpp<'_> {
    pub fn as_ref(&self) -> WireOnlyLlcppRef<'_> {
        match self.raw.ordinal() {
            1 => WireOnlyLlcppRef::X(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireOnlyLlcppMut<'_> {
        match self.raw.ordinal() {
            1 => WireOnlyLlcppMut::X(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOnlyLlcpp<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            ord => return Err(fidl::decode::Error::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOnlyLlcpp<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalOnlyLlcpp<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalOnlyLlcpp<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireOnlyLlcpp<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireOnlyLlcpp<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireOnlyLlcpp<'buf>> {
        if self.is_some() {
            Some(WireOnlyLlcpp {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalOnlyLlcpp<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOptionalOnlyLlcpp<'buf> {
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<::fidl::u32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalOnlyLlcpp<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct OnlyRust {}

impl OnlyRust {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl::Encode for OnlyRust {
    type Encoded<'buf> = WireOnlyRust<'buf>;

    fn encode(
        &mut self,
        encoder: &mut ::fidl::encode::Encoder,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::encode::Error> {
        ::fidl::munge!(let WireOnlyRust { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl::WireEnvelope<'_>>::uninit();
        let mut preallocated = encoder.preallocate::<::fidl::WireEnvelope<'_>>(max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl::Slot::new(&mut backing);
            match i {
                _ => ::fidl::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireOnlyRust<'buf>> for OnlyRust {
    fn take_from(from: &mut WireOnlyRust<'buf>) -> Self {
        Self {}
    }
}

#[repr(C)]
pub struct WireOnlyRust<'buf> {
    table: ::fidl::WireTable<'buf>,
}

unsafe impl<'buf> ::fidl::Decode<'buf> for WireOnlyRust<'buf> {
    fn decode(
        slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ::fidl::decode::Decoder<'buf>,
    ) -> Result<(), ::fidl::decode::Error> {
        ::fidl::munge!(let Self { table } = slot);

        ::fidl::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| match ordinal {
            0 => unsafe { ::core::hint::unreachable_unchecked() },

            _ => ::fidl::WireEnvelope::decode_unknown(slot, decoder),
        })
    }
}

impl<'buf> WireOnlyRust<'buf> {}

impl ::core::fmt::Debug for WireOnlyRust<'_> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("OnlyRust").finish()
    }
}
