// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(
    unused_parens,
    unused_variables,
    unused_mut,
    unused_imports,
    unreachable_code,
    nonstandard_style
)]

#[derive(Debug)]
pub struct FdfHandles {
    pub fdf_channel_handle: ::fidl_next::Handle,
    pub client_end_driver:
        ::fidl_next::EndpointResource<::fidl_next::Handle, ::fidl_next::ClientEndpoint>,
    pub server_end_driver:
        ::fidl_next::EndpointResource<::fidl_next::Handle, ::fidl_next::ServerEndpoint>,
}

impl ::fidl_next::Encodable for FdfHandles {
    type Encoded<'buf> = WireFdfHandles;
}

impl<___E> ::fidl_next::Encode<___E> for FdfHandles
where
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::EndpointResource<::fidl_next::Handle, ::fidl_next::ClientEndpoint>:
        ::fidl_next::Encode<___E>,
    ::fidl_next::EndpointResource<::fidl_next::Handle, ::fidl_next::ServerEndpoint>:
        ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                fdf_channel_handle,
                client_end_driver,
                server_end_driver,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.fdf_channel_handle, encoder, fdf_channel_handle)?;
        ::fidl_next::Encode::encode(&mut self.client_end_driver, encoder, client_end_driver)?;
        ::fidl_next::Encode::encode(&mut self.server_end_driver, encoder, server_end_driver)?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<FdfHandles> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireFdfHandles>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<FdfHandles>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    FdfHandles: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireFdfHandles> for FdfHandles {
    fn take_from(from: &mut WireFdfHandles) -> Self {
        Self {
            fdf_channel_handle: ::fidl_next::TakeFrom::take_from(&mut from.fdf_channel_handle),
            client_end_driver: ::fidl_next::TakeFrom::take_from(&mut from.client_end_driver),
            server_end_driver: ::fidl_next::TakeFrom::take_from(&mut from.server_end_driver),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireFdfHandles {
    pub fdf_channel_handle: ::fidl_next::WireHandle,
    pub client_end_driver:
        ::fidl_next::EndpointResource<::fidl_next::WireHandle, ::fidl_next::ClientEndpoint>,
    pub server_end_driver:
        ::fidl_next::EndpointResource<::fidl_next::WireHandle, ::fidl_next::ServerEndpoint>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFdfHandles
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::EndpointResource<::fidl_next::WireHandle, ::fidl_next::ClientEndpoint>:
        ::fidl_next::Decode<___D>,
    ::fidl_next::EndpointResource<::fidl_next::WireHandle, ::fidl_next::ServerEndpoint>:
        ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut fdf_channel_handle,
                mut client_end_driver,
                mut server_end_driver,
            } = slot;
        }
        ::fidl_next::Decode::decode(fdf_channel_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(client_end_driver.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(server_end_driver.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct Handles {
    pub plain_handle: ::fidl_next::Handle,
    pub bti_handle: ::fidl_next::Handle,
    pub channel_handle: ::fidl_next::Handle,
    pub clock_handle: ::fidl_next::Handle,
    pub debuglog_handle: ::fidl_next::Handle,
    pub event_handle: ::fidl_next::Handle,
    pub eventpair_handle: ::fidl_next::Handle,
    pub exception_handle: ::fidl_next::Handle,
    pub fifo_handle: ::fidl_next::Handle,
    pub guest_handle: ::fidl_next::Handle,
    pub interrupt_handle: ::fidl_next::Handle,
    pub iommu_handle: ::fidl_next::Handle,
    pub job_handle: ::fidl_next::Handle,
    pub msi_handle: ::fidl_next::Handle,
    pub pager_handle: ::fidl_next::Handle,
    pub pmt_handle: ::fidl_next::Handle,
    pub port_handle: ::fidl_next::Handle,
    pub process_handle: ::fidl_next::Handle,
    pub profile_handle: ::fidl_next::Handle,
    pub resource_handle: ::fidl_next::Handle,
    pub socket_handle: ::fidl_next::Handle,
    pub stream_handle: ::fidl_next::Handle,
    pub suspendtoken_handle: ::fidl_next::Handle,
    pub thread_handle: ::fidl_next::Handle,
    pub timer_handle: ::fidl_next::Handle,
    pub vcpu_handle: ::fidl_next::Handle,
    pub vmar_handle: ::fidl_next::Handle,
    pub vmo_handle: ::fidl_next::Handle,
    pub rights_handle: ::fidl_next::Handle,
    pub aliased_plain_handle_field: ::fidl_next::Handle,
    pub aliased_subtype_handle_field: ::fidl_next::Handle,
    pub aliased_rights_handle_field: ::fidl_next::Handle,
    pub some_protocol:
        ::fidl_next::EndpointResource<::fidl_next::Handle, ::fidl_next::ClientEndpoint>,
    pub request_some_protocol:
        ::fidl_next::EndpointResource<::fidl_next::Handle, ::fidl_next::ServerEndpoint>,
}

impl ::fidl_next::Encodable for Handles {
    type Encoded<'buf> = WireHandles;
}

impl<___E> ::fidl_next::Encode<___E> for Handles
where
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::Handle: ::fidl_next::Encode<___E>,
    ::fidl_next::EndpointResource<::fidl_next::Handle, ::fidl_next::ClientEndpoint>:
        ::fidl_next::Encode<___E>,
    ::fidl_next::EndpointResource<::fidl_next::Handle, ::fidl_next::ServerEndpoint>:
        ::fidl_next::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                plain_handle,
                bti_handle,
                channel_handle,
                clock_handle,
                debuglog_handle,
                event_handle,
                eventpair_handle,
                exception_handle,
                fifo_handle,
                guest_handle,
                interrupt_handle,
                iommu_handle,
                job_handle,
                msi_handle,
                pager_handle,
                pmt_handle,
                port_handle,
                process_handle,
                profile_handle,
                resource_handle,
                socket_handle,
                stream_handle,
                suspendtoken_handle,
                thread_handle,
                timer_handle,
                vcpu_handle,
                vmar_handle,
                vmo_handle,
                rights_handle,
                aliased_plain_handle_field,
                aliased_subtype_handle_field,
                aliased_rights_handle_field,
                some_protocol,
                request_some_protocol,
            } = slot;
        }
        ::fidl_next::Encode::encode(&mut self.plain_handle, encoder, plain_handle)?;
        ::fidl_next::Encode::encode(&mut self.bti_handle, encoder, bti_handle)?;
        ::fidl_next::Encode::encode(&mut self.channel_handle, encoder, channel_handle)?;
        ::fidl_next::Encode::encode(&mut self.clock_handle, encoder, clock_handle)?;
        ::fidl_next::Encode::encode(&mut self.debuglog_handle, encoder, debuglog_handle)?;
        ::fidl_next::Encode::encode(&mut self.event_handle, encoder, event_handle)?;
        ::fidl_next::Encode::encode(&mut self.eventpair_handle, encoder, eventpair_handle)?;
        ::fidl_next::Encode::encode(&mut self.exception_handle, encoder, exception_handle)?;
        ::fidl_next::Encode::encode(&mut self.fifo_handle, encoder, fifo_handle)?;
        ::fidl_next::Encode::encode(&mut self.guest_handle, encoder, guest_handle)?;
        ::fidl_next::Encode::encode(&mut self.interrupt_handle, encoder, interrupt_handle)?;
        ::fidl_next::Encode::encode(&mut self.iommu_handle, encoder, iommu_handle)?;
        ::fidl_next::Encode::encode(&mut self.job_handle, encoder, job_handle)?;
        ::fidl_next::Encode::encode(&mut self.msi_handle, encoder, msi_handle)?;
        ::fidl_next::Encode::encode(&mut self.pager_handle, encoder, pager_handle)?;
        ::fidl_next::Encode::encode(&mut self.pmt_handle, encoder, pmt_handle)?;
        ::fidl_next::Encode::encode(&mut self.port_handle, encoder, port_handle)?;
        ::fidl_next::Encode::encode(&mut self.process_handle, encoder, process_handle)?;
        ::fidl_next::Encode::encode(&mut self.profile_handle, encoder, profile_handle)?;
        ::fidl_next::Encode::encode(&mut self.resource_handle, encoder, resource_handle)?;
        ::fidl_next::Encode::encode(&mut self.socket_handle, encoder, socket_handle)?;
        ::fidl_next::Encode::encode(&mut self.stream_handle, encoder, stream_handle)?;
        ::fidl_next::Encode::encode(&mut self.suspendtoken_handle, encoder, suspendtoken_handle)?;
        ::fidl_next::Encode::encode(&mut self.thread_handle, encoder, thread_handle)?;
        ::fidl_next::Encode::encode(&mut self.timer_handle, encoder, timer_handle)?;
        ::fidl_next::Encode::encode(&mut self.vcpu_handle, encoder, vcpu_handle)?;
        ::fidl_next::Encode::encode(&mut self.vmar_handle, encoder, vmar_handle)?;
        ::fidl_next::Encode::encode(&mut self.vmo_handle, encoder, vmo_handle)?;
        ::fidl_next::Encode::encode(&mut self.rights_handle, encoder, rights_handle)?;
        ::fidl_next::Encode::encode(
            &mut self.aliased_plain_handle_field,
            encoder,
            aliased_plain_handle_field,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.aliased_subtype_handle_field,
            encoder,
            aliased_subtype_handle_field,
        )?;
        ::fidl_next::Encode::encode(
            &mut self.aliased_rights_handle_field,
            encoder,
            aliased_rights_handle_field,
        )?;
        ::fidl_next::Encode::encode(&mut self.some_protocol, encoder, some_protocol)?;
        ::fidl_next::Encode::encode(
            &mut self.request_some_protocol,
            encoder,
            request_some_protocol,
        )?;
        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Handles> {
    type EncodedOption<'buf> = ::fidl_next::WireBox<'buf, WireHandles>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Handles>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Handles: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandles> for Handles {
    fn take_from(from: &mut WireHandles) -> Self {
        Self {
            plain_handle: ::fidl_next::TakeFrom::take_from(&mut from.plain_handle),
            bti_handle: ::fidl_next::TakeFrom::take_from(&mut from.bti_handle),
            channel_handle: ::fidl_next::TakeFrom::take_from(&mut from.channel_handle),
            clock_handle: ::fidl_next::TakeFrom::take_from(&mut from.clock_handle),
            debuglog_handle: ::fidl_next::TakeFrom::take_from(&mut from.debuglog_handle),
            event_handle: ::fidl_next::TakeFrom::take_from(&mut from.event_handle),
            eventpair_handle: ::fidl_next::TakeFrom::take_from(&mut from.eventpair_handle),
            exception_handle: ::fidl_next::TakeFrom::take_from(&mut from.exception_handle),
            fifo_handle: ::fidl_next::TakeFrom::take_from(&mut from.fifo_handle),
            guest_handle: ::fidl_next::TakeFrom::take_from(&mut from.guest_handle),
            interrupt_handle: ::fidl_next::TakeFrom::take_from(&mut from.interrupt_handle),
            iommu_handle: ::fidl_next::TakeFrom::take_from(&mut from.iommu_handle),
            job_handle: ::fidl_next::TakeFrom::take_from(&mut from.job_handle),
            msi_handle: ::fidl_next::TakeFrom::take_from(&mut from.msi_handle),
            pager_handle: ::fidl_next::TakeFrom::take_from(&mut from.pager_handle),
            pmt_handle: ::fidl_next::TakeFrom::take_from(&mut from.pmt_handle),
            port_handle: ::fidl_next::TakeFrom::take_from(&mut from.port_handle),
            process_handle: ::fidl_next::TakeFrom::take_from(&mut from.process_handle),
            profile_handle: ::fidl_next::TakeFrom::take_from(&mut from.profile_handle),
            resource_handle: ::fidl_next::TakeFrom::take_from(&mut from.resource_handle),
            socket_handle: ::fidl_next::TakeFrom::take_from(&mut from.socket_handle),
            stream_handle: ::fidl_next::TakeFrom::take_from(&mut from.stream_handle),
            suspendtoken_handle: ::fidl_next::TakeFrom::take_from(&mut from.suspendtoken_handle),
            thread_handle: ::fidl_next::TakeFrom::take_from(&mut from.thread_handle),
            timer_handle: ::fidl_next::TakeFrom::take_from(&mut from.timer_handle),
            vcpu_handle: ::fidl_next::TakeFrom::take_from(&mut from.vcpu_handle),
            vmar_handle: ::fidl_next::TakeFrom::take_from(&mut from.vmar_handle),
            vmo_handle: ::fidl_next::TakeFrom::take_from(&mut from.vmo_handle),
            rights_handle: ::fidl_next::TakeFrom::take_from(&mut from.rights_handle),
            aliased_plain_handle_field: ::fidl_next::TakeFrom::take_from(
                &mut from.aliased_plain_handle_field,
            ),
            aliased_subtype_handle_field: ::fidl_next::TakeFrom::take_from(
                &mut from.aliased_subtype_handle_field,
            ),
            aliased_rights_handle_field: ::fidl_next::TakeFrom::take_from(
                &mut from.aliased_rights_handle_field,
            ),
            some_protocol: ::fidl_next::TakeFrom::take_from(&mut from.some_protocol),
            request_some_protocol: ::fidl_next::TakeFrom::take_from(
                &mut from.request_some_protocol,
            ),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireHandles {
    pub plain_handle: ::fidl_next::WireHandle,
    pub bti_handle: ::fidl_next::WireHandle,
    pub channel_handle: ::fidl_next::WireHandle,
    pub clock_handle: ::fidl_next::WireHandle,
    pub debuglog_handle: ::fidl_next::WireHandle,
    pub event_handle: ::fidl_next::WireHandle,
    pub eventpair_handle: ::fidl_next::WireHandle,
    pub exception_handle: ::fidl_next::WireHandle,
    pub fifo_handle: ::fidl_next::WireHandle,
    pub guest_handle: ::fidl_next::WireHandle,
    pub interrupt_handle: ::fidl_next::WireHandle,
    pub iommu_handle: ::fidl_next::WireHandle,
    pub job_handle: ::fidl_next::WireHandle,
    pub msi_handle: ::fidl_next::WireHandle,
    pub pager_handle: ::fidl_next::WireHandle,
    pub pmt_handle: ::fidl_next::WireHandle,
    pub port_handle: ::fidl_next::WireHandle,
    pub process_handle: ::fidl_next::WireHandle,
    pub profile_handle: ::fidl_next::WireHandle,
    pub resource_handle: ::fidl_next::WireHandle,
    pub socket_handle: ::fidl_next::WireHandle,
    pub stream_handle: ::fidl_next::WireHandle,
    pub suspendtoken_handle: ::fidl_next::WireHandle,
    pub thread_handle: ::fidl_next::WireHandle,
    pub timer_handle: ::fidl_next::WireHandle,
    pub vcpu_handle: ::fidl_next::WireHandle,
    pub vmar_handle: ::fidl_next::WireHandle,
    pub vmo_handle: ::fidl_next::WireHandle,
    pub rights_handle: ::fidl_next::WireHandle,
    pub aliased_plain_handle_field: ::fidl_next::WireHandle,
    pub aliased_subtype_handle_field: ::fidl_next::WireHandle,
    pub aliased_rights_handle_field: ::fidl_next::WireHandle,
    pub some_protocol:
        ::fidl_next::EndpointResource<::fidl_next::WireHandle, ::fidl_next::ClientEndpoint>,
    pub request_some_protocol:
        ::fidl_next::EndpointResource<::fidl_next::WireHandle, ::fidl_next::ServerEndpoint>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandles
where
    ___D: ?Sized,

    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::WireHandle: ::fidl_next::Decode<___D>,
    ::fidl_next::EndpointResource<::fidl_next::WireHandle, ::fidl_next::ClientEndpoint>:
        ::fidl_next::Decode<___D>,
    ::fidl_next::EndpointResource<::fidl_next::WireHandle, ::fidl_next::ServerEndpoint>:
        ::fidl_next::Decode<___D>,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut plain_handle,
                mut bti_handle,
                mut channel_handle,
                mut clock_handle,
                mut debuglog_handle,
                mut event_handle,
                mut eventpair_handle,
                mut exception_handle,
                mut fifo_handle,
                mut guest_handle,
                mut interrupt_handle,
                mut iommu_handle,
                mut job_handle,
                mut msi_handle,
                mut pager_handle,
                mut pmt_handle,
                mut port_handle,
                mut process_handle,
                mut profile_handle,
                mut resource_handle,
                mut socket_handle,
                mut stream_handle,
                mut suspendtoken_handle,
                mut thread_handle,
                mut timer_handle,
                mut vcpu_handle,
                mut vmar_handle,
                mut vmo_handle,
                mut rights_handle,
                mut aliased_plain_handle_field,
                mut aliased_subtype_handle_field,
                mut aliased_rights_handle_field,
                mut some_protocol,
                mut request_some_protocol,
            } = slot;
        }
        ::fidl_next::Decode::decode(plain_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(bti_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(channel_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(clock_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(debuglog_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(event_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(eventpair_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(exception_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(fifo_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(guest_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(interrupt_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(iommu_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(job_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(msi_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(pager_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(pmt_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(port_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(process_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(profile_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(resource_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(socket_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(stream_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(suspendtoken_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(thread_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(timer_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(vcpu_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(vmar_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(vmo_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(rights_handle.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(aliased_plain_handle_field.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(aliased_subtype_handle_field.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(aliased_rights_handle_field.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(some_protocol.as_mut(), decoder)?;
        ::fidl_next::Decode::decode(request_some_protocol.as_mut(), decoder)?;
        Ok(())
    }
}
