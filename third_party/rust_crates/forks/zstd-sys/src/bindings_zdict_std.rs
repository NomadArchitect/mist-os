// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Generated by third_party/rust_crates/forks/zstd-sys/bindgen.sh using bindgen 0.71.1

unsafe extern "C" {
    /// ZDICT_trainFromBuffer():
    ///  Train a dictionary from an array of samples.
    ///  Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,
    ///  f=20, and accel=1.
    ///  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
    ///  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
    ///  The resulting dictionary will be saved into `dictBuffer`.
    /// @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
    ///          or an error code, which can be tested with ZDICT_isError().
    ///  Note:  Dictionary training will fail if there are not enough samples to construct a
    ///         dictionary, or if most of the samples are too small (< 8 bytes being the lower limit).
    ///         If dictionary training fails, you should use zstd without a dictionary, as the dictionary
    ///         would've been ineffective anyways. If you believe your samples would benefit from a dictionary
    ///         please open an issue with details, and we can look into it.
    ///  Note: ZDICT_trainFromBuffer()'s memory usage is about 6 MB.
    ///  Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
    ///        It's possible to select smaller or larger size, just by specifying `dictBufferCapacity`.
    ///        In general, it's recommended to provide a few thousands samples, though this can vary a lot.
    ///        It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
    pub fn ZDICT_trainFromBuffer(
        dictBuffer: *mut ::core::ffi::c_void,
        dictBufferCapacity: usize,
        samplesBuffer: *const ::core::ffi::c_void,
        samplesSizes: *const usize,
        nbSamples: ::core::ffi::c_uint,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZDICT_params_t {
    ///< optimize for a specific zstd compression level; 0 means default
    pub compressionLevel: ::core::ffi::c_int,
    ///< Write log to stderr; 0 = none (default); 1 = errors; 2 = progression; 3 = details; 4 = debug;
    pub notificationLevel: ::core::ffi::c_uint,
    ///< force dictID value; 0 means auto mode (32-bits random value)
    ///   NOTE: The zstd format reserves some dictionary IDs for future use.
    ///         You may use them in private settings, but be warned that they
    ///         may be used by zstd in a public dictionary registry in the future.
    ///         These dictionary IDs are:
    ///           - low range  : <= 32767
    ///           - high range : >= (2^31)
    pub dictID: ::core::ffi::c_uint,
}
unsafe extern "C" {
    /// ZDICT_finalizeDictionary():
    /// Given a custom content as a basis for dictionary, and a set of samples,
    /// finalize dictionary by adding headers and statistics according to the zstd
    /// dictionary format.
    ///
    /// Samples must be stored concatenated in a flat buffer `samplesBuffer`,
    /// supplied with an array of sizes `samplesSizes`, providing the size of each
    /// sample in order. The samples are used to construct the statistics, so they
    /// should be representative of what you will compress with this dictionary.
    ///
    /// The compression level can be set in `parameters`. You should pass the
    /// compression level you expect to use in production. The statistics for each
    /// compression level differ, so tuning the dictionary for the compression level
    /// can help quite a bit.
    ///
    /// You can set an explicit dictionary ID in `parameters`, or allow us to pick
    /// a random dictionary ID for you, but we can't guarantee no collisions.
    ///
    /// The dstDictBuffer and the dictContent may overlap, and the content will be
    /// appended to the end of the header. If the header + the content doesn't fit in
    /// maxDictSize the beginning of the content is truncated to make room, since it
    /// is presumed that the most profitable content is at the end of the dictionary,
    /// since that is the cheapest to reference.
    ///
    /// `maxDictSize` must be >= max(dictContentSize, ZSTD_DICTSIZE_MIN).
    ///
    /// @return: size of dictionary stored into `dstDictBuffer` (<= `maxDictSize`),
    ///          or an error code, which can be tested by ZDICT_isError().
    /// Note: ZDICT_finalizeDictionary() will push notifications into stderr if
    ///       instructed to, using notificationLevel>0.
    /// NOTE: This function currently may fail in several edge cases including:
    ///         * Not enough samples
    ///         * Samples are uncompressible
    ///         * Samples are all exactly the same
    pub fn ZDICT_finalizeDictionary(
        dstDictBuffer: *mut ::core::ffi::c_void,
        maxDictSize: usize,
        dictContent: *const ::core::ffi::c_void,
        dictContentSize: usize,
        samplesBuffer: *const ::core::ffi::c_void,
        samplesSizes: *const usize,
        nbSamples: ::core::ffi::c_uint,
        parameters: ZDICT_params_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ZDICT_getDictID(
        dictBuffer: *const ::core::ffi::c_void,
        dictSize: usize,
    ) -> ::core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn ZDICT_getDictHeaderSize(
        dictBuffer: *const ::core::ffi::c_void,
        dictSize: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ZDICT_isError(errorCode: usize) -> ::core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn ZDICT_getErrorName(errorCode: usize) -> *const ::core::ffi::c_char;
}
