// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Generated by third_party/rust_crates/forks/zstd-sys/bindgen.sh using bindgen 0.71.1

pub const ZSTD_VERSION_MAJOR: u32 = 1;
pub const ZSTD_VERSION_MINOR: u32 = 5;
pub const ZSTD_VERSION_RELEASE: u32 = 6;
pub const ZSTD_VERSION_NUMBER: u32 = 10506;
pub const ZSTD_CLEVEL_DEFAULT: u32 = 3;
pub const ZSTD_MAGICNUMBER: u32 = 4247762216;
pub const ZSTD_MAGIC_DICTIONARY: u32 = 3962610743;
pub const ZSTD_MAGIC_SKIPPABLE_START: u32 = 407710288;
pub const ZSTD_MAGIC_SKIPPABLE_MASK: u32 = 4294967280;
pub const ZSTD_BLOCKSIZELOG_MAX: u32 = 17;
pub const ZSTD_BLOCKSIZE_MAX: u32 = 131072;
pub const ZSTD_CONTENTSIZE_UNKNOWN: i32 = -1;
pub const ZSTD_CONTENTSIZE_ERROR: i32 = -2;
unsafe extern "C" {
    /// ZSTD_versionNumber() :
    ///  Return runtime library version, the value is (MAJOR*100*100 + MINOR*100 + RELEASE).
    pub fn ZSTD_versionNumber() -> ::core::ffi::c_uint;
}
unsafe extern "C" {
    /// ZSTD_versionString() :
    ///  Return runtime library version, like "1.4.5". Requires v1.3.0+.
    pub fn ZSTD_versionString() -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    ///  Simple API
    ////
    ////*! ZSTD_compress() :
    ///  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.
    ///  NOTE: Providing `dstCapacity >= ZSTD_compressBound(srcSize)` guarantees that zstd will have
    ///        enough space to successfully compress the data.
    ///  @return : compressed size written into `dst` (<= `dstCapacity),
    ///            or an error code if it fails (which can be tested using ZSTD_isError()).
    pub fn ZSTD_compress(
        dst: *mut ::core::ffi::c_void,
        dstCapacity: usize,
        src: *const ::core::ffi::c_void,
        srcSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -> usize;
}
unsafe extern "C" {
    /// ZSTD_decompress() :
    ///  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.
    ///  `dstCapacity` is an upper bound of originalSize to regenerate.
    ///  If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.
    ///  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),
    ///            or an errorCode if it fails (which can be tested using ZSTD_isError()).
    pub fn ZSTD_decompress(
        dst: *mut ::core::ffi::c_void,
        dstCapacity: usize,
        src: *const ::core::ffi::c_void,
        compressedSize: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_getFrameContentSize(
        src: *const ::core::ffi::c_void,
        srcSize: usize,
    ) -> ::core::ffi::c_ulonglong;
}
unsafe extern "C" {
    /// ZSTD_getDecompressedSize() :
    ///  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize().
    ///  Both functions work the same way, but ZSTD_getDecompressedSize() blends
    ///  "empty", "unknown" and "error" results to the same return value (0),
    ///  while ZSTD_getFrameContentSize() gives them separate return values.
    /// @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise.
    pub fn ZSTD_getDecompressedSize(
        src: *const ::core::ffi::c_void,
        srcSize: usize,
    ) -> ::core::ffi::c_ulonglong;
}
unsafe extern "C" {
    /// ZSTD_findFrameCompressedSize() : Requires v1.4.0+
    /// `src` should point to the start of a ZSTD frame or skippable frame.
    /// `srcSize` must be >= first frame size
    /// @return : the compressed size of the first frame starting at `src`,
    ///           suitable to pass as `srcSize` to `ZSTD_decompress` or similar,
    ///        or an error code if input is invalid
    pub fn ZSTD_findFrameCompressedSize(src: *const ::core::ffi::c_void, srcSize: usize) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_compressBound(srcSize: usize) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_isError(code: usize) -> ::core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn ZSTD_getErrorName(code: usize) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn ZSTD_minCLevel() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ZSTD_maxCLevel() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ZSTD_defaultCLevel() -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CCtx_s {
    _unused: [u8; 0],
}
///  Explicit context
pub type ZSTD_CCtx = ZSTD_CCtx_s;
unsafe extern "C" {
    pub fn ZSTD_createCCtx() -> *mut ZSTD_CCtx;
}
unsafe extern "C" {
    pub fn ZSTD_freeCCtx(cctx: *mut ZSTD_CCtx) -> usize;
}
unsafe extern "C" {
    /// ZSTD_compressCCtx() :
    ///  Same as ZSTD_compress(), using an explicit ZSTD_CCtx.
    ///  Important : in order to mirror `ZSTD_compress()` behavior,
    ///  this function compresses at the requested compression level,
    ///  __ignoring any other advanced parameter__ .
    ///  If any advanced parameter was set using the advanced API,
    ///  they will all be reset. Only `compressionLevel` remains.
    pub fn ZSTD_compressCCtx(
        cctx: *mut ZSTD_CCtx,
        dst: *mut ::core::ffi::c_void,
        dstCapacity: usize,
        src: *const ::core::ffi::c_void,
        srcSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DCtx_s {
    _unused: [u8; 0],
}
pub type ZSTD_DCtx = ZSTD_DCtx_s;
unsafe extern "C" {
    pub fn ZSTD_createDCtx() -> *mut ZSTD_DCtx;
}
unsafe extern "C" {
    pub fn ZSTD_freeDCtx(dctx: *mut ZSTD_DCtx) -> usize;
}
unsafe extern "C" {
    /// ZSTD_decompressDCtx() :
    ///  Same as ZSTD_decompress(),
    ///  requires an allocated ZSTD_DCtx.
    ///  Compatible with sticky parameters (see below).
    pub fn ZSTD_decompressDCtx(
        dctx: *mut ZSTD_DCtx,
        dst: *mut ::core::ffi::c_void,
        dstCapacity: usize,
        src: *const ::core::ffi::c_void,
        srcSize: usize,
    ) -> usize;
}
#[repr(u32)]
///  Advanced compression API (Requires v1.4.0+)
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ZSTD_strategy {
    ZSTD_fast = 1,
    ZSTD_dfast = 2,
    ZSTD_greedy = 3,
    ZSTD_lazy = 4,
    ZSTD_lazy2 = 5,
    ZSTD_btlazy2 = 6,
    ZSTD_btopt = 7,
    ZSTD_btultra = 8,
    ZSTD_btultra2 = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ZSTD_cParameter {
    ZSTD_c_compressionLevel = 100,
    ZSTD_c_windowLog = 101,
    ZSTD_c_hashLog = 102,
    ZSTD_c_chainLog = 103,
    ZSTD_c_searchLog = 104,
    ZSTD_c_minMatch = 105,
    ZSTD_c_targetLength = 106,
    ZSTD_c_strategy = 107,
    ZSTD_c_targetCBlockSize = 130,
    ZSTD_c_enableLongDistanceMatching = 160,
    ZSTD_c_ldmHashLog = 161,
    ZSTD_c_ldmMinMatch = 162,
    ZSTD_c_ldmBucketSizeLog = 163,
    ZSTD_c_ldmHashRateLog = 164,
    ZSTD_c_contentSizeFlag = 200,
    ZSTD_c_checksumFlag = 201,
    ZSTD_c_dictIDFlag = 202,
    ZSTD_c_nbWorkers = 400,
    ZSTD_c_jobSize = 401,
    ZSTD_c_overlapLog = 402,
    ZSTD_c_experimentalParam1 = 500,
    ZSTD_c_experimentalParam2 = 10,
    ZSTD_c_experimentalParam3 = 1000,
    ZSTD_c_experimentalParam4 = 1001,
    ZSTD_c_experimentalParam5 = 1002,
    ZSTD_c_experimentalParam7 = 1004,
    ZSTD_c_experimentalParam8 = 1005,
    ZSTD_c_experimentalParam9 = 1006,
    ZSTD_c_experimentalParam10 = 1007,
    ZSTD_c_experimentalParam11 = 1008,
    ZSTD_c_experimentalParam12 = 1009,
    ZSTD_c_experimentalParam13 = 1010,
    ZSTD_c_experimentalParam14 = 1011,
    ZSTD_c_experimentalParam15 = 1012,
    ZSTD_c_experimentalParam16 = 1013,
    ZSTD_c_experimentalParam17 = 1014,
    ZSTD_c_experimentalParam18 = 1015,
    ZSTD_c_experimentalParam19 = 1016,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_bounds {
    pub error: usize,
    pub lowerBound: ::core::ffi::c_int,
    pub upperBound: ::core::ffi::c_int,
}
unsafe extern "C" {
    /// ZSTD_cParam_getBounds() :
    ///  All parameters must belong to an interval with lower and upper bounds,
    ///  otherwise they will either trigger an error or be automatically clamped.
    /// @return : a structure, ZSTD_bounds, which contains
    ///         - an error status field, which must be tested using ZSTD_isError()
    ///         - lower and upper bounds, both inclusive
    pub fn ZSTD_cParam_getBounds(cParam: ZSTD_cParameter) -> ZSTD_bounds;
}
unsafe extern "C" {
    /// ZSTD_CCtx_setParameter() :
    ///  Set one compression parameter, selected by enum ZSTD_cParameter.
    ///  All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds().
    ///  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
    ///  Setting a parameter is generally only possible during frame initialization (before starting compression).
    ///  Exception : when using multi-threading mode (nbWorkers >= 1),
    ///              the following parameters can be updated _during_ compression (within same frame):
    ///              => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy.
    ///              new parameters will be active for next job only (after a flush()).
    /// @return : an error code (which can be tested using ZSTD_isError()).
    pub fn ZSTD_CCtx_setParameter(
        cctx: *mut ZSTD_CCtx,
        param: ZSTD_cParameter,
        value: ::core::ffi::c_int,
    ) -> usize;
}
unsafe extern "C" {
    /// ZSTD_CCtx_setPledgedSrcSize() :
    ///  Total input data size to be compressed as a single frame.
    ///  Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag.
    ///  This value will also be controlled at end of frame, and trigger an error if not respected.
    /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
    ///  Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame.
    ///           In order to mean "unknown content size", pass constant ZSTD_CONTENTSIZE_UNKNOWN.
    ///           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame.
    ///  Note 2 : pledgedSrcSize is only valid once, for the next frame.
    ///           It's discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN.
    ///  Note 3 : Whenever all input data is provided and consumed in a single round,
    ///           for example with ZSTD_compress2(),
    ///           or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),
    ///           this value is automatically overridden by srcSize instead.
    pub fn ZSTD_CCtx_setPledgedSrcSize(
        cctx: *mut ZSTD_CCtx,
        pledgedSrcSize: ::core::ffi::c_ulonglong,
    ) -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ZSTD_ResetDirective {
    ZSTD_reset_session_only = 1,
    ZSTD_reset_parameters = 2,
    ZSTD_reset_session_and_parameters = 3,
}
unsafe extern "C" {
    /// ZSTD_CCtx_reset() :
    ///  There are 2 different things that can be reset, independently or jointly :
    ///  - The session : will stop compressing current frame, and make CCtx ready to start a new one.
    ///                  Useful after an error, or to interrupt any ongoing compression.
    ///                  Any internal data not yet flushed is cancelled.
    ///                  Compression parameters and dictionary remain unchanged.
    ///                  They will be used to compress next frame.
    ///                  Resetting session never fails.
    ///  - The parameters : changes all parameters back to "default".
    ///                  This also removes any reference to any dictionary or external sequence producer.
    ///                  Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)
    ///                  otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())
    ///  - Both : similar to resetting the session, followed by resetting parameters.
    pub fn ZSTD_CCtx_reset(cctx: *mut ZSTD_CCtx, reset: ZSTD_ResetDirective) -> usize;
}
unsafe extern "C" {
    /// ZSTD_compress2() :
    ///  Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API.
    ///  (note that this entry point doesn't even expose a compression level parameter).
    ///  ZSTD_compress2() always starts a new frame.
    ///  Should cctx hold data from a previously unfinished frame, everything about it is forgotten.
    ///  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
    ///  - The function is always blocking, returns when compression is completed.
    ///  NOTE: Providing `dstCapacity >= ZSTD_compressBound(srcSize)` guarantees that zstd will have
    ///        enough space to successfully compress the data, though it is possible it fails for other reasons.
    /// @return : compressed size written into `dst` (<= `dstCapacity),
    ///           or an error code if it fails (which can be tested using ZSTD_isError()).
    pub fn ZSTD_compress2(
        cctx: *mut ZSTD_CCtx,
        dst: *mut ::core::ffi::c_void,
        dstCapacity: usize,
        src: *const ::core::ffi::c_void,
        srcSize: usize,
    ) -> usize;
}
#[repr(u32)]
///  Advanced decompression API (Requires v1.4.0+)
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ZSTD_dParameter {
    ZSTD_d_windowLogMax = 100,
    ZSTD_d_experimentalParam1 = 1000,
    ZSTD_d_experimentalParam2 = 1001,
    ZSTD_d_experimentalParam3 = 1002,
    ZSTD_d_experimentalParam4 = 1003,
    ZSTD_d_experimentalParam5 = 1004,
    ZSTD_d_experimentalParam6 = 1005,
}
unsafe extern "C" {
    /// ZSTD_dParam_getBounds() :
    ///  All parameters must belong to an interval with lower and upper bounds,
    ///  otherwise they will either trigger an error or be automatically clamped.
    /// @return : a structure, ZSTD_bounds, which contains
    ///         - an error status field, which must be tested using ZSTD_isError()
    ///         - both lower and upper bounds, inclusive
    pub fn ZSTD_dParam_getBounds(dParam: ZSTD_dParameter) -> ZSTD_bounds;
}
unsafe extern "C" {
    /// ZSTD_DCtx_setParameter() :
    ///  Set one compression parameter, selected by enum ZSTD_dParameter.
    ///  All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds().
    ///  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
    ///  Setting a parameter is only possible during frame initialization (before starting decompression).
    /// @return : 0, or an error code (which can be tested using ZSTD_isError()).
    pub fn ZSTD_DCtx_setParameter(
        dctx: *mut ZSTD_DCtx,
        param: ZSTD_dParameter,
        value: ::core::ffi::c_int,
    ) -> usize;
}
unsafe extern "C" {
    /// ZSTD_DCtx_reset() :
    ///  Return a DCtx to clean state.
    ///  Session and parameters can be reset jointly or separately.
    ///  Parameters can only be reset when no active frame is being decompressed.
    /// @return : 0, or an error code, which can be tested with ZSTD_isError()
    pub fn ZSTD_DCtx_reset(dctx: *mut ZSTD_DCtx, reset: ZSTD_ResetDirective) -> usize;
}
///  Streaming
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_inBuffer_s {
    ///< start of input buffer
    pub src: *const ::core::ffi::c_void,
    ///< size of input buffer
    pub size: usize,
    ///< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size
    pub pos: usize,
}
///  Streaming
pub type ZSTD_inBuffer = ZSTD_inBuffer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_outBuffer_s {
    ///< start of output buffer
    pub dst: *mut ::core::ffi::c_void,
    ///< size of output buffer
    pub size: usize,
    ///< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size
    pub pos: usize,
}
pub type ZSTD_outBuffer = ZSTD_outBuffer_s;
pub type ZSTD_CStream = ZSTD_CCtx;
unsafe extern "C" {
    pub fn ZSTD_createCStream() -> *mut ZSTD_CStream;
}
unsafe extern "C" {
    pub fn ZSTD_freeCStream(zcs: *mut ZSTD_CStream) -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ZSTD_EndDirective {
    ZSTD_e_continue = 0,
    ZSTD_e_flush = 1,
    ZSTD_e_end = 2,
}
unsafe extern "C" {
    /// ZSTD_compressStream2() : Requires v1.4.0+
    ///  Behaves about the same as ZSTD_compressStream, with additional control on end directive.
    ///  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
    ///  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)
    ///  - output->pos must be <= dstCapacity, input->pos must be <= srcSize
    ///  - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit.
    ///  - endOp must be a valid directive
    ///  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller.
    ///  - When nbWorkers>=1, function is non-blocking : it copies a portion of input, distributes jobs to internal worker threads, flush to output whatever is available,
    ///                                                  and then immediately returns, just indicating that there is some data remaining to be flushed.
    ///                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte.
    ///  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking.
    ///  - @return provides a minimum amount of data remaining to be flushed from internal buffers
    ///            or an error code, which can be tested using ZSTD_isError().
    ///            if @return != 0, flush is not fully completed, there is still some data left within internal buffers.
    ///            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers.
    ///            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed.
    ///  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),
    ///            only ZSTD_e_end or ZSTD_e_flush operations are allowed.
    ///            Before starting a new compression job, or changing compression parameters,
    ///            it is required to fully flush internal buffers.
    ///  - note: if an operation ends with an error, it may leave @cctx in an undefined state.
    ///          Therefore, it's UB to invoke ZSTD_compressStream2() of ZSTD_compressStream() on such a state.
    ///          In order to be re-employed after an error, a state must be reset,
    ///          which can be done explicitly (ZSTD_CCtx_reset()),
    ///          or is sometimes implied by methods starting a new compression job (ZSTD_initCStream(), ZSTD_compressCCtx())
    pub fn ZSTD_compressStream2(
        cctx: *mut ZSTD_CCtx,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
        endOp: ZSTD_EndDirective,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_CStreamInSize() -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_CStreamOutSize() -> usize;
}
unsafe extern "C" {
    /// Equivalent to:
    ///
    ///     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
    ///     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
    ///     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
    ///
    /// Note that ZSTD_initCStream() clears any previously set dictionary. Use the new API
    /// to compress with a dictionary.
    pub fn ZSTD_initCStream(zcs: *mut ZSTD_CStream, compressionLevel: ::core::ffi::c_int) -> usize;
}
unsafe extern "C" {
    /// Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue).
    /// NOTE: The return value is different. ZSTD_compressStream() returns a hint for
    /// the next read size (if non-zero and not an error). ZSTD_compressStream2()
    /// returns the minimum nb of bytes left to flush (if non-zero and not an error).
    pub fn ZSTD_compressStream(
        zcs: *mut ZSTD_CStream,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
    ) -> usize;
}
unsafe extern "C" {
    /// Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush).
    pub fn ZSTD_flushStream(zcs: *mut ZSTD_CStream, output: *mut ZSTD_outBuffer) -> usize;
}
unsafe extern "C" {
    /// Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end).
    pub fn ZSTD_endStream(zcs: *mut ZSTD_CStream, output: *mut ZSTD_outBuffer) -> usize;
}
pub type ZSTD_DStream = ZSTD_DCtx;
unsafe extern "C" {
    pub fn ZSTD_createDStream() -> *mut ZSTD_DStream;
}
unsafe extern "C" {
    pub fn ZSTD_freeDStream(zds: *mut ZSTD_DStream) -> usize;
}
unsafe extern "C" {
    /// ZSTD_initDStream() :
    /// Initialize/reset DStream state for new decompression operation.
    /// Call before new decompression operation using same DStream.
    ///
    /// Note : This function is redundant with the advanced API and equivalent to:
    ///     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
    ///     ZSTD_DCtx_refDDict(zds, NULL);
    pub fn ZSTD_initDStream(zds: *mut ZSTD_DStream) -> usize;
}
unsafe extern "C" {
    /// ZSTD_decompressStream() :
    /// Streaming decompression function.
    /// Call repetitively to consume full input updating it as necessary.
    /// Function will update both input and output `pos` fields exposing current state via these fields:
    /// - `input.pos < input.size`, some input remaining and caller should provide remaining input
    ///   on the next call.
    /// - `output.pos < output.size`, decoder finished and flushed all remaining buffers.
    /// - `output.pos == output.size`, potentially uncflushed data present in the internal buffers,
    ///   call ZSTD_decompressStream() again to flush remaining data to output.
    /// Note : with no additional input, amount of data flushed <= ZSTD_BLOCKSIZE_MAX.
    ///
    /// @return : 0 when a frame is completely decoded and fully flushed,
    ///           or an error code, which can be tested using ZSTD_isError(),
    ///           or any other value > 0, which means there is some decoding or flushing to do to complete current frame.
    ///
    /// Note: when an operation returns with an error code, the @zds state may be left in undefined state.
    ///       It's UB to invoke `ZSTD_decompressStream()` on such a state.
    ///       In order to re-use such a state, it must be first reset,
    ///       which can be done explicitly (`ZSTD_DCtx_reset()`),
    ///       or is implied for operations starting some new decompression job (`ZSTD_initDStream`, `ZSTD_decompressDCtx()`, `ZSTD_decompress_usingDict()`)
    pub fn ZSTD_decompressStream(
        zds: *mut ZSTD_DStream,
        output: *mut ZSTD_outBuffer,
        input: *mut ZSTD_inBuffer,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_DStreamInSize() -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_DStreamOutSize() -> usize;
}
unsafe extern "C" {
    ///  Simple dictionary API
    ////
    ////*! ZSTD_compress_usingDict() :
    ///  Compression at an explicit compression level using a Dictionary.
    ///  A dictionary can be any arbitrary data segment (also called a prefix),
    ///  or a buffer with specified information (see zdict.h).
    ///  Note : This function loads the dictionary, resulting in significant startup delay.
    ///         It's intended for a dictionary used only once.
    ///  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used.
    pub fn ZSTD_compress_usingDict(
        ctx: *mut ZSTD_CCtx,
        dst: *mut ::core::ffi::c_void,
        dstCapacity: usize,
        src: *const ::core::ffi::c_void,
        srcSize: usize,
        dict: *const ::core::ffi::c_void,
        dictSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -> usize;
}
unsafe extern "C" {
    /// ZSTD_decompress_usingDict() :
    ///  Decompression using a known Dictionary.
    ///  Dictionary must be identical to the one used during compression.
    ///  Note : This function loads the dictionary, resulting in significant startup delay.
    ///         It's intended for a dictionary used only once.
    ///  Note : When `dict == NULL || dictSize < 8` no dictionary is used.
    pub fn ZSTD_decompress_usingDict(
        dctx: *mut ZSTD_DCtx,
        dst: *mut ::core::ffi::c_void,
        dstCapacity: usize,
        src: *const ::core::ffi::c_void,
        srcSize: usize,
        dict: *const ::core::ffi::c_void,
        dictSize: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CDict_s {
    _unused: [u8; 0],
}
///  Bulk processing dictionary API
pub type ZSTD_CDict = ZSTD_CDict_s;
unsafe extern "C" {
    /// ZSTD_createCDict() :
    ///  When compressing multiple messages or blocks using the same dictionary,
    ///  it's recommended to digest the dictionary only once, since it's a costly operation.
    ///  ZSTD_createCDict() will create a state from digesting a dictionary.
    ///  The resulting state can be used for future compression operations with very limited startup cost.
    ///  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
    /// @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict.
    ///  Note 1 : Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate @dictBuffer content.
    ///  Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer,
    ///      in which case the only thing that it transports is the @compressionLevel.
    ///      This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively,
    ///      expecting a ZSTD_CDict parameter with any data, including those without a known dictionary.
    pub fn ZSTD_createCDict(
        dictBuffer: *const ::core::ffi::c_void,
        dictSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -> *mut ZSTD_CDict;
}
unsafe extern "C" {
    /// ZSTD_freeCDict() :
    ///  Function frees memory allocated by ZSTD_createCDict().
    ///  If a NULL pointer is passed, no operation is performed.
    pub fn ZSTD_freeCDict(CDict: *mut ZSTD_CDict) -> usize;
}
unsafe extern "C" {
    /// ZSTD_compress_usingCDict() :
    ///  Compression using a digested Dictionary.
    ///  Recommended when same dictionary is used multiple times.
    ///  Note : compression level is _decided at dictionary creation time_,
    ///     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)
    pub fn ZSTD_compress_usingCDict(
        cctx: *mut ZSTD_CCtx,
        dst: *mut ::core::ffi::c_void,
        dstCapacity: usize,
        src: *const ::core::ffi::c_void,
        srcSize: usize,
        cdict: *const ZSTD_CDict,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DDict_s {
    _unused: [u8; 0],
}
pub type ZSTD_DDict = ZSTD_DDict_s;
unsafe extern "C" {
    /// ZSTD_createDDict() :
    ///  Create a digested dictionary, ready to start decompression operation without startup delay.
    ///  dictBuffer can be released after DDict creation, as its content is copied inside DDict.
    pub fn ZSTD_createDDict(
        dictBuffer: *const ::core::ffi::c_void,
        dictSize: usize,
    ) -> *mut ZSTD_DDict;
}
unsafe extern "C" {
    /// ZSTD_freeDDict() :
    ///  Function frees memory allocated with ZSTD_createDDict()
    ///  If a NULL pointer is passed, no operation is performed.
    pub fn ZSTD_freeDDict(ddict: *mut ZSTD_DDict) -> usize;
}
unsafe extern "C" {
    /// ZSTD_decompress_usingDDict() :
    ///  Decompression using a digested Dictionary.
    ///  Recommended when same dictionary is used multiple times.
    pub fn ZSTD_decompress_usingDDict(
        dctx: *mut ZSTD_DCtx,
        dst: *mut ::core::ffi::c_void,
        dstCapacity: usize,
        src: *const ::core::ffi::c_void,
        srcSize: usize,
        ddict: *const ZSTD_DDict,
    ) -> usize;
}
unsafe extern "C" {
    /// ZSTD_getDictID_fromDict() : Requires v1.4.0+
    ///  Provides the dictID stored within dictionary.
    ///  if @return == 0, the dictionary is not conformant with Zstandard specification.
    ///  It can still be loaded, but as a content-only dictionary.
    pub fn ZSTD_getDictID_fromDict(
        dict: *const ::core::ffi::c_void,
        dictSize: usize,
    ) -> ::core::ffi::c_uint;
}
unsafe extern "C" {
    /// ZSTD_getDictID_fromCDict() : Requires v1.5.0+
    ///  Provides the dictID of the dictionary loaded into `cdict`.
    ///  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
    ///  Non-conformant dictionaries can still be loaded, but as content-only dictionaries.
    pub fn ZSTD_getDictID_fromCDict(cdict: *const ZSTD_CDict) -> ::core::ffi::c_uint;
}
unsafe extern "C" {
    /// ZSTD_getDictID_fromDDict() : Requires v1.4.0+
    ///  Provides the dictID of the dictionary loaded into `ddict`.
    ///  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
    ///  Non-conformant dictionaries can still be loaded, but as content-only dictionaries.
    pub fn ZSTD_getDictID_fromDDict(ddict: *const ZSTD_DDict) -> ::core::ffi::c_uint;
}
unsafe extern "C" {
    /// ZSTD_getDictID_fromFrame() : Requires v1.4.0+
    ///  Provides the dictID required to decompressed the frame stored within `src`.
    ///  If @return == 0, the dictID could not be decoded.
    ///  This could for one of the following reasons :
    ///  - The frame does not require a dictionary to be decoded (most common case).
    ///  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden piece of information.
    ///    Note : this use case also happens when using a non-conformant dictionary.
    ///  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`).
    ///  - This is not a Zstandard frame.
    ///  When identifying the exact failure cause, it's possible to use ZSTD_getFrameHeader(), which will provide a more precise error code.
    pub fn ZSTD_getDictID_fromFrame(
        src: *const ::core::ffi::c_void,
        srcSize: usize,
    ) -> ::core::ffi::c_uint;
}
unsafe extern "C" {
    /// ZSTD_CCtx_loadDictionary() : Requires v1.4.0+
    ///  Create an internal CDict from `dict` buffer.
    ///  Decompression will have to use same dictionary.
    /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
    ///  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,
    ///           meaning "return to no-dictionary mode".
    ///  Note 1 : Dictionary is sticky, it will be used for all future compressed frames,
    ///           until parameters are reset, a new dictionary is loaded, or the dictionary
    ///           is explicitly invalidated by loading a NULL dictionary.
    ///  Note 2 : Loading a dictionary involves building tables.
    ///           It's also a CPU consuming operation, with non-negligible impact on latency.
    ///           Tables are dependent on compression parameters, and for this reason,
    ///           compression parameters can no longer be changed after loading a dictionary.
    ///  Note 3 :`dict` content will be copied internally.
    ///           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead.
    ///           In such a case, dictionary buffer must outlive its users.
    ///  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()
    ///           to precisely select how dictionary content must be interpreted.
    ///  Note 5 : This method does not benefit from LDM (long distance mode).
    ///           If you want to employ LDM on some large dictionary content,
    ///           prefer employing ZSTD_CCtx_refPrefix() described below.
    pub fn ZSTD_CCtx_loadDictionary(
        cctx: *mut ZSTD_CCtx,
        dict: *const ::core::ffi::c_void,
        dictSize: usize,
    ) -> usize;
}
unsafe extern "C" {
    /// ZSTD_CCtx_refCDict() : Requires v1.4.0+
    ///  Reference a prepared dictionary, to be used for all future compressed frames.
    ///  Note that compression parameters are enforced from within CDict,
    ///  and supersede any compression parameter previously set within CCtx.
    ///  The parameters ignored are labelled as "superseded-by-cdict" in the ZSTD_cParameter enum docs.
    ///  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode.
    ///  The dictionary will remain valid for future compressed frames using same CCtx.
    /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
    ///  Special : Referencing a NULL CDict means "return to no-dictionary mode".
    ///  Note 1 : Currently, only one dictionary can be managed.
    ///           Referencing a new dictionary effectively "discards" any previous one.
    ///  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx.
    pub fn ZSTD_CCtx_refCDict(cctx: *mut ZSTD_CCtx, cdict: *const ZSTD_CDict) -> usize;
}
unsafe extern "C" {
    /// ZSTD_CCtx_refPrefix() : Requires v1.4.0+
    ///  Reference a prefix (single-usage dictionary) for next compressed frame.
    ///  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end).
    ///  Decompression will need same prefix to properly regenerate data.
    ///  Compressing with a prefix is similar in outcome as performing a diff and compressing it,
    ///  but performs much faster, especially during decompression (compression speed is tunable with compression level).
    ///  This method is compatible with LDM (long distance mode).
    /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
    ///  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary
    ///  Note 1 : Prefix buffer is referenced. It **must** outlive compression.
    ///           Its content must remain unmodified during compression.
    ///  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,
    ///           ensure that the window size is large enough to contain the entire source.
    ///           See ZSTD_c_windowLog.
    ///  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters.
    ///           It's a CPU consuming operation, with non-negligible impact on latency.
    ///           If there is a need to use the same prefix multiple times, consider loadDictionary instead.
    ///  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent).
    ///           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation.
    pub fn ZSTD_CCtx_refPrefix(
        cctx: *mut ZSTD_CCtx,
        prefix: *const ::core::ffi::c_void,
        prefixSize: usize,
    ) -> usize;
}
unsafe extern "C" {
    /// ZSTD_DCtx_loadDictionary() : Requires v1.4.0+
    ///  Create an internal DDict from dict buffer, to be used to decompress all future frames.
    ///  The dictionary remains valid for all future frames, until explicitly invalidated, or
    ///  a new dictionary is loaded.
    /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
    ///  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,
    ///            meaning "return to no-dictionary mode".
    ///  Note 1 : Loading a dictionary involves building tables,
    ///           which has a non-negligible impact on CPU usage and latency.
    ///           It's recommended to "load once, use many times", to amortize the cost
    ///  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading.
    ///           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead.
    ///  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of
    ///           how dictionary content is loaded and interpreted.
    pub fn ZSTD_DCtx_loadDictionary(
        dctx: *mut ZSTD_DCtx,
        dict: *const ::core::ffi::c_void,
        dictSize: usize,
    ) -> usize;
}
unsafe extern "C" {
    /// ZSTD_DCtx_refDDict() : Requires v1.4.0+
    ///  Reference a prepared dictionary, to be used to decompress next frames.
    ///  The dictionary remains active for decompression of future frames using same DCtx.
    ///
    ///  If called with ZSTD_d_refMultipleDDicts enabled, repeated calls of this function
    ///  will store the DDict references in a table, and the DDict used for decompression
    ///  will be determined at decompression time, as per the dict ID in the frame.
    ///  The memory for the table is allocated on the first call to refDDict, and can be
    ///  freed with ZSTD_freeDCtx().
    ///
    ///  If called with ZSTD_d_refMultipleDDicts disabled (the default), only one dictionary
    ///  will be managed, and referencing a dictionary effectively "discards" any previous one.
    ///
    /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
    ///  Special: referencing a NULL DDict means "return to no-dictionary mode".
    ///  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx.
    pub fn ZSTD_DCtx_refDDict(dctx: *mut ZSTD_DCtx, ddict: *const ZSTD_DDict) -> usize;
}
unsafe extern "C" {
    /// ZSTD_DCtx_refPrefix() : Requires v1.4.0+
    ///  Reference a prefix (single-usage dictionary) to decompress next frame.
    ///  This is the reverse operation of ZSTD_CCtx_refPrefix(),
    ///  and must use the same prefix as the one used during compression.
    ///  Prefix is **only used once**. Reference is discarded at end of frame.
    ///  End of frame is reached when ZSTD_decompressStream() returns 0.
    /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
    ///  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary
    ///  Note 2 : Prefix buffer is referenced. It **must** outlive decompression.
    ///           Prefix buffer must remain unmodified up to the end of frame,
    ///           reached when ZSTD_decompressStream() returns 0.
    ///  Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent).
    ///           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)
    ///  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost.
    ///           A full dictionary is more costly, as it requires building tables.
    pub fn ZSTD_DCtx_refPrefix(
        dctx: *mut ZSTD_DCtx,
        prefix: *const ::core::ffi::c_void,
        prefixSize: usize,
    ) -> usize;
}
unsafe extern "C" {
    /// ZSTD_sizeof_*() : Requires v1.4.0+
    ///  These functions give the _current_ memory usage of selected object.
    ///  Note that object memory usage can evolve (increase or decrease) over time.
    pub fn ZSTD_sizeof_CCtx(cctx: *const ZSTD_CCtx) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_sizeof_DCtx(dctx: *const ZSTD_DCtx) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_sizeof_CStream(zcs: *const ZSTD_CStream) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_sizeof_DStream(zds: *const ZSTD_DStream) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_sizeof_CDict(cdict: *const ZSTD_CDict) -> usize;
}
unsafe extern "C" {
    pub fn ZSTD_sizeof_DDict(ddict: *const ZSTD_DDict) -> usize;
}
