# Copyright 2024 The Fuchsia Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components/fuchsia_package.gni")
import("//build/dist/renamed_binary.gni")
import("//build/toolchain/ifs_extract.gni")

# Defines a Fuchsia package containing a Trusted Application
#
# Example:
# ```
# fuchsia_ta_package("echo") {
#   sources = [
#     "ta_source_file.cc",
#   ]
#   deps = [
#     "//path/to/library/used/by/ta",
#   ]
# }
# ```
#
# Parameters
#
#    sources (list)
#      Source files for the Trusted Application.
#
#    deps (optional)
#      Dependencies of the Trusted Application.
template("fuchsia_ta_package") {
  main_target = target_name
  module_target = "_${target_name}_module"
  ifs_target = "_${target_name}_ifs"
  ta_name_resource_target = "_${target_name}_resource"
  ta_props_resource_target = "_${target_name}_props_resource"

  forward_variables_from(invoker, [ "props_file" ])
  if (!defined(props_file)) {
    props_file = "//src/tee/ta/config/ta_properties_template.json5"
  }

  loadable_module(module_target) {
    output_name = main_target
    visibility = [ ":*" ]
    deps = []
    forward_variables_from(invoker,
                           "*",
                           [
                             "configs",
                             "visibility",
                           ])
    deps += [ "//src/tee/tee_internal_api" ]
    if (defined(invoker.configs)) {
      configs += invoker.configs
    }
  }

  # An .ifs file describing the symbols defined and needed by the TA. This file
  # is of use in build-time verification that a TA's expected public symbols
  # are indeed defined (TODO(joshuaseaton) for its consumption to that effect),
  # as well as of diagnostic value in seeing what subset of the TEE internal
  # API is being used by a particular TA (especially during 'bring-up').
  ifs_extract(ifs_target) {
    visibility = [ ":*" ]
    outputs = [ "$target_out_dir/$main_target.ifs" ]
    deps = [ ":$module_target" ]
  }

  # This adds a file to the package containing the name of the TA at a
  # well-known location so that the runtime knows where in the package the TA is
  # to load. There are a few other ways we could factor this if needed:
  # *) We could require that the package name correspond to the TA name and use that
  # *) We could place the TA name inside a manifest (perhaps even a component manifest)
  #    and use that
  # *) An external index could provide the TA name along with other data, such as its
  #    UUID.
  resource(ta_name_resource_target) {
    ta_name_file = "${target_gen_dir}/${main_target}"
    write_file(ta_name_file, main_target)
    sources = [ ta_name_file ]
    outputs = [ "data/ta_name" ]
  }

  # This file describes TA-specific properties, whose values may be queried by the
  # Property set of internal core APIs.
  # TODO(b/366486931): Build-time validation for this TA properties file.
  resource(ta_props_resource_target) {
    sources = [ "${props_file}" ]
    outputs = [ "data/ta_properties" ]
  }

  fuchsia_package(main_target) {
    forward_variables_from(invoker, [ "visibility" ])
    deps = [
      ":${module_target}",
      ":${ta_name_resource_target}",
      ":${ta_props_resource_target}",
      "//src/tee/runtime:runtime-component",
    ]

    # Not a really a dependency of the package itself, but we need somewhere to
    # include this into the build graph and other package-related GN code
    # unfortunately expects target_name to expand to a package target.
    data_deps = [ ":${ifs_target}" ]
  }
}
