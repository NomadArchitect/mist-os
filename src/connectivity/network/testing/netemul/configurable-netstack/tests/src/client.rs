// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![cfg(test)]

use assert_matches::assert_matches;
use configurable_netstack_test::{server_ips, BUS_NAME, REQUEST, RESPONSE, SERVER_NAME};
use fuchsia_component::client::connect_to_protocol;
use futures_util::StreamExt as _;
use net_declare::{fidl_mac, net_ip_v4};
use net_types::ip::Ipv4;
use std::collections::HashMap;
use std::io::{Read as _, Write as _};
use std::pin::pin;
use test_case::test_case;
use {
    fidl_fuchsia_net as fnet, fidl_fuchsia_net_interfaces as fnet_interfaces,
    fidl_fuchsia_net_interfaces_admin as fnet_interfaces_admin,
    fidl_fuchsia_net_interfaces_ext as fnet_interfaces_ext, fidl_fuchsia_net_root as fnet_root,
    fidl_fuchsia_net_routes as fnet_routes, fidl_fuchsia_net_routes_ext as fnet_routes_ext,
};

pub const CLIENT_NAME: &str = "client";

#[fuchsia_async::run_singlethreaded(test)]
async fn connect_to_server() {
    netemul_sync::Bus::subscribe(BUS_NAME, CLIENT_NAME)
        .expect("subscribe to bus")
        .wait_for_client(SERVER_NAME)
        .await
        .expect("wait for server to join bus");

    for addr in server_ips() {
        let mut stream = std::net::TcpStream::connect(&addr).expect("connect to server");
        let request = REQUEST.as_bytes();
        assert_eq!(stream.write(request).expect("write to socket"), request.len());
        stream.flush().expect("flush stream");

        let mut buffer = [0; 512];
        let read = stream.read(&mut buffer).expect("read from socket");
        let response = String::from_utf8_lossy(&buffer[0..read]);
        assert_eq!(response, RESPONSE, "got unexpected response from server: {}", response);
    }
}

const MAC_ADDR: fnet::MacAddress = fidl_mac!("00:00:00:00:00:01");

#[fuchsia_async::run_singlethreaded(test)]
async fn without_autogenerated_addresses() {
    let state = connect_to_protocol::<fnet_interfaces::StateMarker>().expect("connect to protocol");
    let stream =
        fnet_interfaces_ext::event_stream_from_state::<fnet_interfaces_ext::DefaultInterest>(
            &state,
            fnet_interfaces_ext::IncludedAddresses::OnlyAssigned,
        )
        .expect("event stream from interfaces state");
    let interfaces = fnet_interfaces_ext::existing(
        stream,
        HashMap::<u64, fnet_interfaces_ext::PropertiesAndState<(), _>>::new(),
    )
    .await
    .expect("list existing interfaces")
    .into_values();
    let root = connect_to_protocol::<fnet_root::InterfacesMarker>().expect("connect to protocol");

    // Find the interface that corresponds to `MAC_ADDR` by querying
    // `fuchsia.net.root/Interfaces.GetMac` with the ID of each existing interface.
    //
    // Once we've found the matching interface, retrieve its IPv4 and link-local
    // IPv6 addresses to ensure any auto-generated addresses were removed by the
    // netemul runner during test setup.
    let mut addresses = pin!(futures_util::stream::iter(interfaces).filter_map(
        |fnet_interfaces_ext::PropertiesAndState {
             properties: fnet_interfaces_ext::Properties { id, addresses, .. },
             state: _,
         }| {
            let root = &root;
            async move {
                match root.get_mac(id.get()).await.expect("get mac") {
                    Err(fnet_root::InterfacesGetMacError::NotFound) => None,
                    Ok(mac_address) => {
                        let mac_address = mac_address.expect("mac address not set");
                        (mac_address.octets == MAC_ADDR.octets).then(|| addresses)
                    }
                }
            }
        },
    ));
    let addresses = addresses
        .next()
        .await
        .expect("could not find interface")
        .into_iter()
        .filter_map(
            |fnet_interfaces_ext::Address {
                 addr: fnet::Subnet { addr, prefix_len: _ },
                 valid_until: _,
                 preferred_lifetime_info: _,
                 assignment_state,
             }| {
                assert_eq!(assignment_state, fnet_interfaces::AddressAssignmentState::Assigned);

                match addr {
                    ip_addr @ fnet::IpAddress::Ipv4(_) => Some(ip_addr),
                    ip_addr @ fnet::IpAddress::Ipv6(fnet::Ipv6Address { addr }) => {
                        let v6_addr = net_types::ip::Ipv6Addr::from_bytes(addr);
                        v6_addr.is_unicast_link_local().then(|| ip_addr)
                    }
                }
            },
        )
        .collect::<Vec<_>>();
    assert_eq!(addresses, vec![], "found unexpected addresses on interface");
}

const GATEWAY: net_types::ip::Ipv4Addr = net_ip_v4!("192.168.0.1");

#[fuchsia_async::run_singlethreaded(test)]
async fn default_gateway() {
    let ipv4_routing_table = {
        let state_v4 =
            connect_to_protocol::<fnet_routes::StateV4Marker>().expect("connect to protocol");
        let stream = fnet_routes_ext::event_stream_from_state::<Ipv4>(&state_v4)
            .expect("failed to connect to watcher");
        let stream = pin!(stream);
        fnet_routes_ext::collect_routes_until_idle::<_, Vec<_>>(stream)
            .await
            .expect("failed to get routing table")
    };
    let found = ipv4_routing_table.iter().any(
        |fnet_routes_ext::InstalledRoute {
             route: fnet_routes_ext::Route { destination, action, properties: _ },
             effective_properties: _,
             table_id: _,
         }| {
            match action {
                fnet_routes_ext::RouteAction::Forward(fnet_routes_ext::RouteTarget {
                    outbound_interface: _,
                    next_hop,
                }) => next_hop
                    // NB: Because destination is a `net_types::ip::Subnet`, a
                    // `prefix` of 0 ensures the `network` is unspecified.
                    .map(|next_hop| *next_hop == GATEWAY && destination.prefix() == 0)
                    .unwrap_or(false),
                fnet_routes_ext::RouteAction::Unknown => panic!("route with unknown action"),
            }
        },
    );
    assert!(found, "could not find default route to gateway {:?}", GATEWAY);
}

/// Return the ID of the interface with the given MAC.
///
/// Connects to fuchsia.net.interfaces/State and searches the set of existing
/// interfaces for one that has the given MAC.
async fn get_interface_with_mac(mac: fnet::MacAddress) -> fnet::InterfaceId {
    let state = connect_to_protocol::<fnet_interfaces::StateMarker>().expect("connect to protocol");
    let stream =
        fnet_interfaces_ext::event_stream_from_state::<fnet_interfaces_ext::DefaultInterest>(
            &state,
            fnet_interfaces_ext::IncludedAddresses::OnlyAssigned,
        )
        .expect("event stream from interfaces state");
    let interfaces = fnet_interfaces_ext::existing(
        stream,
        HashMap::<u64, fnet_interfaces_ext::PropertiesAndState<(), _>>::new(),
    )
    .await
    .expect("list existing interfaces")
    .into_keys();
    let root = connect_to_protocol::<fnet_root::InterfacesMarker>().expect("connect to protocol");

    // Find the interface that corresponds to `interface_mac_address` by querying
    // `fuchsia.net.root/Interfaces.GetMac` with the ID of each existing interface.
    let mut matching_interface = pin!(futures_util::stream::iter(interfaces).filter_map(|id| {
        let root = &root;
        async move {
            match root.get_mac(id).await.expect("get mac") {
                Err(fnet_root::InterfacesGetMacError::NotFound) => None,
                Ok(mac_address) => {
                    let mac_address = mac_address.expect("mac address not set");
                    (mac_address.octets == mac.octets).then(|| id)
                }
            }
        }
    }));
    matching_interface.next().await.expect("could not find interface")
}

/// Retrieves the configuration for the given interface.
async fn get_interface_config(id: fnet::InterfaceId) -> fnet_interfaces_admin::Configuration {
    let root = connect_to_protocol::<fnet_root::InterfacesMarker>().expect("connect to protocol");
    let (control, server_end) =
        fnet_interfaces_ext::admin::Control::create_endpoints().expect("create endpoints");
    root.get_admin(id, server_end).expect("get control handle to interface");

    control
        .get_configuration()
        .await
        .expect("call get configuration")
        .expect("get interface configuration")
}

const IPV4_FWD_ENABLED_MAC_ADDR: fnet::MacAddress = fidl_mac!("00:00:00:00:00:02");
const IPV6_FWD_ENABLED_MAC_ADDR: fnet::MacAddress = fidl_mac!("00:00:00:00:00:03");

#[test_case(
    IPV4_FWD_ENABLED_MAC_ADDR,
    true,
    false;
    "interface with IPv4 forwarding enabled"
)]
#[test_case(
    IPV6_FWD_ENABLED_MAC_ADDR,
    false,
    true;
    "interface with IPv6 forwarding enabled"
)]
#[fuchsia_async::run_singlethreaded(test)]
async fn enable_forwarding(
    interface_mac_address: fnet::MacAddress,
    expected_ipv4_forwarding: bool,
    expected_ipv6_forwarding: bool,
) {
    let id = get_interface_with_mac(interface_mac_address).await;
    let fnet_interfaces_admin::Configuration { ipv4, ipv6, .. } = get_interface_config(id).await;
    let fnet_interfaces_admin::Ipv4Configuration { unicast_forwarding: ipv4_forwarding, .. } =
        ipv4.expect("extract ipv4 configuration");
    let fnet_interfaces_admin::Ipv6Configuration { unicast_forwarding: ipv6_forwarding, .. } =
        ipv6.expect("extract ipv6 configuration");
    assert_eq!(ipv4_forwarding, Some(expected_ipv4_forwarding));
    assert_eq!(ipv6_forwarding, Some(expected_ipv6_forwarding));
}

// The MAC addresses of the interfaces that are expected to have their maximum
// number of multicast neighbor solicitations configured.
const IPV4_NEIGHBOR_SOLICITS_CONFIGURED_ADDR: fnet::MacAddress = fidl_mac!("00:00:00:00:00:04");
const IPV6_NEIGHBOR_SOLICITS_CONFIGURED_ADDR: fnet::MacAddress = fidl_mac!("00:00:00:00:00:05");

// The number of solicitations configured on the above interfaces. Notably, this
// value differs from the default number of solicitations (3).
const NUM_SOLICITS: u16 = 100;

#[test_case(
    IPV4_NEIGHBOR_SOLICITS_CONFIGURED_ADDR,
    true,
    false;
    "interface with IPv4 neighbor solicitations configured"
)]
#[test_case(
    IPV6_NEIGHBOR_SOLICITS_CONFIGURED_ADDR,
    false,
    true;
    "interface with IPv6 neighbor solicitations configured"
)]
#[fuchsia_async::run_singlethreaded(test)]
async fn configure_multicast_neighbor_solicitations(
    interface_mac_address: fnet::MacAddress,
    expected_ipv4_neighbor_solicits_configured: bool,
    expected_ipv6_neighbor_solicits_configured: bool,
) {
    let id = get_interface_with_mac(interface_mac_address).await;
    let fnet_interfaces_admin::Configuration { ipv4, ipv6, .. } = get_interface_config(id).await;

    let ipv4_solicitations = assert_matches!(
        ipv4,
        Some(fnet_interfaces_admin::Ipv4Configuration {
            arp: Some(fnet_interfaces_admin::ArpConfiguration {
                nud: Some(fnet_interfaces_admin::NudConfiguration{
                    max_multicast_solicitations: Some(max_solicits),
                    ..
                }),
                ..
            }),
            ..
        })
        => max_solicits
    );
    if expected_ipv4_neighbor_solicits_configured {
        assert_eq!(ipv4_solicitations, NUM_SOLICITS);
    } else {
        assert_ne!(ipv4_solicitations, NUM_SOLICITS);
    }

    let ipv6_solicitations = assert_matches!(
        ipv6,
        Some(fnet_interfaces_admin::Ipv6Configuration {
            ndp: Some(fnet_interfaces_admin::NdpConfiguration {
                nud: Some(fnet_interfaces_admin::NudConfiguration{
                    max_multicast_solicitations: Some(max_solicits),
                    ..
                }),
                ..
            }),
            ..
        })
        => max_solicits
    );
    if expected_ipv6_neighbor_solicits_configured {
        assert_eq!(ipv6_solicitations, NUM_SOLICITS);
    } else {
        assert_ne!(ipv6_solicitations, NUM_SOLICITS);
    }
}
