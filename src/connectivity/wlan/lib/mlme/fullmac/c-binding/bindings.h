// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_CONNECTIVITY_WLAN_LIB_MLME_FULLMAC_C_BINDING_BINDINGS_H_
#define SRC_CONNECTIVITY_WLAN_LIB_MLME_FULLMAC_C_BINDING_BINDINGS_H_

// Warning:
// This file was autogenerated by cbindgen.
// Do not modify this file manually.

#include <fuchsia/wlan/fullmac/c/banjo.h>
#include <fuchsia/wlan/ieee80211/c/banjo.h>
#include <fuchsia/wlan/internal/c/banjo.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef struct wlan_fullmac_mlme_handle_t wlan_fullmac_mlme_handle_t;

typedef struct {
  void (*on_scan_result)(void *ctx, const wlan_fullmac_scan_result_t *result);
  void (*on_scan_end)(void *ctx, const wlan_fullmac_scan_end_t *end);
  void (*connect_conf)(void *ctx, const wlan_fullmac_connect_confirm_t *resp);
  void (*roam_start_ind)(void *ctx, const uint8_t *selected_bssid,
                         const bss_description_t *selected_bss,
                         bool original_association_maintained);
  void (*roam_result_ind)(void *ctx, const uint8_t *selected_bssid, status_code_t status_code,
                          bool original_association_maintained, bool target_bss_authenticated,
                          uint16_t association_id, const uint8_t *association_ies_list,
                          uintptr_t association_ies_count);
  void (*auth_ind)(void *ctx, const wlan_fullmac_auth_ind_t *ind);
  void (*deauth_conf)(void *ctx, const uint8_t *peer_sta_address);
  void (*deauth_ind)(void *ctx, const wlan_fullmac_deauth_indication_t *ind);
  void (*assoc_ind)(void *ctx, const wlan_fullmac_assoc_ind_t *ind);
  void (*disassoc_conf)(void *ctx, const wlan_fullmac_disassoc_confirm_t *resp);
  void (*disassoc_ind)(void *ctx, const wlan_fullmac_disassoc_indication_t *ind);
  void (*start_conf)(void *ctx, const wlan_fullmac_start_confirm_t *resp);
  void (*stop_conf)(void *ctx, const wlan_fullmac_stop_confirm_t *resp);
  void (*eapol_conf)(void *ctx, const wlan_fullmac_eapol_confirm_t *resp);
  void (*on_channel_switch)(void *ctx, const wlan_fullmac_channel_switch_info_t *resp);
  void (*signal_report)(void *ctx, const wlan_fullmac_signal_report_indication_t *ind);
  void (*eapol_ind)(void *ctx, const wlan_fullmac_eapol_indication_t *ind);
  void (*on_pmk_available)(void *ctx, const wlan_fullmac_pmk_info_t *info);
  void (*sae_handshake_ind)(void *ctx, const wlan_fullmac_sae_handshake_ind_t *ind);
  void (*sae_frame_rx)(void *ctx, const wlan_fullmac_sae_frame_t *frame);
  void (*on_wmm_status_resp)(void *ctx, zx_status_t status,
                             const wlan_wmm_parameters_t *wmm_params);
} rust_wlan_fullmac_ifc_protocol_ops_copy_t;

/**
 * Hand-rolled Rust version of the banjo wlan_fullmac_ifc_protocol for communication from the
 * driver up.
 * Note that we copy the individual fns out of this struct into the equivalent generated struct
 * in C++. Thanks to cbindgen, this gives us a compile-time confirmation that our function
 * signatures are correct.
 */
typedef struct {
  const rust_wlan_fullmac_ifc_protocol_ops_copy_t *ops;
  void *ctx;
} rust_wlan_fullmac_ifc_protocol_copy_t;

/**
 * A `RawFullmacDeviceFfi` allows transmitting MLME messages.
 */
typedef struct {
  void *device;
  /**
   * Start operations on the underlying device and return the SME channel.
   */
  zx_status_t (*start_fullmac_ifc_server)(void *device,
                                          const rust_wlan_fullmac_ifc_protocol_copy_t *ifc,
                                          zx_handle_t fullmac_ifc_server_end_handle);
} rust_fullmac_device_ffi_t;

extern "C" wlan_fullmac_mlme_handle_t *start_fullmac_mlme(rust_fullmac_device_ffi_t raw_device,
                                                          zx_handle_t fullmac_client_end_handle);

extern "C" void stop_fullmac_mlme(wlan_fullmac_mlme_handle_t *mlme);

/**
 * FFI interface: Stop and delete a FullMAC MLME via the FullmacMlmeHandle. Takes ownership
 * and invalidates the passed FullmacMlmeHandle.
 *
 * # Safety
 *
 * This fn accepts a raw pointer that is held by the FFI caller as a handle to
 * the MLME. This API is fundamentally unsafe, and relies on the caller to
 * pass the correct pointer and make no further calls on it later.
 */
extern "C" void delete_fullmac_mlme(wlan_fullmac_mlme_handle_t *mlme);

#endif  // SRC_CONNECTIVITY_WLAN_LIB_MLME_FULLMAC_C_BINDING_BINDINGS_H_
