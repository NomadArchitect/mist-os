// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_
#define SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_

// Warning:
// This file was autogenerated by cbindgen.
// Do not modify this file manually.

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <zircon/types.h>

typedef struct {
  void *ctx;
  /**
   * Sends an Ethernet frame to the C++ portion of wlansoftmac.
   *
   * # Safety
   *
   * Behavior is undefined unless `payload` contains a persisted `EthernetRx.Transfer` request
   * and `payload_len` is the length of the persisted byte array.
   */
  zx_status_t (*transfer)(void *ctx, const uint8_t *payload, uintptr_t payload_len);
} ethernet_rx_t;

typedef struct {
  void *ctx;
  /**
   * Sends a WLAN MAC frame to the C++ portion of wlansoftmac.
   *
   * # Safety
   *
   * Behavior is undefined unless `payload` contains a persisted `WlanTx.Transfer` request
   * and `payload_len` is the length of the persisted byte array.
   */
  zx_status_t (*transfer)(void *ctx, const uint8_t *payload, uintptr_t payload_len);
} wlan_tx_t;

typedef struct {
  const void *ctx;
  zx_status_t (*transfer)(const void *ctx, const uint8_t *request, uintptr_t request_size);
} ethernet_tx_t;

typedef struct {
  const void *ctx;
  void (*transfer)(const void *ctx, const uint8_t *request, uintptr_t request_size);
} wlan_rx_t;

/**
 * Start and run a bridged wlansoftmac driver hosting an MLME server and an SME server.
 *
 * The driver is "bridged" in the sense that it requires a bridge to a Fuchsia driver to
 * communicate with other Fuchsia drivers over the FDF transport. After the bridged
 * driver starts successfully, `run_start_completer` will be called with `start_completer`.
 * If the bridged driver does not start successfully, this function will return a
 * non-`ZX_OK` status.
 *
 * This function returns `ZX_OK` only if shutdown completes successfully. A successful
 * shutdown only occurs if the bridged driver receives a
 * `fuchsia.wlan.softmac/WlanSoftmacIfcBridge.StopBridgedDriver` message and the subsequent
 * teardown of the hosted server succeeds.
 *
 * In all other scenarios, e.g., failure during startup, while running, or during shutdown,
 * this function will return a non-`ZX_OK` value.
 *
 * # Safety
 *
 * This function is unsafe for the following reasons:
 *
 *   - This function cannot guarantee `run_start_completer` is thread-safe.
 *   - This function cannot guarantee `start_completer` points to a valid object when
 *     `run_start_completer` is called.
 *   - This function cannot guarantee `run_shutdown_completer` is thread-safe.
 *   - This function cannot guarantee `shutdown_completer` points to a valid object when
 *     `run_shutdown_completer` is called.
 *   - This function cannot guarantee `wlan_softmac_bridge_client_handle` is a valid handle.
 *
 * By calling this function, the caller promises the following:
 *
 *   - The `run_start_completer` function is thread-safe.
 *   - The `start_completer` pointer will point to a valid object at least until
 *     `run_start_completer` is called.
 *   - The `run_shutdown_completer` function is thread-safe.
 *   - The `shutdown_completer` pointer will point to a valid object at least until
 *     `run_shutdown_completer` is called.
 *   - The `wlan_softmac_bridge_client_handle` is a valid handle.
 */
extern "C" zx_status_t start_bridged_wlansoftmac(
    void *start_completer, void (*run_start_completer)(void *start_completer, zx_status_t status),
    void *shutdown_completer,
    void (*run_shutdown_completer)(void *shutdown_completer, zx_status_t status),
    ethernet_rx_t ethernet_rx, wlan_tx_t wlan_tx, zx_handle_t wlan_softmac_bridge_client_handle);

#endif  // SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_
