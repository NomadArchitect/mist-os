// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package fuchsia.sensors;

import public "types.proto";

/* Fuchsia Sensor Data Proto File Format.

   The sensor data file format described below serializes sensor events to disk
   in a way which allows for disk IO and memory to be traded off at the time of
   playback.

   Size      - Description
   -----------------------
   uint64_t  - h_bytes: Size of the serialized DatasetHeader message to follow.
   h_bytes   - The serialized DatasetHeader message.

   uint64_t  - e_bytes_1: Size of the serialized RecordedSensorEvent message to
               follow.
   e_bytes_1 - A serialized RecordedSensorEvent message.

   uint64_t  - e_bytes_2: Size of the serialized RecordedSensorEvent message to
               follow.
   e_bytes_2 - A serialized RecordedSensorEvent message.

   ...

   uint64_t  - e_bytes_n: Size of the serialized RecordedSensorEvent message to
               follow.
   e_bytes_n - A serialized RecordedSensorEvent message.

   The events must be written in increasing chronological order such that each
   timestamp is greater than or equal to the previous.
*/

// The header for a sensor dataset file.
message DatasetHeader {
  // A name for the dataset.
  optional string name = 1;

  // Sensor descriptors for sensors in the dataset.
  repeated SensorInfo sensors = 2;
}

// A sensor event to be serialized into a dataset file.
message RecordedSensorEvent {
  // The sensor event.
  optional /*required*/ SensorEvent event = 1;

  // A receipt timestamp. This is the time the system received the sensor event,
  // as opposed to the event timestamp that was generated by the hardware and
  // corresponds to the physical measurement. This can be used as a presentation
  // timestamp during playback if one desires to simulate something other than
  // "ideal" sensor event timing.
  //
  // NOTE: Datasets recorded with buffering enabled (max reporting latency > 0)
  //       will effectively have that buffering "baked in" when played back
  //       using this value to generate the schedule.
  optional int64 receipt_timestamp = 2;
}
