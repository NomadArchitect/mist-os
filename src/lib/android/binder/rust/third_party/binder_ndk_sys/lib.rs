/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! Generated Rust bindings to libbinder_ndk

use std::error::Error;
use std::fmt;

mod bindings {
/* automatically generated by rust-bindgen 0.69.4 */

extern "C" {
    pub fn android_get_application_target_sdk_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_get_device_api_level() -> ::std::os::raw::c_int;
}
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __uid_t = __kernel_uid32_t;
pub type uid_t = __uid_t;
pub type __pid_t = __kernel_pid_t;
pub type pid_t = __pid_t;
extern "C" {
    pub fn __assert(
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
        __msg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert2(
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
        __function: *const ::std::os::raw::c_char,
        __msg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __errno() -> *mut ::std::os::raw::c_int;
}
#[doc = " One of the STATUS_* values.\n\n All unrecognized values are coerced into STATUS_UNKNOWN_ERROR."]
pub type binder_status_t = i32;
#[doc = " One of the EX_* enumerators.\n\n All unrecognized values are coerced into EX_TRANSACTION_FAILED.\n\n These exceptions values are used by the SDK for parcelables. Also see Parcel.java."]
pub type binder_exception_t = i32;
#[doc = " This is a helper class that encapsulates a standard way to keep track of and chain binder errors\n along with service specific errors.\n\n It is not required to be used in order to parcel/receive transactions, but it is required in\n order to be compatible with standard AIDL transactions since it is written as the header to the\n out parcel for transactions which get executed (don't fail during unparceling of input arguments\n or sooner)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AStatus {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " New status which is considered a success.\n\n Available since API level 29.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_newOk() -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with exception code.\n\n Available since API level 29.\n\n \\param exception the code that this status should represent. If this is EX_NONE, then this\n constructs an non-error status object.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromExceptionCode(exception: binder_exception_t) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with exception code and message.\n\n Available since API level 29.\n\n \\param exception the code that this status should represent. If this is EX_NONE, then this\n constructs an non-error status object.\n \\param message the error message to associate with this status object.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromExceptionCodeWithMessage(
        exception: binder_exception_t,
        message: *const ::std::os::raw::c_char,
    ) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with a service speciic error.\n\n This is considered to be EX_TRANSACTION_FAILED with extra information.\n\n Available since API level 29.\n\n \\param serviceSpecific an implementation defined error code.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromServiceSpecificError(serviceSpecific: i32) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with a service specific error and message.\n\n This is considered to be EX_TRANSACTION_FAILED with extra information.\n\n Available since API level 29.\n\n \\param serviceSpecific an implementation defined error code.\n \\param message the error message to associate with this status object.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromServiceSpecificErrorWithMessage(
        serviceSpecific: i32,
        message: *const ::std::os::raw::c_char,
    ) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with binder_status_t. This is typically for low level failures when a binder_status_t\n is returned by an API on AIBinder or AParcel, and that is to be returned from a method returning\n an AStatus instance. This is the least preferable way to return errors.\n Prefer exceptions (particularly service-specific errors) when possible.\n\n Available since API level 29.\n\n \\param status a low-level error to associate with this status object.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromStatus(status: binder_status_t) -> *mut AStatus;
}
extern "C" {
    #[doc = " Whether this object represents a successful transaction. If this function returns true, then\n AStatus_getExceptionCode will return EX_NONE.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return whether the status represents a successful transaction. For more details, see below."]
    pub fn AStatus_isOk(status: *const AStatus) -> bool;
}
extern "C" {
    #[doc = " The exception that this status object represents.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return the exception code that this object represents."]
    pub fn AStatus_getExceptionCode(status: *const AStatus) -> binder_exception_t;
}
extern "C" {
    #[doc = " The service specific error if this object represents one. This function will only ever return a\n non-zero result if AStatus_getExceptionCode returns EX_SERVICE_SPECIFIC. If this function returns\n 0, the status object may still represent a different exception or status. To find out if this\n transaction as a whole is okay, use AStatus_isOk instead.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return the service-specific error code if the exception code is EX_SERVICE_SPECIFIC or 0."]
    pub fn AStatus_getServiceSpecificError(status: *const AStatus) -> i32;
}
extern "C" {
    #[doc = " The status if this object represents one. This function will only ever return a non-zero result\n if AStatus_getExceptionCode returns EX_TRANSACTION_FAILED. If this function return 0, the status\n object may represent a different exception or a service specific error. To find out if this\n transaction as a whole is okay, use AStatus_isOk instead.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return the status code if the exception code is EX_TRANSACTION_FAILED or 0."]
    pub fn AStatus_getStatus(status: *const AStatus) -> binder_status_t;
}
extern "C" {
    #[doc = " If there is a message associated with this status, this will return that message. If there is no\n message, this will return an empty string.\n\n The returned string has the lifetime of the status object passed into this function.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return the message associated with this error."]
    pub fn AStatus_getMessage(status: *const AStatus) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get human-readable description for debugging.\n\n Available since API level 30.\n\n \\param status the status being queried.\n\n \\return a description, must be deleted with AStatus_deleteDescription."]
    pub fn AStatus_getDescription(status: *const AStatus) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Delete description.\n\n \\param description value from AStatus_getDescription"]
    pub fn AStatus_deleteDescription(description: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Deletes memory associated with the status instance.\n\n Available since API level 29.\n\n \\param status the status to delete, returned from AStatus_newOk or one of the AStatus_from* APIs."]
    pub fn AStatus_delete(status: *mut AStatus);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbstate_t {
    pub __seq: [::std::os::raw::c_uchar; 4usize],
    pub __reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mbstate_t>(),
        1usize,
        concat!("Alignment of ", stringify!(mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__seq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mbstate_t),
            "::",
            stringify!(__seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mbstate_t),
            "::",
            stringify!(__reserved)
        )
    );
}
extern "C" {
    pub fn c16rtomb(__buf: *mut ::std::os::raw::c_char, __ch16: u16, __ps: *mut mbstate_t)
        -> usize;
}
extern "C" {
    pub fn c32rtomb(__buf: *mut ::std::os::raw::c_char, __ch32: u32, __ps: *mut mbstate_t)
        -> usize;
}
extern "C" {
    pub fn mbrtoc16(
        __ch16: *mut u16,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbrtoc32(
        __ch32: *mut u32,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
#[doc = " Represents a local or remote object which can be used for IPC or which can itself be sent.\n\n This object has a refcount associated with it and will be deleted when its refcount reaches zero.\n How methods interactive with this refcount is described below. When using this API, it is\n intended for a client of a service to hold a strong reference to that service. This also means\n that user data typically should hold a strong reference to a local AIBinder object. A remote\n AIBinder object automatically holds a strong reference to the AIBinder object in the server's\n process. A typically memory layout looks like this:\n\n Key:\n   --->         Ownership/a strong reference\n   ...>         A weak reference\n\n                         (process boundary)\n                                 |\n MyInterface ---> AIBinder_Weak  |  ProxyForMyInterface\n      ^                .         |          |\n      |                .         |          |\n      |                v         |          v\n   UserData  <---   AIBinder   <-|-      AIBinder\n                                 |\n\n In this way, you'll notice that a proxy for the interface holds a strong reference to the\n implementation and that in the server process, the AIBinder object which was sent can be resent\n so that the same AIBinder object always represents the same object. This allows, for instance, an\n implementation (usually a callback) to transfer all ownership to a remote process and\n automatically be deleted when the remote process is done with it or dies. Other memory models are\n possible, but this is the standard one.\n\n If the process containing an AIBinder dies, it is possible to be holding a strong reference to\n an object which does not exist. In this case, transactions to this binder will return\n STATUS_DEAD_OBJECT. See also AIBinder_linkToDeath, AIBinder_unlinkToDeath, and AIBinder_isAlive.\n\n Once an AIBinder is created, anywhere it is passed (remotely or locally), there is a 1-1\n correspondence between the address of an AIBinder and the object it represents. This means that\n when two AIBinder pointers point to the same address, they represent the same object (whether\n that object is local or remote). This correspondance can be broken accidentally if AIBinder_new\n is erronesouly called to create the same object multiple times."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder {
    _unused: [u8; 0],
}
#[doc = " This object represents a package of data that can be sent between processes. When transacting, an\n instance of it is automatically created to be used for the transaction. When two processes use\n binder to communicate, they must agree on a format of this parcel to be used in order to transfer\n data. This is usually done in an IDL (see AIDL, specificially)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AParcel {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Cleans up a parcel.\n\n Available since API level 29.\n\n \\param parcel A parcel returned by AIBinder_prepareTransaction or AIBinder_transact when a\n transaction is being aborted."]
    pub fn AParcel_delete(parcel: *mut AParcel);
}
extern "C" {
    #[doc = " Sets the position within the parcel.\n\n This must be called with a position that has been previously returned from\n AParcel_getDataPosition. If writes are made after setting the data position, they must\n be made in the exact same sequence used before resetting data position. Writing over\n objects such as binders or file descriptors is not supported.\n\n Available since API level 29.\n\n \\param parcel The parcel of which to set the position.\n \\param position Position of the parcel to set. This must be a value returned by\n AParcel_getDataPosition. Positions are constant for a given parcel between processes.\n\n \\return STATUS_OK on success. If position is negative, then STATUS_BAD_VALUE will be returned."]
    pub fn AParcel_setDataPosition(parcel: *const AParcel, position: i32) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets the current position within the parcel.\n\n Available since API level 29.\n\n \\param parcel The parcel of which to get the position.\n\n \\return The size of the parcel. This will always be greater than 0. The values returned by this\n function before and after calling various reads and writes are not defined. Only the delta\n between two positions between a specific sequence of calls is defined. For instance, if position\n is X, writeBool is called, and then position is Y, readBool can be called from position X will\n return the same value, and then position will be Y."]
    pub fn AParcel_getDataPosition(parcel: *const AParcel) -> i32;
}
#[doc = " This is called to allocate a buffer for a C-style string (null-terminated). The returned buffer\n should be at least length bytes. This includes space for a null terminator. For a string, length\n will always be strictly less than or equal to the maximum size that can be held in a size_t and\n will always be greater than 0. However, if a 'null' string is being read, length will be -1.\n\n See also AParcel_readString.\n\n If allocation fails, null should be returned.\n\n \\param stringData some external representation of a string\n \\param length the length of the buffer needed to fill (including the null-terminator)\n \\param buffer a buffer of size 'length' or null if allocation failed.\n\n \\return true if the allocation succeeded, false otherwise. If length is -1, a true return here\n means that a 'null' value (or equivalent) was successfully stored."]
pub type AParcel_stringAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        stringData: *mut ::std::os::raw::c_void,
        length: i32,
        buffer: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " This is called to allocate an array of size 'length'. If length is -1, then a 'null' array (or\n equivalent) should be created.\n\n See also AParcel_readStringArray\n\n \\param arrayData some external representation of an array\n \\param length the length to allocate this array to\n\n \\return true if allocation succeeded. If length is -1, a true return here means that a 'null'\n value (or equivalent) was successfully stored."]
pub type AParcel_stringArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool,
>;
#[doc = " This is called to allocate a string inside of an array that was allocated by an\n AParcel_stringArrayAllocator.\n\n The index returned will always be within the range [0, length of arrayData). The returned buffer\n should be at least length bytes. This includes space for a null-terminator. For a string, length\n will always be strictly less than or equal to the maximum size that can be held in a size_t and\n will always be greater than 0. However, if a 'null' string is being read, length will be -1.\n\n See also AParcel_readStringArray\n\n \\param arrayData some external representation of an array.\n \\param index the index at which a string should be allocated.\n \\param length the length of the string to be allocated at this index. See also\n AParcel_stringAllocator. This includes the length required for a null-terminator.\n \\param buffer a buffer of size 'length' or null if allocation failed.\n\n \\return true if the allocation succeeded, false otherwise. If length is -1, a true return here\n means that a 'null' value (or equivalent) was successfully stored."]
pub type AParcel_stringArrayElementAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        index: usize,
        length: i32,
        buffer: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " This returns the length and buffer of an array at a specific index in an arrayData object.\n\n See also AParcel_writeStringArray\n\n \\param arrayData some external representation of an array.\n \\param index the index at which a string should be allocated.\n \\param outLength an out parameter for the length of the string at the specified index. This\n should not include the length for a null-terminator if there is one. If the object at this index\n is 'null', then this should be set to -1.\n\n \\param a buffer of size outLength or more representing the string at the provided index. This is\n not required to be null-terminated. If the object at index is null, then this should be null."]
pub type AParcel_stringArrayElementGetter = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *const ::std::os::raw::c_void,
        index: usize,
        outLength: *mut i32,
    ) -> *const ::std::os::raw::c_char,
>;
#[doc = " This is called to allocate an array of size 'length'. If length is -1, then a 'null' array (or\n equivalent) should be created.\n\n See also AParcel_readParcelableArray\n\n \\param arrayData some external representation of an array\n \\param length the length to allocate this array to\n\n \\return true if allocation succeeded. If length is -1, a true return here means that a 'null'\n value (or equivalent) was successfully stored."]
pub type AParcel_parcelableArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool,
>;
#[doc = " This is called to parcel the underlying data from an arrayData object at index.\n\n See also AParcel_writeParcelableArray\n\n \\param parcel parcel to write the parcelable to\n \\param arrayData some external representation of an array of parcelables (a user-defined type).\n \\param index the index of the value to be retrieved.\n\n \\return status (usually returned from other parceling functions). STATUS_OK for success."]
pub type AParcel_writeParcelableElement = ::std::option::Option<
    unsafe extern "C" fn(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        index: usize,
    ) -> binder_status_t,
>;
#[doc = " This is called to set an underlying value in an arrayData object at index.\n\n See also AParcel_readParcelableArray\n\n \\param parcel parcel to read the parcelable from\n \\param arrayData some external representation of an array of parcelables (a user-defined type).\n \\param index the index of the value to be set.\n\n \\return status (usually returned from other parceling functions). STATUS_OK for success."]
pub type AParcel_readParcelableElement = ::std::option::Option<
    unsafe extern "C" fn(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        index: usize,
    ) -> binder_status_t,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readInt32Array\n\n \\param arrayData some external representation of an array of int32_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of int32_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_int32ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut i32,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readUint32Array\n\n \\param arrayData some external representation of an array of uint32_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of uint32_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_uint32ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut u32,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readInt64Array\n\n \\param arrayData some external representation of an array of int64_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of int64_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_int64ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut i64,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readUint64Array\n\n \\param arrayData some external representation of an array of uint64_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of uint64_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_uint64ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut u64,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readFloatArray\n\n \\param arrayData some external representation of an array of float.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of float of size 'length' (if length is >= 0, if length is 0, this may\n be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_floatArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut f32,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readDoubleArray\n\n \\param arrayData some external representation of an array of double.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of double of size 'length' (if length is >= 0, if length is 0, this may\n be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_doubleArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut f64,
    ) -> bool,
>;
#[doc = " This allocates an array of size 'length' inside of arrayData and returns whether or not there was\n a success. If length is -1, then this should allocate some representation of a null array.\n\n See also AParcel_readBoolArray\n\n \\param arrayData some external representation of an array of bool.\n \\param length the length to allocate arrayData to (or -1 if this represents a null array).\n\n \\return whether the allocation succeeded."]
pub type AParcel_boolArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object at index.\n\n See also AParcel_writeBoolArray\n\n \\param arrayData some external representation of an array of bool.\n \\param index the index of the value to be retrieved.\n\n \\return the value of the array at index index."]
pub type AParcel_boolArrayGetter = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *const ::std::os::raw::c_void, index: usize) -> bool,
>;
#[doc = " This is called to set an underlying value in an arrayData object at index.\n\n See also AParcel_readBoolArray\n\n \\param arrayData some external representation of an array of bool.\n \\param index the index of the value to be set.\n \\param value the value to set at index index."]
pub type AParcel_boolArraySetter = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, index: usize, value: bool),
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readCharArray\n\n \\param arrayData some external representation of an array of char16_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of char16_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_charArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut u16,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readByteArray\n\n \\param arrayData some external representation of an array of int8_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of int8_t of size 'length' (if length is >= 0, if length is 0, this may\n be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_byteArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut i8,
    ) -> bool,
>;
extern "C" {
    #[doc = " Writes an AIBinder to the next location in a non-null parcel. Can be null. This does not take any\n refcounts of ownership of the binder from the client.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param binder the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeStrongBinder(
        parcel: *mut AParcel,
        binder: *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an AIBinder from the next location in a non-null parcel. One strong ref-count of ownership\n is passed to the caller of this function.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param binder the out parameter for what is read from the parcel. This may be null.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_readStrongBinder(
        parcel: *const AParcel,
        binder: *mut *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes a file descriptor to the next location in a non-null parcel. This does not take ownership\n of fd.\n\n This corresponds to the SDK's android.os.ParcelFileDescriptor.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param fd the value to write to the parcel (-1 to represent a null ParcelFileDescriptor).\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeParcelFileDescriptor(
        parcel: *mut AParcel,
        fd: ::std::os::raw::c_int,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an int from the next location in a non-null parcel.\n\n The returned fd must be closed.\n\n This corresponds to the SDK's android.os.ParcelFileDescriptor.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param fd the out parameter for what is read from the parcel (or -1 to represent a null\n ParcelFileDescriptor)\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_readParcelFileDescriptor(
        parcel: *const AParcel,
        fd: *mut ::std::os::raw::c_int,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an AStatus object to the next location in a non-null parcel.\n\n If the status is considered to be a low-level status and has no additional information other\n than a binder_status_t (for instance, if it is created with AStatus_fromStatus), then that\n status will be returned from this method and nothing will be written to the parcel. If either\n this happens or if writing the status object itself fails, the return value from this function\n should be propagated to the client, and AParcel_readStatusHeader shouldn't be called.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param status the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeStatusHeader(
        parcel: *mut AParcel,
        status: *const AStatus,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an AStatus from the next location in a non-null parcel. Ownership is passed to the caller\n of this function.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param status the out parameter for what is read from the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_readStatusHeader(
        parcel: *const AParcel,
        status: *mut *mut AStatus,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes utf-8 string value to the next location in a non-null parcel.\n\n If length is -1, and string is nullptr, this will write a 'null' string to the parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param string the null-terminated string to write to the parcel, at least of size 'length'.\n \\param length the length of the string to be written.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeString(
        parcel: *mut AParcel,
        string: *const ::std::os::raw::c_char,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads and allocates utf-8 string value from the next location in a non-null parcel.\n\n Data is passed to the string allocator once the string size is known. This size includes the\n space for the null-terminator of this string. This allocator returns a buffer which is used as\n the output buffer from this read. If there is a 'null' string on the binder buffer, the allocator\n will be called with length -1.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param stringData some external representation of a string.\n \\param allocator allocator that will be called once the size of the string is known.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_readString(
        parcel: *const AParcel,
        stringData: *mut ::std::os::raw::c_void,
        allocator: AParcel_stringAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes utf-8 string array data to the next location in a non-null parcel.\n\n length is the length of the array. AParcel_stringArrayElementGetter will be called for all\n indices in range [0, length) with the arrayData provided here. The string length and buffer\n returned from this function will be used to fill out the data from the parcel. If length is -1,\n this will write a 'null' string array to the binder buffer.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData some external representation of an array.\n \\param length the length of the array to be written.\n \\param getter the callback that will be called for every index of the array to retrieve the\n corresponding string buffer.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeStringArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        getter: AParcel_stringArrayElementGetter,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads and allocates utf-8 string array value from the next location in a non-null parcel.\n\n First, AParcel_stringArrayAllocator will be called with the size of the array to be read where\n length is the length of the array to be read from the parcel. Then, for each index i in [0,\n length), AParcel_stringArrayElementAllocator will be called with the length of the string to be\n read from the parcel. The resultant buffer from each of these calls will be filled according to\n the contents of the string that is read. If the string array being read is 'null', this will\n instead just pass -1 to AParcel_stringArrayAllocator.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called with arrayData once the size of the output\n array is known.\n \\param elementAllocator the callback that will be called on every index of arrayData to allocate\n the string at that location.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readStringArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_stringArrayAllocator,
        elementAllocator: AParcel_stringArrayElementAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of parcelables (user-defined types) to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n \\param elementWriter function to be called for every array index to write the user-defined type\n at that location.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeParcelableArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        elementWriter: AParcel_writeParcelableElement,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of parcelables (user-defined types) from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, elementReader will be called for every index to read the\n corresponding parcelable.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n \\param elementReader the callback that will be called to fill out individual elements.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readParcelableArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_parcelableArrayAllocator,
        elementReader: AParcel_readParcelableElement,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes int32_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt32(parcel: *mut AParcel, value: i32) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes uint32_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint32(parcel: *mut AParcel, value: u32) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes int64_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt64(parcel: *mut AParcel, value: i64) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes uint64_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint64(parcel: *mut AParcel, value: u64) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes float value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeFloat(parcel: *mut AParcel, value: f32) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes double value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeDouble(parcel: *mut AParcel, value: f64) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes bool value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeBool(parcel: *mut AParcel, value: bool) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes char16_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeChar(parcel: *mut AParcel, value: u16) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes int8_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeByte(parcel: *mut AParcel, value: i8) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into int32_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt32(parcel: *const AParcel, value: *mut i32) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into uint32_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint32(parcel: *const AParcel, value: *mut u32) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into int64_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt64(parcel: *const AParcel, value: *mut i64) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into uint64_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint64(parcel: *const AParcel, value: *mut u64) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into float value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readFloat(parcel: *const AParcel, value: *mut f32) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into double value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readDouble(parcel: *const AParcel, value: *mut f64) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into bool value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readBool(parcel: *const AParcel, value: *mut bool) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into char16_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readChar(parcel: *const AParcel, value: *mut u16) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into int8_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readByte(parcel: *const AParcel, value: *mut i8) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of int32_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt32Array(
        parcel: *mut AParcel,
        arrayData: *const i32,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of uint32_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint32Array(
        parcel: *mut AParcel,
        arrayData: *const u32,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of int64_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt64Array(
        parcel: *mut AParcel,
        arrayData: *const i64,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of uint64_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint64Array(
        parcel: *mut AParcel,
        arrayData: *const u64,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of float to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeFloatArray(
        parcel: *mut AParcel,
        arrayData: *const f32,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of double to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeDoubleArray(
        parcel: *mut AParcel,
        arrayData: *const f64,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of bool to the next location in a non-null parcel.\n\n getter(arrayData, i) will be called for each i in [0, length) in order to get the underlying\n values to write to the parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData some external representation of an array.\n \\param length the length of arrayData (or -1 if this represents a null array).\n \\param getter the callback to retrieve data at specific locations in the array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeBoolArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        getter: AParcel_boolArrayGetter,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of char16_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeCharArray(
        parcel: *mut AParcel,
        arrayData: *const u16,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of int8_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeByteArray(
        parcel: *mut AParcel,
        arrayData: *const i8,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of int32_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt32Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_int32ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of uint32_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint32Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_uint32ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of int64_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt64Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_int64ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of uint64_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint64Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_uint64ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of float from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readFloatArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_floatArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of double from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readDoubleArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_doubleArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of bool from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. Then, for every i in [0, length),\n setter(arrayData, i, x) will be called where x is the value at the associated index.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n \\param setter the callback that will be called to set a value at a specific location in the\n array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readBoolArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_boolArrayAllocator,
        setter: AParcel_boolArraySetter,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of char16_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readCharArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_charArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of int8_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readByteArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_byteArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reset the parcel to the initial status.\n\n Available since API level 31.\n\n \\param parcel The parcel of which to be reset.\n\n \\return STATUS_OK on success."]
    pub fn AParcel_reset(parcel: *mut AParcel) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets the size of the parcel.\n\n Available since API level 31.\n\n \\param parcel The parcel of which to get the size.\n\n \\return The size of the parcel."]
    pub fn AParcel_getDataSize(parcel: *const AParcel) -> i32;
}
extern "C" {
    #[doc = " Copy the data of a parcel to other parcel.\n\n Available since API level 31.\n\n \\param from The source\n \\param to The detination\n \\param start The position where the copied data starts.\n \\param size The amount of data which will be copied.\n\n \\return STATUS_OK on success."]
    pub fn AParcel_appendFrom(
        from: *const AParcel,
        to: *mut AParcel,
        start: i32,
        size: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Creates a parcel.\n\n Available since API level 31.\n\n \\return A parcel which is not related to any IBinder objects."]
    pub fn AParcel_create() -> *mut AParcel;
}
extern "C" {
    #[doc = " Marshals the raw bytes of the Parcel to a buffer.\n\n Available since API level 33.\n\n The parcel must not contain any binders or file descriptors.\n\n The data you retrieve here must not be placed in any kind of persistent storage. (on local disk,\n across a network, etc). For that, you should use standard serialization or another kind of\n general serialization mechanism. The Parcel marshalled representation is highly optimized for\n local IPC, and as such does not attempt to maintain compatibility with data created in different\n versions of the platform.\n\n \\param parcel The parcel of which to get the data.\n \\param buffer The buffer to copy the raw bytes to.\n \\param start The start position in the buffer to copy from.\n \\param len The size of the data to copy, buffer size must be larger or equal to this.\n\n \\return STATUS_OK on success, STATUS_INVALID_OPERATION if parcel contains binders or file\n descriptors. STATUS_BAD_VALUE if the buffer size is less than parcel size."]
    pub fn AParcel_marshal(
        parcel: *const AParcel,
        buffer: *mut u8,
        start: usize,
        len: usize,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Set the data in the parcel to the raw bytes from the buffer.\n\n Available since API level 33.\n\n \\param parcel The parcel to set data.\n \\param buffer The data buffer to set.\n \\param len The size of the data to set.\n\n \\return STATUS_OK on success."]
    pub fn AParcel_unmarshal(
        parcel: *mut AParcel,
        buffer: *const u8,
        len: usize,
    ) -> binder_status_t;
}
#[doc = " Flags for AIBinder_transact."]
pub type binder_flags_t = u32;
#[doc = " Codes for AIBinder_transact. This defines the range of codes available for\n usage. Other codes are used or reserved by the Android system."]
pub type transaction_code_t = u32;
#[doc = " Represents a type of AIBinder object which can be sent out."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_Class {
    _unused: [u8; 0],
}
#[doc = " The AIBinder object associated with this can be retrieved if it is still alive so that it can be\n re-used. The intention of this is to enable the same AIBinder object to always represent the same\n object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_Weak {
    _unused: [u8; 0],
}
#[doc = " Represents a handle on a death notification. See AIBinder_linkToDeath/AIBinder_unlinkToDeath."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_DeathRecipient {
    _unused: [u8; 0],
}
#[doc = " This is called whenever a new AIBinder object is needed of a specific class.\n\n \\param args these can be used to construct a new class. These are passed from AIBinder_new.\n \\return this is the userdata representing the class. It can be retrieved using\n AIBinder_getUserData."]
pub type AIBinder_Class_onCreate = ::std::option::Option<
    unsafe extern "C" fn(args: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[doc = " This is called whenever an AIBinder object is no longer referenced and needs destroyed.\n\n Typically, this just deletes whatever the implementation is.\n\n \\param userData this is the same object returned by AIBinder_Class_onCreate"]
pub type AIBinder_Class_onDestroy =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[doc = " This is called whenever a transaction needs to be processed by a local implementation.\n\n This method will be called after the equivalent of\n android.os.Parcel#enforceInterface is called. That is, the interface\n descriptor associated with the AIBinder_Class descriptor will already be\n checked.\n\n \\param binder the object being transacted on.\n \\param code implementation-specific code representing which transaction should be taken.\n \\param in the implementation-specific input data to this transaction.\n \\param out the implementation-specific output data to this transaction.\n\n \\return the implementation-specific output code. This may be forwarded from another service, the\n result of a parcel read or write, or another error as is applicable to the specific\n implementation. Usually, implementation-specific error codes are written to the output parcel,\n and the transaction code is reserved for kernel errors or error codes that have been repeated\n from subsequent transactions."]
pub type AIBinder_Class_onTransact = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        code: transaction_code_t,
        in_: *const AParcel,
        out: *mut AParcel,
    ) -> binder_status_t,
>;
extern "C" {
    #[doc = " This creates a new instance of a class of binders which can be instantiated. This is called one\n time during library initialization and cleaned up when the process exits or execs.\n\n None of these parameters can be null.\n\n Available since API level 29.\n\n \\param interfaceDescriptor this is a unique identifier for the class. This is used internally for\n validity checks on transactions. This should be utf-8.\n \\param onCreate see AIBinder_Class_onCreate.\n \\param onDestroy see AIBinder_Class_onDestroy.\n \\param onTransact see AIBinder_Class_onTransact.\n\n \\return the class object representing these parameters or null on error."]
    pub fn AIBinder_Class_define(
        interfaceDescriptor: *const ::std::os::raw::c_char,
        onCreate: AIBinder_Class_onCreate,
        onDestroy: AIBinder_Class_onDestroy,
        onTransact: AIBinder_Class_onTransact,
    ) -> *mut AIBinder_Class;
}
#[doc = " Dump information about an AIBinder (usually for debugging).\n\n When no arguments are provided, a brief overview of the interview should be given.\n\n \\param binder interface being dumped\n \\param fd file descriptor to be dumped to, should be flushed, ownership is not passed.\n \\param args array of null-terminated strings for dump (may be null if numArgs is 0)\n \\param numArgs number of args to be sent\n\n \\return binder_status_t result of transaction (if remote, for instance)"]
pub type AIBinder_onDump = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        fd: ::std::os::raw::c_int,
        args: *mut *const ::std::os::raw::c_char,
        numArgs: u32,
    ) -> binder_status_t,
>;
extern "C" {
    #[doc = " This sets the implementation of the dump method for a class.\n\n If this isn't set, nothing will be dumped when dump is called (for instance with\n android.os.Binder#dump). Must be called before any instance of the class is created.\n\n Available since API level 29.\n\n \\param clazz class which should use this dump function\n \\param onDump function to call when an instance of this binder class is being dumped."]
    pub fn AIBinder_Class_setOnDump(clazz: *mut AIBinder_Class, onDump: AIBinder_onDump);
}
extern "C" {
    #[doc = " This tells users of this class not to use a transaction header. By default, libbinder_ndk users\n read/write transaction headers implicitly (in the SDK, this must be manually written by\n android.os.Parcel#writeInterfaceToken, and it is read/checked with\n android.os.Parcel#enforceInterface). This method is provided in order to talk to legacy code\n which does not write an interface token. When this is disabled, type safety is reduced, so you\n must have a separate way of determining the binder you are talking to is the right type. Must\n be called before any instance of the class is created.\n\n Available since API level 33.\n\n WARNING: this API interacts badly with linkernamespaces. For correct behavior, you must\n use it on all instances of a class in the same process which share the same interface\n descriptor. In general, it is recommended you do not use this API, because it is disabling\n type safety.\n\n \\param clazz class to disable interface header on."]
    pub fn AIBinder_Class_disableInterfaceTokenHeader(clazz: *mut AIBinder_Class);
}
extern "C" {
    #[doc = " Creates a new binder object of the appropriate class.\n\n Ownership of args is passed to this object. The lifecycle is implemented with AIBinder_incStrong\n and AIBinder_decStrong. When the reference count reaches zero, onDestroy is called.\n\n When this is called, the refcount is implicitly 1. So, calling decStrong exactly one time is\n required to delete this object.\n\n Once an AIBinder object is created using this API, re-creating that AIBinder for the same\n instance of the same class will break pointer equality for that specific AIBinder object. For\n instance, if someone erroneously created two AIBinder instances representing the same callback\n object and passed one to a hypothetical addCallback function and then later another one to a\n hypothetical removeCallback function, the remote process would have no way to determine that\n these two objects are actually equal using the AIBinder pointer alone (which they should be able\n to do). Also see the suggested memory ownership model suggested above.\n\n Available since API level 29.\n\n \\param clazz the type of the object to be created.\n \\param args the args to pass to AIBinder_onCreate for that class.\n\n \\return a binder object representing the newly instantiated object."]
    pub fn AIBinder_new(
        clazz: *const AIBinder_Class,
        args: *mut ::std::os::raw::c_void,
    ) -> *mut AIBinder;
}
extern "C" {
    #[doc = " If this is hosted in a process other than the current one.\n\n Available since API level 29.\n\n \\param binder the binder being queried.\n\n \\return true if the AIBinder represents an object in another process."]
    pub fn AIBinder_isRemote(binder: *const AIBinder) -> bool;
}
extern "C" {
    #[doc = " If this binder is known to be alive. This will not send a transaction to a remote process and\n returns a result based on the last known information. That is, whenever a transaction is made,\n this is automatically updated to reflect the current alive status of this binder. This will be\n updated as the result of a transaction made using AIBinder_transact, but it will also be updated\n based on the results of bookkeeping or other transactions made internally.\n\n Available since API level 29.\n\n \\param binder the binder being queried.\n\n \\return true if the binder is alive."]
    pub fn AIBinder_isAlive(binder: *const AIBinder) -> bool;
}
extern "C" {
    #[doc = " Built-in transaction for all binder objects. This sends a transaction that will immediately\n return. Usually this is used to make sure that a binder is alive, as a placeholder call, or as a\n consistency check.\n\n Available since API level 29.\n\n \\param binder the binder being queried.\n\n \\return STATUS_OK if the ping succeeds."]
    pub fn AIBinder_ping(binder: *mut AIBinder) -> binder_status_t;
}
extern "C" {
    #[doc = " Built-in transaction for all binder objects. This dumps information about a given binder.\n\n See also AIBinder_Class_setOnDump, AIBinder_onDump.\n\n Available since API level 29.\n\n \\param binder the binder to dump information about\n \\param fd where information should be dumped to\n \\param args null-terminated arguments to pass (may be null if numArgs is 0)\n \\param numArgs number of args to send\n\n \\return STATUS_OK if dump succeeds (or if there is nothing to dump)"]
    pub fn AIBinder_dump(
        binder: *mut AIBinder,
        fd: ::std::os::raw::c_int,
        args: *mut *const ::std::os::raw::c_char,
        numArgs: u32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Registers for notifications that the associated binder is dead. The same death recipient may be\n associated with multiple different binders. If the binder is local, then no death recipient will\n be given (since if the local process dies, then no recipient will exist to receive a\n transaction). The cookie is passed to recipient in the case that this binder dies and can be\n null. The exact cookie must also be used to unlink this transaction (see AIBinder_unlinkToDeath).\n This function may return a binder transaction failure. The cookie can be used both for\n identification and holding user data.\n\n If binder is local, this will return STATUS_INVALID_OPERATION.\n\n Available since API level 29.\n\n \\param binder the binder object you want to receive death notifications from.\n \\param recipient the callback that will receive notifications when/if the binder dies.\n \\param cookie the value that will be passed to the death recipient on death.\n\n \\return STATUS_OK on success."]
    pub fn AIBinder_linkToDeath(
        binder: *mut AIBinder,
        recipient: *mut AIBinder_DeathRecipient,
        cookie: *mut ::std::os::raw::c_void,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Stops registration for the associated binder dying. Does not delete the recipient. This function\n may return a binder transaction failure and in case the death recipient cannot be found, it\n returns STATUS_NAME_NOT_FOUND.\n\n This only ever needs to be called when the AIBinder_DeathRecipient remains for use with other\n AIBinder objects. If the death recipient is deleted, all binders will automatically be unlinked.\n If the binder dies, it will automatically unlink. If the binder is deleted, it will be\n automatically unlinked.\n\n Be aware that it is not safe to immediately deallocate the cookie when this call returns. If you\n need to clean up the cookie, you should do so in the onUnlinked callback, which can be set using\n AIBinder_DeathRecipient_setOnUnlinked.\n\n Available since API level 29.\n\n \\param binder the binder object to remove a previously linked death recipient from.\n \\param recipient the callback to remove.\n \\param cookie the cookie used to link to death.\n\n \\return STATUS_OK on success. STATUS_NAME_NOT_FOUND if the binder cannot be found to be unlinked."]
    pub fn AIBinder_unlinkToDeath(
        binder: *mut AIBinder,
        recipient: *mut AIBinder_DeathRecipient,
        cookie: *mut ::std::os::raw::c_void,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " This returns the calling UID assuming that this thread is called from a thread that is processing\n a binder transaction (for instance, in the implementation of AIBinder_Class_onTransact).\n\n This can be used with higher-level system services to determine the caller's identity and check\n permissions.\n\n Available since API level 29.\n\n \\return calling uid or the current process's UID if this thread isn't processing a transaction."]
    pub fn AIBinder_getCallingUid() -> uid_t;
}
extern "C" {
    #[doc = " This returns the calling PID assuming that this thread is called from a thread that is processing\n a binder transaction (for instance, in the implementation of AIBinder_Class_onTransact).\n\n This can be used with higher-level system services to determine the caller's identity and check\n permissions. However, when doing this, one should be aware of possible TOCTOU problems when the\n calling process dies and is replaced with another process with elevated permissions and the same\n PID.\n\n Warning: oneway transactions do not receive PID. Even if you expect\n a transaction to be synchronous, a misbehaving client could send it\n as a synchronous call and result in a 0 PID here. Additionally, if\n there is a race and the calling process dies, the PID may still be\n 0 for a synchronous call.\n\n Available since API level 29.\n\n \\return calling pid or the current process's PID if this thread isn't processing a transaction.\n If the transaction being processed is a oneway transaction, then this method will return 0."]
    pub fn AIBinder_getCallingPid() -> pid_t;
}
extern "C" {
    #[doc = " Determine whether the current thread is currently executing an incoming transaction.\n\n \\return true if the current thread is currently executing an incoming transaction, and false\n otherwise."]
    pub fn AIBinder_isHandlingTransaction() -> bool;
}
extern "C" {
    #[doc = " This can only be called if a strong reference to this object already exists in process.\n\n Available since API level 29.\n\n \\param binder the binder object to add a refcount to."]
    pub fn AIBinder_incStrong(binder: *mut AIBinder);
}
extern "C" {
    #[doc = " This will delete the object and call onDestroy once the refcount reaches zero.\n\n Available since API level 29.\n\n \\param binder the binder object to remove a refcount from."]
    pub fn AIBinder_decStrong(binder: *mut AIBinder);
}
extern "C" {
    #[doc = " For debugging only!\n\n Available since API level 29.\n\n \\param binder the binder object to retrieve the refcount of.\n\n \\return the number of strong-refs on this binder in this process. If binder is null, this will be\n -1."]
    pub fn AIBinder_debugGetRefCount(binder: *mut AIBinder) -> i32;
}
extern "C" {
    #[doc = " This sets the class of an AIBinder object. This checks to make sure the remote object is of\n the expected class. A class must be set in order to use transactions on an AIBinder object.\n However, if an object is just intended to be passed through to another process or used as a\n handle this need not be called.\n\n This returns true if the class association succeeds. If it fails, no change is made to the\n binder object.\n\n Warning: this may fail if the binder is dead.\n\n Available since API level 29.\n\n \\param binder the object to attach the class to.\n \\param clazz the clazz to attach to binder.\n\n \\return true if the binder has the class clazz and if the association was successful."]
    pub fn AIBinder_associateClass(binder: *mut AIBinder, clazz: *const AIBinder_Class) -> bool;
}
extern "C" {
    #[doc = " Returns the class that this binder was constructed with or associated with.\n\n Available since API level 29.\n\n \\param binder the object that is being queried.\n\n \\return the class that this binder is associated with. If this binder wasn't created with\n AIBinder_new, and AIBinder_associateClass hasn't been called, then this will return null."]
    pub fn AIBinder_getClass(binder: *mut AIBinder) -> *const AIBinder_Class;
}
extern "C" {
    #[doc = " Value returned by onCreate for a local binder. For stateless classes (if onCreate returns\n null), this also returns null. For a remote binder, this will always return null.\n\n Available since API level 29.\n\n \\param binder the object that is being queried.\n\n \\return the userdata returned from AIBinder_onCreate when this object was created. This may be\n null for stateless objects. For remote objects, this is always null."]
    pub fn AIBinder_getUserData(binder: *mut AIBinder) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Creates a parcel to start filling out for a transaction. This will add a header to the\n transaction that corresponds to android.os.Parcel#writeInterfaceToken. This may add debugging\n or other information to the transaction for platform use or to enable other features to work. The\n contents of this header is a platform implementation detail, and it is required to use\n libbinder_ndk. This parcel is to be sent via AIBinder_transact and it represents the input data\n to the transaction. It is recommended to check if the object is local and call directly into its\n user data before calling this as the parceling and unparceling cost can be avoided. This AIBinder\n must be either built with a class or associated with a class before using this API.\n\n This does not affect the ownership of binder. When this function succeeds, the in parcel's\n ownership is passed to the caller. At this point, the parcel can be filled out and passed to\n AIBinder_transact. Alternatively, if there is an error while filling out the parcel, it can be\n deleted with AParcel_delete.\n\n Available since API level 29.\n\n \\param binder the binder object to start a transaction on.\n \\param in out parameter for input data to the transaction.\n\n \\return STATUS_OK on success. This will return STATUS_INVALID_OPERATION if the binder has not yet\n been associated with a class (see AIBinder_new and AIBinder_associateClass)."]
    pub fn AIBinder_prepareTransaction(
        binder: *mut AIBinder,
        in_: *mut *mut AParcel,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Transact using a parcel created from AIBinder_prepareTransaction. This actually communicates with\n the object representing this binder object. This also passes out a parcel to be used for the\n return transaction. This takes ownership of the in parcel and automatically deletes it after it\n is sent to the remote process. The output parcel is the result of the transaction. If the\n transaction has FLAG_ONEWAY, the out parcel will be empty. Otherwise, this will block until the\n remote process has processed the transaction, and the out parcel will contain the output data\n from transaction.\n\n This does not affect the ownership of binder. The out parcel's ownership is passed to the caller\n and must be released with AParcel_delete when finished reading.\n\n Available since API level 29.\n\n \\param binder the binder object to transact on.\n \\param code the implementation-specific code representing which transaction should be taken.\n \\param in the implementation-specific input data to this transaction.\n \\param out the implementation-specific output data to this transaction.\n \\param flags possible flags to alter the way in which the transaction is conducted or 0.\n\n \\return the result from the kernel or from the remote process. Usually, implementation-specific\n error codes are written to the output parcel, and the transaction code is reserved for kernel\n errors or error codes that have been repeated from subsequent transactions."]
    pub fn AIBinder_transact(
        binder: *mut AIBinder,
        code: transaction_code_t,
        in_: *mut *mut AParcel,
        out: *mut *mut AParcel,
        flags: binder_flags_t,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " This does not take any ownership of the input binder, but it can be used to retrieve it if\n something else in some process still holds a reference to it.\n\n Available since API level 29.\n\n \\param binder object to create a weak pointer to.\n\n \\return object representing a weak pointer to binder (or null if binder is null)."]
    pub fn AIBinder_Weak_new(binder: *mut AIBinder) -> *mut AIBinder_Weak;
}
extern "C" {
    #[doc = " Deletes the weak reference. This will have no impact on the lifetime of the binder.\n\n Available since API level 29.\n\n \\param weakBinder object created with AIBinder_Weak_new."]
    pub fn AIBinder_Weak_delete(weakBinder: *mut AIBinder_Weak);
}
extern "C" {
    #[doc = " If promotion succeeds, result will have one strong refcount added to it. Otherwise, this returns\n null.\n\n Available since API level 29.\n\n \\param weakBinder weak pointer to attempt retrieving the original object from.\n\n \\return an AIBinder object with one refcount given to the caller or null."]
    pub fn AIBinder_Weak_promote(weakBinder: *mut AIBinder_Weak) -> *mut AIBinder;
}
#[doc = " This function is executed on death receipt. See AIBinder_linkToDeath/AIBinder_unlinkToDeath.\n\n Available since API level 29.\n\n \\param cookie the cookie passed to AIBinder_linkToDeath."]
pub type AIBinder_DeathRecipient_onBinderDied =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
#[doc = " This function is intended for cleaning up the data in the provided cookie, and it is executed\n when the DeathRecipient is unlinked. When the DeathRecipient is unlinked due to a death receipt,\n this method is called after the call to onBinderDied.\n\n This method is called once for each binder that is unlinked. Hence, if the same cookie is passed\n to multiple binders, then the caller is responsible for reference counting the cookie.\n\n See also AIBinder_linkToDeath/AIBinder_unlinkToDeath.\n\n WARNING: Make sure the lifetime of this cookie is long enough. If it is dynamically\n allocated, it should be deleted with AIBinder_DeathRecipient_setOnUnlinked.\n\n Available since API level 33.\n\n \\param cookie the cookie passed to AIBinder_linkToDeath."]
pub type AIBinder_DeathRecipient_onBinderUnlinked =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Creates a new binder death recipient. This can be attached to multiple different binder objects.\n\n Available since API level 29.\n\n WARNING: Make sure the lifetime of this cookie is long enough. If it is dynamically\n allocated, it should be deleted with AIBinder_DeathRecipient_setOnUnlinked.\n\n \\param onBinderDied the callback to call when this death recipient is invoked.\n\n \\return the newly constructed object (or null if onBinderDied is null)."]
    pub fn AIBinder_DeathRecipient_new(
        onBinderDied: AIBinder_DeathRecipient_onBinderDied,
    ) -> *mut AIBinder_DeathRecipient;
}
extern "C" {
    #[doc = " Set the callback to be called when this DeathRecipient is unlinked from a binder. The callback is\n called in the following situations:\n\n  1. If the binder died, shortly after the call to onBinderDied.\n  2. If the binder is explicitly unlinked with AIBinder_unlinkToDeath or\n     AIBinder_DeathRecipient_delete, after any pending onBinderDied calls\n     finish.\n  3. During or shortly after the AIBinder_linkToDeath call if it returns an error.\n\n It is guaranteed that the callback is called exactly once for each call to linkToDeath unless the\n process is aborted before the binder is unlinked.\n\n Be aware that when the binder is explicitly unlinked, it is not guaranteed that onUnlinked has\n been called before the call to AIBinder_unlinkToDeath or AIBinder_DeathRecipient_delete returns.\n For example, if the binder dies concurrently with a call to AIBinder_unlinkToDeath, the binder is\n not unlinked until after the death notification is delivered, even if AIBinder_unlinkToDeath\n returns before that happens.\n\n This method should be called before linking the DeathRecipient to a binder because the function\n pointer is cached. If you change it after linking to a binder, it is unspecified whether the old\n binder will call the old or new onUnlinked callback.\n\n The onUnlinked argument may be null. In this case, no notification is given when the binder is\n unlinked.\n\n Available since API level 33.\n\n \\param recipient the DeathRecipient to set the onUnlinked callback for.\n \\param onUnlinked the callback to call when a binder is unlinked from recipient."]
    pub fn AIBinder_DeathRecipient_setOnUnlinked(
        recipient: *mut AIBinder_DeathRecipient,
        onUnlinked: AIBinder_DeathRecipient_onBinderUnlinked,
    );
}
extern "C" {
    #[doc = " Deletes a binder death recipient. It is not necessary to call AIBinder_unlinkToDeath before\n calling this as these will all be automatically unlinked.\n\n Be aware that it is not safe to immediately deallocate the cookie when this call returns. If you\n need to clean up the cookie, you should do so in the onUnlinked callback, which can be set using\n AIBinder_DeathRecipient_setOnUnlinked.\n\n Available since API level 29.\n\n \\param recipient the binder to delete (previously created with AIBinder_DeathRecipient_new)."]
    pub fn AIBinder_DeathRecipient_delete(recipient: *mut AIBinder_DeathRecipient);
}
extern "C" {
    #[doc = " Gets the extension registered with AIBinder_setExtension.\n\n See AIBinder_setExtension.\n\n Available since API level 30.\n\n \\param binder the object to get the extension of.\n \\param outExt the returned extension object. Will be null if there is no extension set or\n non-null with one strong ref count.\n\n \\return error of getting the interface (may be a transaction error if this is\n remote binder). STATUS_UNEXPECTED_NULL if binder is null."]
    pub fn AIBinder_getExtension(
        binder: *mut AIBinder,
        outExt: *mut *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets the extension of a binder interface. This allows a downstream developer to add\n an extension to an interface without modifying its interface file. This should be\n called immediately when the object is created before it is passed to another thread.\n No thread safety is required.\n\n For instance, imagine if we have this interface:\n     interface IFoo { void doFoo(); }\n\n A). Historical option that has proven to be BAD! Only the original\n     author of an interface should change an interface. If someone\n     downstream wants additional functionality, they should not ever\n     change the interface or use this method.\n\n    BAD TO DO:  interface IFoo {                       BAD TO DO\n    BAD TO DO:      void doFoo();                      BAD TO DO\n    BAD TO DO: +    void doBar(); // adding a method   BAD TO DO\n    BAD TO DO:  }                                      BAD TO DO\n\n B). Option that this method enables.\n     Leave the original interface unchanged (do not change IFoo!).\n     Instead, create a new interface in a downstream package:\n\n         package com.<name>; // new functionality in a new package\n         interface IBar { void doBar(); }\n\n     When registering the interface, add:\n         std::shared_ptr<MyFoo> foo = new MyFoo; // class in AOSP codebase\n         std::shared_ptr<MyBar> bar = new MyBar; // custom extension class\n         SpAIBinder binder = foo->asBinder(); // target binder to extend\n         ... = AIBinder_setExtension(binder.get(), bar->asBinder().get());\n         ... = AServiceManager_addService(binder.get(), instanceName);\n         // handle error\n\n         Do not use foo->asBinder().get() as the target binder argument to\n         AIBinder_setExtensions because asBinder it creates a new binder\n         object that will be destroyed after the function is called. The same\n         binder object must be used for AIBinder_setExtension and\n         AServiceManager_addService to register the service with an extension.\n\n     Then, clients of IFoo can get this extension:\n         SpAIBinder binder = ...;\n         std::shared_ptr<IFoo> foo = IFoo::fromBinder(binder); // handle if null\n         SpAIBinder barBinder;\n         ... = AIBinder_getExtension(barBinder.get());\n         // handle error\n         std::shared_ptr<IBar> bar = IBar::fromBinder(barBinder);\n         // type is checked with AIBinder_associateClass\n         // if bar is null, then there is no extension or a different\n         // type of extension\n\n Available since API level 30.\n\n \\param binder the object to get the extension on. Must be local.\n \\param ext the extension to set (binder will hold a strong reference to this)\n\n \\return OK on success, STATUS_INVALID_OPERATION if binder is not local, STATUS_UNEXPECTED_NULL\n if either binder is null."]
    pub fn AIBinder_setExtension(binder: *mut AIBinder, ext: *mut AIBinder) -> binder_status_t;
}
extern "C" {
    #[doc = " Retrieve the class descriptor for the class.\n\n Available since API level 31.\n\n \\param clazz the class to fetch the descriptor from\n\n \\return the class descriptor string. This pointer will never be null; a\n descriptor is required to define a class. The pointer is owned by the class\n and will remain valid as long as the class does. For a local class, this will\n be the same value (not necessarily pointer equal) as is passed into\n AIBinder_Class_define. Format is utf-8."]
    pub fn AIBinder_Class_getDescriptor(
        clazz: *const AIBinder_Class,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Whether AIBinder is less than another.\n\n This provides a per-process-unique total ordering of binders where a null\n AIBinder* object is considered to be before all other binder objects.\n For instance, two binders refer to the same object in a local or remote\n process when both AIBinder_lt(a, b) and AIBinder_lt(b, a) are false. This API\n might be used to insert and lookup binders in binary search trees.\n\n AIBinder* pointers themselves actually also create a per-process-unique total\n ordering. However, this ordering is inconsistent with AIBinder_Weak_lt for\n remote binders. So, in general, this function should be preferred.\n\n Available since API level 31.\n\n \\param lhs comparison object\n \\param rhs comparison object\n\n \\return whether \"lhs < rhs\" is true"]
    pub fn AIBinder_lt(lhs: *const AIBinder, rhs: *const AIBinder) -> bool;
}
extern "C" {
    #[doc = " Clone an AIBinder_Weak. Useful because even if a weak binder promotes to a\n null value, after further binder transactions, it may no longer promote to a\n null value.\n\n Available since API level 31.\n\n \\param weak Object to clone\n\n \\return clone of the input parameter. This must be deleted with\n AIBinder_Weak_delete. Null if weak input parameter is also null."]
    pub fn AIBinder_Weak_clone(weak: *const AIBinder_Weak) -> *mut AIBinder_Weak;
}
extern "C" {
    #[doc = " Whether AIBinder_Weak is less than another.\n\n This provides a per-process-unique total ordering of binders which is exactly\n the same as AIBinder_lt. Similarly, a null AIBinder_Weak* is considered to be\n ordered before all other weak references.\n\n This function correctly distinguishes binders even if one is deallocated. So,\n for instance, an AIBinder_Weak* entry representing a deleted binder will\n never compare as equal to an AIBinder_Weak* entry which represents a\n different allocation of a binder, even if the two binders were originally\n allocated at the same address. That is:\n\n     AIBinder* a = ...; // imagine this has address 0x8\n     AIBinder_Weak* bWeak = AIBinder_Weak_new(a);\n     AIBinder_decStrong(a); // a may be deleted, if this is the last reference\n     AIBinder* b = ...; // imagine this has address 0x8 (same address as b)\n     AIBinder_Weak* bWeak = AIBinder_Weak_new(b);\n\n Then when a/b are compared with other binders, their order will be preserved,\n and it will either be the case that AIBinder_Weak_lt(aWeak, bWeak) OR\n AIBinder_Weak_lt(bWeak, aWeak), but not both.\n\n Unlike AIBinder*, the AIBinder_Weak* addresses themselves have nothing to do\n with the underlying binder.\n\n Available since API level 31.\n\n \\param lhs comparison object\n \\param rhs comparison object\n\n \\return whether \"lhs < rhs\" is true"]
    pub fn AIBinder_Weak_lt(lhs: *const AIBinder_Weak, rhs: *const AIBinder_Weak) -> bool;
}
extern "C" {
    #[doc = " Makes calls to AIBinder_getCallingSid work if the kernel supports it. This\n must be called on a local binder server before it is sent out to any othe\n process. If this is a remote binder, it will abort. If the kernel doesn't\n support this feature, you'll always get null from AIBinder_getCallingSid.\n\n \\param binder local server binder to request security contexts on"]
    pub fn AIBinder_setRequestingSid(binder: *mut AIBinder, requestingSid: bool);
}
extern "C" {
    #[doc = " Returns the selinux context of the callee.\n\n In order for this to work, the following conditions must be met:\n - The kernel must be new enough to support this feature.\n - The server must have called AIBinder_setRequestingSid.\n - The callee must be a remote process.\n\n \\return security context or null if unavailable. The lifetime of this context\n is the lifetime of the transaction."]
    pub fn AIBinder_getCallingSid() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets a minimum scheduler policy for all transactions coming into this\n AIBinder.\n\n This must be called before the object is sent to another process.\n Aborts on invalid values. Not thread safe.\n\n \\param binder local server binder to set the policy for\n \\param policy scheduler policy as defined in linux UAPI\n \\param priority priority. [-20..19] for SCHED_NORMAL, [1..99] for RT"]
    pub fn AIBinder_setMinSchedulerPolicy(
        binder: *mut AIBinder,
        policy: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Allow the binder to inherit realtime scheduling policies from its caller.\n\n This must be called before the object is sent to another process. Not thread\n safe.\n\n \\param binder local server binder to set the policy for\n \\param inheritRt whether to inherit realtime scheduling policies (default is\n     false)."]
    pub fn AIBinder_setInheritRt(binder: *mut AIBinder, inheritRt: bool);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AServiceManager_AddServiceFlag {
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_ALLOW_ISOLATED = 1,
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_DUMP_FLAG_PRIORITY_CRITICAL = 2,
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_DUMP_FLAG_PRIORITY_HIGH = 4,
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_DUMP_FLAG_PRIORITY_NORMAL = 8,
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_DUMP_FLAG_PRIORITY_DEFAULT = 16,
}
extern "C" {
    #[doc = " This registers the service with the default service manager under this instance name. This does\n not take ownership of binder.\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n \\param binder object to register globally with the service manager.\n \\param instance identifier of the service. This will be used to lookup the service.\n\n \\return EX_NONE on success."]
    pub fn AServiceManager_addService(
        binder: *mut AIBinder,
        instance: *const ::std::os::raw::c_char,
    ) -> binder_exception_t;
}
extern "C" {
    #[doc = " This registers the service with the default service manager under this instance name. This does\n not take ownership of binder.\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n \\param binder object to register globally with the service manager.\n \\param instance identifier of the service. This will be used to lookup the service.\n \\param flags an AServiceManager_AddServiceFlag enum to denote how the service should be added.\n\n \\return EX_NONE on success."]
    pub fn AServiceManager_addServiceWithFlags(
        binder: *mut AIBinder,
        instance: *const ::std::os::raw::c_char,
        flags: AServiceManager_AddServiceFlag,
    ) -> binder_exception_t;
}
extern "C" {
    #[doc = " Gets a binder object with this specific instance name. Will return nullptr immediately if the\n service is not available This also implicitly calls AIBinder_incStrong (so the caller of this\n function is responsible for calling AIBinder_decStrong).\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n \\param instance identifier of the service used to lookup the service."]
    pub fn AServiceManager_checkService(instance: *const ::std::os::raw::c_char) -> *mut AIBinder;
}
extern "C" {
    #[doc = " Gets a binder object with this specific instance name. Blocks for a couple of seconds waiting on\n it. This also implicitly calls AIBinder_incStrong (so the caller of this function is responsible\n for calling AIBinder_decStrong). This does polling. A more efficient way to make sure you\n unblock as soon as the service is available is to use AIBinder_waitForService.\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n WARNING: when using this API, typically, you should call it in a loop. It's dangerous to\n assume that nullptr could mean that the service is not available. The service could just\n be starting. Generally, whether a service exists, this information should be declared\n externally (for instance, an Android feature might imply the existence of a service,\n a system property, or in the case of services in the VINTF manifest, it can be checked\n with AServiceManager_isDeclared).\n\n \\param instance identifier of the service used to lookup the service."]
    pub fn AServiceManager_getService(instance: *const ::std::os::raw::c_char) -> *mut AIBinder;
}
extern "C" {
    #[doc = " Registers a lazy service with the default service manager under the 'instance' name.\n Does not take ownership of binder.\n The service must be configured statically with init so it can be restarted with\n ctl.interface.* messages from servicemanager.\n AServiceManager_registerLazyService cannot safely be used with AServiceManager_addService\n in the same process. If one service is registered with AServiceManager_registerLazyService,\n the entire process will have its lifetime controlled by servicemanager.\n Instead, all services in the process should be registered using\n AServiceManager_registerLazyService.\n\n \\param binder object to register globally with the service manager.\n \\param instance identifier of the service. This will be used to lookup the service.\n\n \\return STATUS_OK on success."]
    pub fn AServiceManager_registerLazyService(
        binder: *mut AIBinder,
        instance: *const ::std::os::raw::c_char,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets a binder object with this specific instance name. Efficiently waits for the service.\n If the service is not ever registered, it will wait indefinitely. Requires the threadpool\n to be started in the service.\n This also implicitly calls AIBinder_incStrong (so the caller of this function is responsible\n for calling AIBinder_decStrong).\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n \\param instance identifier of the service used to lookup the service.\n\n \\return service if registered, null if not."]
    pub fn AServiceManager_waitForService(instance: *const ::std::os::raw::c_char)
        -> *mut AIBinder;
}
#[doc = " Function to call when a service is registered. The instance is passed as well as\n ownership of the binder named 'registered'.\n\n WARNING: a lock is held when this method is called in order to prevent races with\n AServiceManager_NotificationRegistration_delete. Do not make synchronous binder calls when\n implementing this method to avoid deadlocks.\n\n \\param instance instance name of service registered\n \\param registered ownership-passed instance of service registered\n \\param cookie data passed during registration for notifications"]
pub type AServiceManager_onRegister = ::std::option::Option<
    unsafe extern "C" fn(
        instance: *const ::std::os::raw::c_char,
        registered: *mut AIBinder,
        cookie: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Represents a registration to servicemanager which can be cleared anytime."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AServiceManager_NotificationRegistration {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get notifications when a service is registered. If the service is already registered,\n you will immediately get a notification.\n\n WARNING: it is strongly recommended to use AServiceManager_waitForService API instead.\n That API will wait synchronously, which is what you usually want in cases, including\n using some feature or during boot up. There is a history of bugs where waiting for\n notifications like this races with service startup. Also, when this API is used, a service\n bug will result in silent failure (rather than a debuggable deadlock). Furthermore, there\n is a history of this API being used to know when a service is up as a proxy for whethre\n that service should be started. This should only be used if you are intending to get\n ahold of the service as a client. For lazy services, whether a service is registered\n should not be used as a proxy for when it should be registered, which is only known\n by the real client.\n\n WARNING: if you use this API, you must also ensure that you check missing services are\n started and crash otherwise. If service failures are ignored, the system rots.\n\n \\param instance name of service to wait for notifications about\n \\param onRegister callback for when service is registered\n \\param cookie data associated with this callback\n\n \\return the token for this registration. Deleting this token will unregister."]
    pub fn AServiceManager_registerForServiceNotifications(
        instance: *const ::std::os::raw::c_char,
        onRegister: AServiceManager_onRegister,
        cookie: *mut ::std::os::raw::c_void,
    ) -> *mut AServiceManager_NotificationRegistration;
}
extern "C" {
    #[doc = " Unregister for notifications and delete the object.\n\n After this method is called, the callback is guaranteed to no longer be invoked. This will block\n until any in-progress onRegister callbacks have completed. It is therefore safe to immediately\n destroy the void* cookie that was registered when this method returns.\n\n \\param notification object to dismiss"]
    pub fn AServiceManager_NotificationRegistration_delete(
        notification: *mut AServiceManager_NotificationRegistration,
    );
}
extern "C" {
    #[doc = " Check if a service is declared (e.g. VINTF manifest).\n\n \\param instance identifier of the service.\n\n \\return true on success, meaning AServiceManager_waitForService should always\n    be able to return the service."]
    pub fn AServiceManager_isDeclared(instance: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Returns all declared instances for a particular interface.\n\n For instance, if 'android.foo.IFoo/foo' is declared, and 'android.foo.IFoo' is\n passed here, then [\"foo\"] would be returned.\n\n See also AServiceManager_isDeclared.\n\n \\param interface interface, e.g. 'android.foo.IFoo'\n \\param context to pass to callback\n \\param callback taking instance (e.g. 'foo') and context"]
    pub fn AServiceManager_forEachDeclaredInstance(
        interface: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Check if a service is updatable via an APEX module.\n\n \\param instance identifier of the service\n\n \\return whether the interface is updatable via APEX"]
    pub fn AServiceManager_isUpdatableViaApex(instance: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Returns the APEX name if a service is declared as updatable via an APEX module.\n\n \\param instance identifier of the service\n \\param context to pass to callback\n \\param callback taking the APEX name (e.g. 'com.android.foo') and context"]
    pub fn AServiceManager_getUpdatableApexName(
        instance: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Opens a declared passthrough HAL.\n\n \\param instance identifier of the passthrough service (e.g. \"mapper\")\n \\param instance identifier of the implemenatation (e.g. \"default\")\n \\param flag passed to dlopen()\n\n \\return the result of dlopen of the specified HAL"]
    pub fn AServiceManager_openDeclaredPassthroughHal(
        interface: *const ::std::os::raw::c_char,
        instance: *const ::std::os::raw::c_char,
        flag: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Prevent lazy services without client from shutting down their process\n\n This should only be used if it is every eventually set to false. If a\n service needs to persist but doesn't need to dynamically shut down,\n prefer to control it with another mechanism.\n\n \\param persist 'true' if the process should not exit."]
    pub fn AServiceManager_forceLazyServicesPersist(persist: bool);
}
extern "C" {
    #[doc = " Set a callback that is invoked when the active service count (i.e. services with clients)\n registered with this process drops to zero (or becomes nonzero).\n The callback takes a boolean argument, which is 'true' if there is\n at least one service with clients.\n\n \\param callback function to call when the number of services\n    with clients changes.\n \\param context opaque pointer passed back as second parameter to the\n callback.\n\n The callback takes two arguments. The first is a boolean that represents if there are\n services with clients (true) or not (false).\n The second is the 'context' pointer passed during the registration.\n\n Callback return value:\n - false: Default behavior for lazy services (shut down the process if there\n          are no clients).\n - true:  Don't shut down the process even if there are no clients.\n\n This callback gives a chance to:\n 1 - Perform some additional operations before exiting;\n 2 - Prevent the process from exiting by returning \"true\" from the callback."]
    pub fn AServiceManager_setActiveServicesCallback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: bool, arg2: *mut ::std::os::raw::c_void) -> bool,
        >,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Try to unregister all services previously registered with 'registerService'.\n\n \\return true on success."]
    pub fn AServiceManager_tryUnregister() -> bool;
}
extern "C" {
    #[doc = " Re-register services that were unregistered by 'tryUnregister'.\n This method should be called in the case 'tryUnregister' fails\n (and should be called on the same thread)."]
    pub fn AServiceManager_reRegister();
}
extern "C" {
    #[doc = " Data written to the parcel will be zero'd before being deleted or realloced.\n\n The main use of this is marking a parcel that will be used in a transaction\n with FLAG_CLEAR_BUF. When FLAG_CLEAR_BUF is used, the reply parcel will\n automatically be marked as sensitive when it is created.\n\n \\param parcel The parcel to clear associated data from."]
    pub fn AParcel_markSensitive(parcel: *const AParcel);
}
extern "C" {
    #[doc = " This creates a threadpool for incoming binder transactions if it has not already been created,\n spawning one thread, and allowing the kernel to lazily start threads according to the count\n that is specified in ABinderProcess_setThreadPoolMaxThreadCount.\n\n For instance, if ABinderProcess_setThreadPoolMaxThreadCount(3) is called,\n ABinderProcess_startThreadPool() is called (+1 thread) then the main thread calls\n ABinderProcess_joinThreadPool() (+1 thread), up to *5* total threads will be started\n (2 directly, and 3 more if the kernel starts them lazily).\n\n When using this, it is expected that ABinderProcess_setupPolling and\n ABinderProcess_handlePolledCommands are not used.\n\n Do not use this from a library. Apps setup their own threadpools, and otherwise, the main\n function should be responsible for configuring the threadpool for the entire application."]
    pub fn ABinderProcess_startThreadPool();
}
extern "C" {
    #[doc = " This sets the maximum number of threads that can be started in the threadpool. By default, after\n startThreadPool is called, this is 15. If it is called additional times, it will only prevent\n the kernel from starting new threads and will not delete already existing threads. This should\n be called once before startThreadPool. The number of threads can never decrease.\n\n This count refers to the number of threads that will be created lazily by the kernel, in\n addition to the single threads created by ABinderProcess_startThreadPool (+1) or\n ABinderProcess_joinThreadPool (+1). Note: ABinderProcess_startThreadPool starts a thread\n itself, but it also enables up to the number of threads passed to this function to start.\n This function does not start any threads itself; it only configures\n ABinderProcess_startThreadPool.\n\n Do not use this from a library. Apps setup their own threadpools, and otherwise, the main\n function should be responsible for configuring the threadpool for the entire application."]
    pub fn ABinderProcess_setThreadPoolMaxThreadCount(numThreads: u32) -> bool;
}
extern "C" {
    #[doc = " Check if the threadpool has already been started.\n This tells whether someone in the process has called ABinderProcess_startThreadPool. Usually,\n you should use this in a library to abort if the threadpool is not started.\n Programs should configure binder threadpools once at the beginning."]
    pub fn ABinderProcess_isThreadPoolStarted() -> bool;
}
extern "C" {
    #[doc = " This adds the current thread to the threadpool. This thread will be in addition to the thread\n configured with ABinderProcess_setThreadPoolMaxThreadCount and started with\n ABinderProcess_startThreadPool.\n\n Do not use this from a library. Apps setup their own threadpools, and otherwise, the main\n function should be responsible for configuring the threadpool for the entire application."]
    pub fn ABinderProcess_joinThreadPool();
}
extern "C" {
    #[doc = " This gives you an fd to wait on. Whenever data is available on the fd,\n ABinderProcess_handlePolledCommands can be called to handle binder queries.\n This is expected to be used in a single threaded process which waits on\n events from multiple different fds.\n\n When using this, it is expected ABinderProcess_startThreadPool and\n ABinderProcess_joinThreadPool are not used.\n\n \\param fd out param corresponding to the binder domain opened in this\n process.\n \\return STATUS_OK on success"]
    pub fn ABinderProcess_setupPolling(fd: *mut ::std::os::raw::c_int) -> binder_status_t;
}
extern "C" {
    #[doc = " This will handle all queued binder commands in this process and then return.\n It is expected to be called whenever there is data on the fd.\n\n \\return STATUS_OK on success"]
    pub fn ABinderProcess_handlePolledCommands() -> binder_status_t;
}
#[doc = " Function to execute a shell command.\n\n Available since API level 30.\n\n \\param binder the binder executing the command\n \\param in input file descriptor, should be flushed, ownership is not passed\n \\param out output file descriptor, should be flushed, ownership is not passed\n \\param err error file descriptor, should be flushed, ownership is not passed\n \\param argv array of null-terminated strings for command (may be null if argc\n is 0)\n \\param argc length of argv array\n\n \\return binder_status_t result of transaction"]
pub type AIBinder_handleShellCommand = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        in_: ::std::os::raw::c_int,
        out: ::std::os::raw::c_int,
        err: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
        argc: u32,
    ) -> binder_status_t,
>;
extern "C" {
    #[doc = " This sets the implementation of handleShellCommand for a class.\n\n If this isn't set, nothing will be executed when handleShellCommand is called.\n\n Available since API level 30.\n\n \\param handleShellCommand function to call when a shell transaction is\n received"]
    pub fn AIBinder_Class_setHandleShellCommand(
        clazz: *mut AIBinder_Class,
        handleShellCommand: AIBinder_handleShellCommand,
    );
}
extern "C" {
    #[doc = " This interface has the stability of the system image."]
    pub fn AIBinder_markSystemStability(binder: *mut AIBinder);
}
extern "C" {
    #[doc = " Given a binder interface at a certain stability, there may be some\n requirements associated with that higher stability level. For instance, a\n VINTF stability binder is required to be in the VINTF manifest. This API\n can be called to use that same interface within the system partition.\n\n WARNING: you must hold on to a binder instance after this is set, while you\n are using it. If you get a binder (e.g. `...->asBinder().get()`), you must\n save this binder and then\n use it. For instance:\n\n     auto binder = ...->asBinder();\n     AIBinder_forceDowngradeToSystemStability(binder.get());\n     doSomething(binder);"]
    pub fn AIBinder_forceDowngradeToSystemStability(binder: *mut AIBinder);
}
extern "C" {
    pub fn AIBinder_markVintfStability(binder: *mut AIBinder);
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum android_c_interface_StatusCode {
    OK = 0,
    UNKNOWN_ERROR = -2147483648,
    NO_MEMORY = -12,
    INVALID_OPERATION = -38,
    BAD_VALUE = -22,
    BAD_TYPE = -2147483647,
    NAME_NOT_FOUND = -2,
    PERMISSION_DENIED = -1,
    NO_INIT = -19,
    ALREADY_EXISTS = -17,
    DEAD_OBJECT = -32,
    FAILED_TRANSACTION = -2147483646,
    BAD_INDEX = -75,
    NOT_ENOUGH_DATA = -61,
    WOULD_BLOCK = -11,
    TIMED_OUT = -110,
    UNKNOWN_TRANSACTION = -74,
    FDS_NOT_ALLOWED = -2147483641,
    UNEXPECTED_NULL = -2147483640,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum android_c_interface_ExceptionCode {
    NONE = 0,
    SECURITY = -1,
    BAD_PARCELABLE = -2,
    ILLEGAL_ARGUMENT = -3,
    NULL_POINTER = -4,
    ILLEGAL_STATE = -5,
    NETWORK_MAIN_THREAD = -6,
    UNSUPPORTED_OPERATION = -7,
    SERVICE_SPECIFIC = -8,
    PARCELABLE = -9,
    #[doc = " This is special, and indicates to native binder proxies that the\n transaction has failed at a low level."]
    TRANSACTION_FAILED = -129,
}
pub const FIRST_CALL_TRANSACTION: android_c_interface_consts__bindgen_ty_1 = 1;
pub const LAST_CALL_TRANSACTION: android_c_interface_consts__bindgen_ty_1 = 16777215;
pub type android_c_interface_consts__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const FLAG_ONEWAY: android_c_interface_consts__bindgen_ty_2 = 1;
pub const FLAG_CLEAR_BUF: android_c_interface_consts__bindgen_ty_2 = 32;
pub const FLAG_PRIVATE_LOCAL: android_c_interface_consts__bindgen_ty_2 = 0;
pub type android_c_interface_consts__bindgen_ty_2 = ::std::os::raw::c_uint;
}

pub use bindings::*;

impl Error for android_c_interface_StatusCode {}

impl fmt::Display for android_c_interface_StatusCode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "StatusCode::{:?}", self)
    }
}
