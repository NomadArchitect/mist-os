// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fuchsia.hardware.display.types;

using fuchsia.images2;
using fuchsia.math;

// Rotations are applied counter-clockwise, and are applied before reflections.  Note: this doesn't
// affect the output region on the physical display; use the layer's `dest_frame` for that.  In
// other words, if you have a 600x300 image that you want to rotate 90 degrees without changing the
// aspect ratio, you need to use `ROT_90`, and also use a `dest_frame` of 300x600.
//
// The reflection enums refer to the axis across which reflection occurs.  For example, `REFLECT_X`
// means a reflection across the X-axis.  In other words: bottom becomes top.
type Transform = strict enum : uint8 {
    IDENTITY = 0;
    REFLECT_X = 1;
    REFLECT_Y = 2;
    ROT_90 = 3;
    ROT_180 = 4;
    ROT_270 = 5;
    ROT_90_REFLECT_X = 6;
    ROT_90_REFLECT_Y = 7;
};

type AlphaMode = strict enum : uint8 {
    /// Alpha is disabled for the plane (default).
    DISABLE = 0;
    /// Plane alpha is premultiplied.
    PREMULTIPLIED = 1;
    /// Hardware should multiply the alpha and color channels when blending.
    HW_MULTIPLY = 2;
};

type ClientCompositionOpcode = strict enum : uint8 {
    /// The client should convert the corresponding layer to a primary layer.
    CLIENT_USE_PRIMARY = 0;
    /// The client should compose all layers with CLIENT_MERGE_BASE and CLIENT_MERGE_SRC
    /// into a new, single primary layer at the CLIENT_MERGE_BASE layer's z-order. The
    /// driver must accept a fullscreen layer with the default pixel format, but may
    /// accept other layer parameters.
    ///
    /// CLIENT_MERGE_BASE will only be set on one layer per display.
    CLIENT_MERGE_BASE = 1;
    /// See CLIENT_MERGE_BASE.
    CLIENT_MERGE_SRC = 2;
    /// The client should provide a new image produced by scaling the source image
    /// such that the dimensions of the new image's src_frame and dest_frame are
    /// equal to the dimensions of the current image's dest_frame.
    CLIENT_FRAME_SCALE = 3;
    /// The client should provide a new image produced by clipping the source image
    /// to the region specified by src_frame.
    CLIENT_SRC_FRAME = 4;
    /// The client should provide a new image produced by applying the desired
    /// transformation, so that TRANSFORM_IDENTITY can be specified.
    CLIENT_TRANSFORM = 5;
    /// The client should apply the color conversion itself.
    CLIENT_COLOR_CONVERSION = 6;
    /// The client should apply the alpha itself.
    CLIENT_ALPHA = 7;
};

type PrimaryLayer = struct {
    image_metadata ImageMetadata;

    /// If `alpha_mode` is `AlphaMode.DISABLE`, the layer is opaque and
    /// `alpha_layer_val` is ignored.
    ///
    /// If `alpha_mode` is `AlphaMode.PREMULTIPLIED` or `HW_MULTIPLY`, the
    /// alpha used when blending is determined by the product of
    /// `alpha_layer_val` and any per-pixel alpha.
    ///
    /// Additionally, if `alpha_mode` is `AlphaMode.PREMULTIPLIED`, then the
    /// hardware must premultiply the color channel with `alpha_layer_val`
    /// before blending.
    ///
    /// `alpha_layer_val` must be in the range [0, 1].
    alpha_mode AlphaMode;
    alpha_layer_val float32;

    transform Transform;

    /// The associated image region whose pixels are drawn by the layer.
    ///
    /// The rectangle uses the Vulkan coordinate space. The origin is at the
    /// image's top-left corner. The X axis points to the right, and the Y axis
    /// points downwards.
    ///
    /// A valid layer definition requires a valid non-empty image source
    /// rectangle that is entirely contained within the image.
    ///
    /// Hardware image cropping is requested implicitly, when the source
    /// region's dimensions differ from the image's dimensions. Some display
    /// hardware may not support cropping.
    image_source fuchsia.math.RectU;

    /// The display image (composited output) region occupied by the layer.
    ///
    /// The rectangle uses the Vulkan coordinate space. The origin is at the
    /// display's top-left corner. The X axis points to the right, and the Y axis
    /// points downwards.
    ///
    /// A valid layer definition requires a valid non-empty display destination
    /// rectangle that is entirely contained within the display.
    ///
    /// Hardware image scaling is requested implicitly, when the output region's
    /// dimensions differ from the dimensions of `image_source`. Some display
    /// hardware may not support scaling. All display hardware has limitations
    /// in scaling support.
    display_destination fuchsia.math.RectU;
};

type ColorLayer = struct {
    /// The format of `color` bytes.
    format fuchsia.images2.PixelFormat;

    /// The color to use for the layer. The color is little-endian, and is
    /// guaranteed to be of the exact size of one pixel in `format`.
    color vector<uint8>:MAX;
};

type LayerConfig = strict union {
    1: primary PrimaryLayer;
    2: color ColorLayer;
};

type Layer = struct {
    /// z_index of the layer. See
    /// [`fuchsia.hardware.display.engine/Engine.CheckConfiguration`] and
    /// [`fuchsia.hardware.display.engine/Engine.ApplyConfiguration`].
    cfg LayerConfig;
};
