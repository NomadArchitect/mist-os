// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fuchsia.hardware.display.types;

using fuchsia.images2;
using fuchsia.math;

/// Transformations that can be applied by display hardware to input images.
///
/// The coordinate system transformations listed here can be implemented in
/// hardware by display engines, because they have straightforward
/// implementations for raster images.
///
/// Support for input image transformations (every member except for `IDENTITY`)
/// varies across display engines. This is because each transformation requires
/// non-trivial hardware modifications that have area (cost) and power
/// implications.
type CoordinateTransformation = strict enum : uint8 {
    /// Image pixels are passed through without any change.
    ///
    /// This is the only value guaranteed to be supported by all display engine
    /// drivers.
    IDENTITY = 0;

    /// Image pixels are reflected across a line meeting the image's center, parallel to the X axis.
    ///
    /// This enum member's numeric value has a single bit set to 1. Any
    /// transformation whose value has this bit set involves an X reflection.
    ///
    /// This transformation is also called an "X flip".
    ///
    /// Example:
    /// |a b c d|      |i j k l|
    /// |e f g h|  ->  |e f g h|
    /// |i j k l|      |a b c d|
    REFLECT_X = 1;

    /// Image pixels are reflected across a line meeting the image's center, parallel to the Y axis.
    ///
    /// This enum member's numeric value has a single bit set to 1. Any
    /// transformation whose value has this bit set involves an Y reflection.
    ///
    /// This transformation is also called an "Y flip".
    ///
    /// Example:
    /// |a b c d|      |d c b a|
    /// |e f g h|  ->  |h g f e|
    /// |i j k l|      |l k j i|
    REFLECT_Y = 2;

    // TODO(https://fxbug.dev/356385730): Switch the convention for rotations
    // from CCW (counter-clockwise) to CW (clockwise).

    /// Image pixels are rotated around the image's center counter-clockwise by 180 degrees.
    ///
    /// This is equivalent to applying the `REFLECT_X` and `REFLECT_Y`
    /// transforms. `REFLECT_X` and `REFLECT_Y` are commutative, so their
    /// ordering doesn't matter.
    ///
    /// Example:
    /// |a b c d|      |l k j i|
    /// |e f g h|  ->  |h g f e|
    /// |i j k l|      |d c b a|
    ROTATE_CCW_180 = 3;

    /// Image pixels are rotated around the image's center counter-clockwise by 90 degrees.
    ///
    /// The image produced by this transformation has different dimensions from
    /// the input image.
    ///
    /// This enum member's numeric value has a single bit set to 1. Any
    /// transformation whose value has this bit set involves a 90-degree
    /// counter-clockwise rotation.
    ///
    /// Example:
    /// |a b c d|      |d h l|
    /// |e f g h|  ->  |c g k|
    /// |i j k l|      |b f j|
    ///                |a e i|
    ROTATE_CCW_90 = 4;

    /// Image pixels are transformed using `ROTATE_CCW_90`, followed by `REFLECT_X`.
    ///
    /// The image produced by this transformation has different dimensions from
    /// the input image.
    ///
    /// Example:
    /// |a b c d|      |a e i|
    /// |e f g h|  ->  |b f k|
    /// |i j k l|      |c g k|
    ///                |d h l|
    ROTATE_CCW_90_REFLECT_X = 5;

    /// Image pixels are transformed using `ROTATE_CCW_90`, followed by `REFLECT_Y`.
    ///
    /// The image produced by this transformation has different dimensions from
    /// the input image.
    ///
    /// Example:
    /// |a b c d|      |l h d|
    /// |e f g h|  ->  |k g c|
    /// |i j k l|      |j f b|
    ///                |i e a|
    ROTATE_CCW_90_REFLECT_Y = 6;

    /// Image pixels are rotated around the image's center counter-clockwise by 270 degrees.
    ///
    /// The image produced by this transformation has different dimensions from
    /// the input image.
    ///
    /// This is equivalent to applying the `ROTATE_CCW_90` transform, followed
    /// by `REFLECT_X` and `REFLECT_Y`. `REFLECT_X` and `REFLECT_Y` are
    /// commutative, so their ordering doesn't matter.
    ///
    /// Example:
    /// |a b c d|      |i e a|
    /// |e f g h|  ->  |j f b|
    /// |i j k l|      |k g c|
    ///                |l h d|
    ROTATE_CCW_270 = 7;
};

type AlphaMode = strict enum : uint8 {
    /// Alpha is disabled for the plane (default).
    DISABLE = 0;
    /// Plane alpha is premultiplied.
    PREMULTIPLIED = 1;
    /// Hardware should multiply the alpha and color channels when blending.
    HW_MULTIPLY = 2;
};

type ClientCompositionOpcode = strict enum : uint8 {
    /// The client should convert the corresponding layer to a primary layer.
    CLIENT_USE_PRIMARY = 0;
    /// The client should compose all layers with CLIENT_MERGE_BASE and CLIENT_MERGE_SRC
    /// into a new, single primary layer at the CLIENT_MERGE_BASE layer's z-order. The
    /// driver must accept a fullscreen layer with the default pixel format, but may
    /// accept other layer parameters.
    ///
    /// CLIENT_MERGE_BASE will only be set on one layer per display.
    CLIENT_MERGE_BASE = 1;
    /// See CLIENT_MERGE_BASE.
    CLIENT_MERGE_SRC = 2;
    /// The client should provide a new image produced by scaling the source image
    /// such that the dimensions of the new image's src_frame and dest_frame are
    /// equal to the dimensions of the current image's dest_frame.
    CLIENT_FRAME_SCALE = 3;
    /// The client should provide a new image produced by clipping the source image
    /// to the region specified by src_frame.
    CLIENT_SRC_FRAME = 4;
    /// The client should provide a new image produced by applying the desired
    /// transformation, so that TRANSFORM_IDENTITY can be specified.
    CLIENT_TRANSFORM = 5;
    /// The client should apply the color conversion itself.
    CLIENT_COLOR_CONVERSION = 6;
    /// The client should apply the alpha itself.
    CLIENT_ALPHA = 7;
};

type PrimaryLayer = struct {
    image_metadata ImageMetadata;

    /// If `alpha_mode` is `AlphaMode.DISABLE`, the layer is opaque and
    /// `alpha_layer_val` is ignored.
    ///
    /// If `alpha_mode` is `AlphaMode.PREMULTIPLIED` or `HW_MULTIPLY`, the
    /// alpha used when blending is determined by the product of
    /// `alpha_layer_val` and any per-pixel alpha.
    ///
    /// Additionally, if `alpha_mode` is `AlphaMode.PREMULTIPLIED`, then the
    /// hardware must premultiply the color channel with `alpha_layer_val`
    /// before blending.
    ///
    /// `alpha_layer_val` must be in the range [0, 1].
    alpha_mode AlphaMode;
    alpha_layer_val float32;

    /// Applied to the input image pixels specified by `image_source`.
    ///
    /// `display_destination` must account for image dimensions changes caused
    /// by rotations. For example, rotating a 600x300 pixel image by 90 degrees
    /// would specify 300x600 pixel dimensions in `display_destination`.
    image_source_transformation CoordinateTransformation;

    /// The associated image region whose pixels are drawn by the layer.
    ///
    /// The rectangle uses the Vulkan coordinate space. The origin is at the
    /// image's top-left corner. The X axis points to the right, and the Y axis
    /// points downwards.
    ///
    /// A valid layer definition requires a valid non-empty image source
    /// rectangle that is entirely contained within the image.
    ///
    /// Hardware image cropping is requested implicitly, when the source
    /// region's dimensions differ from the image's dimensions. Some display
    /// hardware may not support cropping.
    image_source fuchsia.math.RectU;

    /// The display image (composited output) region occupied by the layer.
    ///
    /// The rectangle uses the Vulkan coordinate space. The origin is at the
    /// display's top-left corner. The X axis points to the right, and the Y axis
    /// points downwards.
    ///
    /// A valid layer definition requires a valid non-empty display destination
    /// rectangle that is entirely contained within the display.
    ///
    /// Hardware image scaling is requested implicitly, when the output region's
    /// dimensions differ from the dimensions of `image_source`. Some display
    /// hardware may not support scaling. All display hardware has limitations
    /// in scaling support.
    display_destination fuchsia.math.RectU;
};

type ColorLayer = struct {
    /// The format of `color` bytes.
    format fuchsia.images2.PixelFormat;

    /// The color to use for the layer. The color is little-endian, and is
    /// guaranteed to be of the exact size of one pixel in `format`.
    color vector<uint8>:MAX;
};

type LayerConfig = strict union {
    1: primary PrimaryLayer;
    2: color ColorLayer;
};

type Layer = struct {
    /// z_index of the layer. See
    /// [`fuchsia.hardware.display.engine/Engine.CheckConfiguration`] and
    /// [`fuchsia.hardware.display.engine/Engine.ApplyConfiguration`].
    cfg LayerConfig;
};
