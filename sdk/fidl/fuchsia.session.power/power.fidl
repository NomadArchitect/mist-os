// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fuchsia.session.power;

using zx;

/// Lets the session manager handoff a power lease to a session component.
///
/// As an example, `session_manager` may take a lease on the
/// `ApplicationActivity` power element, and offer [`Handoff`] to the
/// session component. The session component can then take the lease from
/// `session_manager` when it is started. This way a constant dependency
/// is maintained on `ApplicationActivity` as the session is restarted.
@available(added=HEAD)
@discoverable
open protocol Handoff {
    /// Take the lease.
    flexible Take() -> (resource struct {
        /// A lease on the power element.
        ///
        /// This is secretly a `fuchsia.power.broker.LeaseControl` channel
        /// but we'd like to avoid exposing that to `ffx`. When that protocol
        /// is stabilized, we can replace the channel with that here.
        ///
        /// TODO(https://fxbug.dev/339474151): This may also become an
        /// eventpair as the linked bug tracks migrating lease control channel
        /// to eventpair.
        lease zx.Handle;
    }) error HandoffError;
};

/// Error when taking the power lease.
@available(added=HEAD)
type HandoffError = flexible enum {
    /// The lease is already taken.
    ALREADY_TAKEN = 1;

    /// The lease is not available due to errors or configuration.
    UNAVAILABLE = 2;
};

/// Allows components to request callbacks on power-state changes.
///
/// The timing of acknowledgements from `BlockingListener`s affects
/// the suspend and resume processes, as the `ListenerRegistry` MUST
/// wait for the `BlockingListener`s to respond.
///
/// Note, however, that the `ListenerRegistry` MAY apply a timeout
/// to the responses.
@available(added=HEAD)
@discoverable
open protocol ListenerRegistry {
    /// Registers `listener` with the registry.
    ///
    /// When the `ListenerRegistry` learns of power state changes, the
    /// `ListenerRegistry` will forward the event to the `listener`.
    ///
    /// See documentation of the `BlockingListener` methods for details
    /// on which events are available, and the semantics of each callback.
    ///
    /// The `ListenerRegistry` MUST continue to forward events to the
    /// `listener`, even after the `ListenerRegistry` connection
    /// is closed.
    ///
    /// Replaces any existing `listener` that was previously registered.
    flexible RegisterBlockingListener(resource struct {
        listener client_end:BlockingListener;
    }) -> ();
};

/// Interface implemented by components which elect to receive
/// power-state callbacks from a Session, and have the Session
/// block related power operations until the component replies.
///
/// Closing the server endpoint of `BlockingListener` will
/// remove the blocking listener from the registry and unblock
/// related power operations.
@available(added=HEAD)
open protocol BlockingListener {
    /// Called by the `ListenerRegistry` to inform the component
    /// that the system has started resuming.
    ///
    /// The callee SHOULD minimize the time it (the callee) takes to reply,
    /// since other power operations may block until the callee replies.
    ///
    /// The caller SHOULD interpret an `UNKNOWN_METHOD` response as an
    /// indication that the callee has no work that would block the
    /// resume process.
    flexible OnResumeStarted() -> ();

    /// Called by the `ListenerRegistry` to inform the component
    /// that a suspend attempt failed.
    ///
    /// The callee SHOULD minimize the time it (callee) takes to reply,
    /// since later suspends may block until the callee replies.
    ///
    /// The caller SHOULD interpret an `UNKNOWN_METHOD` response as an
    /// indication that the callee has no work that would block future
    /// power-state changes.
    flexible OnSuspendFailed() -> ();
};
