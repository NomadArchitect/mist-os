// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
@available(added=7)
library fuchsia.io;

using zx;

/// The type for the name of a node, i.e. a single path component.
/// E.g. `foo`
///
/// ## Invariants
///
/// A valid node name must meet the following criteria:
///
/// * It cannot be longer than [`MAX_NAME_LENGTH`].
/// * It cannot be empty.
/// * It cannot be ".." (dot-dot).
/// * It cannot be "." (single dot).
/// * It cannot contain "/".
/// * It cannot contain embedded NUL.
alias Name = string:MAX_NAME_LENGTH;

/// The maximum length, in bytes, of a single filesystem component.
const MAX_NAME_LENGTH uint64 = 255;

/// A path is a string of one or more components, separated by "/".
/// E.g. `foo/bar/baz`
///
/// ## Invariants
///
/// A valid path must meet the following criteria:
///
/// * It cannot be empty.
/// * It cannot be longer than [`MAX_PATH_LENGTH`].
/// * It cannot have a leading "/".
/// * It cannot have a trailing "/".
/// * It must be exactly "." OR each of its components must be a valid [`Name`].
///
/// Paths should be transformed into their canonical forms at client side.
/// For example, a client should convert `"foo/bar/.././baz/"` to `"foo/baz"`
/// before using it as a path.
alias Path = string:MAX_PATH_LENGTH;

/// The maximum length, in bytes, of a filesystem path.
const MAX_PATH_LENGTH uint64 = 4095;

/// The type to identify a connection to a node.
/// It represents a capability: a reference to a node with associated rights.
alias Token = zx.Handle:EVENT;

/// The type to identify a node, if the implementation supports some notion of
/// unique node ID.
///
/// ## Uniqueness Guarantees
///
/// A client is usually presented with a directory tree that is the result
/// of composing together multiple backing implementation instances. An ID
/// would be unique within the corresponding instance only.
/// Their boundaries are rather implicit on Fuchsia, as a result of
/// transparently-forwarding directory proxies. It could be common for a client
/// to observe identical `Id`s when traversing a directory tree, when it
/// encounters nodes from different backing instances. Therefore, the ID is best
/// used for debugging and informational purposes.
///
/// The [`fuchsia.fs/FilesystemInfo.fs_id`] field may be used to disambiguate
/// IDs from different backing instances.
alias Id = uint64;


/// DEPRECATED - Use fuchsia.io/Flags + fuchsia.io/Options instead.
@available(removed=23)
type NodeOptions = table {
    1: flags @generated_name("NodeFlags") flexible bits : uint64 {
        /// Requests that an [`Node.OnRepresentation`] event be sent as the first message on the
        /// protocol request.
        ///
        /// This is a special case of [`fuchsia.unknown/Queryable.Query`] + inherent `Describe`
        /// methods on the specific protocols. It exists as an optimization to avoid an additional
        /// round trip.
        GET_REPRESENTATION = 0x01;
    };

    /// Callers may assert the type of the object by setting the protocol corresponding to the
    /// expected type:
    ///
    /// * If the caller expected a directory but the node cannot be accessed as a directory, the
    /// error is `ZX_ERR_NOT_DIR`.
    ///
    /// * If the caller expected a file but the node cannot be accessed as a file, the error is
    /// `ZX_ERR_NOT_FILE`.
    ///
    /// * In other mismatched cases, and for an empty table, the error is `ZX_ERR_WRONG_TYPE`.
    ///
    /// If more than one protocol is present, the resultant protocol may become any one of them.
    /// Callers should specify [`NodeFlags.GET_REPRESENTATION`] to receive a
    /// [`Node.OnRepresentation`] event, in order to ascertain the protocol.
    ///
    /// If absent, indicates that the caller accepts any [`Node`] protocol (including [`Node`]
    /// itself for connector nodes, for instance).
    2: protocols @generated_name("NodeProtocols") table {
        1: directory @generated_name("DirectoryProtocolOptions") table {
            /// Optional rights to be negotiated.
            ///
            /// When present, indicates that the caller requests additional optional rights equal to
            /// the intersection of this value and the rights on the requesting connection. This
            /// acts as a high water mark that prevents rights escalation as this request is proxied
            /// over multiple hops; each proxy must intersect the value with the rights on the
            /// requesting connection before proxying on.
            ///
            /// This field is necessary to express POSIX semantics where `open` of a directory must
            /// be `O_RDONLY` yet `openat` can be used to open non-directory nodes within that
            /// directory with privileges exceeding `O_RDONLY`. This means that POSIX clients must
            /// always set this to the full set of [`Rights`] to implement `open` or `openat` calls
            /// which don't forbid directories (e.g. `O_WRONLY` and `O_RDWR` do forbid directories).
            1: optional_rights Rights;
        };
        2: file @generated_name("FileProtocolFlags") flexible bits : uint64 {
            /// Opens the file in append mode, i.e. the connection should seek to the end of the
            /// file before every write.
            ///
            /// If the file does not support appending, it should result in a `ZX_ERR_NOT_SUPPORTED`
            /// epitaph. Currently, only [`NodeProtocolKinds.FILE`] connections support appending.
            APPEND = 0x01;

            /// Truncates the object before usage, by setting its length to 0. Requires the
            /// [`Rights.WRITE_BYTES`] right on the connection.
            ///
            /// If the file does not support truncating, it should result in a
            /// `ZX_ERR_NOT_SUPPORTED` epitaph.
            TRUNCATE = 0x02;
        };
        @available(added=18)
        3: symlink @generated_name("SymlinkProtocolFlags") flexible bits : uint64 {};

        /// Asks for the node protocol. The only right supported is [`Rights.GET_ATTRIBUTES`].
        /// Calling `SetFlags` on the resulting connection will result in `ZX_ERR_BAD_HANDLE`. If
        /// [`NodeFlags.GET_REPRESENTATION`] is specified, the `connector` variant will be returned
        /// (even if the object supports a different representation).
        @available(added=18)
        4: node @generated_name("NodeProtocolFlags") flexible bits : uint64 {
            /// Only allow the connection if the underlying object is a directory. An attempt to
            /// open something other than a directory will result in a `ZX_ERR_NOT_DIR` epitaph.
            MUST_BE_DIRECTORY = 0x01;
        };
    };

    /// Specifies behavior with respect to existence. If an object is to be created, its type is
    /// specified by `protocols`; it must be present. If a valid object type cannot be unambiguously
    /// inferred e.g. both `directory` and `file` are set, the request must fail.
    @available(replaced=19)
    3: mode @generated_name("OpenMode") strict enum : uint32 {
        /// Only succeed if the object exists.
        OPEN_EXISTING = 1;

        /// Create the object if it does not exist, otherwise open existing. The check and the
        /// creation are performed in one atomic step.
        MAYBE_CREATE = 2;

        /// Assert that the object does not exist, then create it. The assertion and creation are
        /// performed in one atomic step.
        ALWAYS_CREATE = 3;
    };

    /// Specifies how the target object should be created. If an object is to be created, its type
    /// must be specified by `protocols`. The check for existence and creation of the new object
    /// are performed atomically.
    ///
    /// If the type is ambiguous (e.g. both `directory` and `file` are set), the request must fail
    /// with `ZX_ERR_INVALID_ARGS`.
    @available(added=19)
    3: mode @generated_name("CreationMode") strict enum : uint32 {
        /// Only open an existing object, never create a new object.
        NEVER = 0;

        @available(deprecated=19, note="For backwards compatibility. Use NEVER instead.")
        NEVER_DEPRECATED = 1;

        /// Create a new object if one does not exist, otherwise open the existing object.
        ALLOW_EXISTING = 2;

        /// Create a new object if one does not exist, otherwise the request will fail with
        /// `ZX_ERR_ALREADY_EXISTS`.
        ALWAYS = 3;
    };

    /// Requested rights on the new connection. If any [`rights`] exceed those of the current
    /// connection, [`object_request`] will be closed with `ZX_ERR_ACCESS_DENIED`.
    ///
    /// The rights granted to the connection will be downscoped to those operations the target
    /// node type supports. For example, if the target node is a file and both
    /// [`Rights.WRITE_BYTES`] and [`Rights.MODIFY_DIRECTORY`] are requested, the resulting
    /// connection will only be granted [`Rights.WRITE_BYTES`].
    ///
    /// If the rights field is absent, it is the equivalent of empty rights.
    4: rights Rights;

    /// If the [`NodeFlags.GET_REPRESENTATION`] flag is set, attributes to be returned in
    /// [`Node.OnRepresentation`]. This requires the [`Rights.GET_ATTRIBUTES`] right on the parent
    /// connection, but not the resulting connection.
    @available(added=18)
    5: attributes NodeAttributesQuery;

    /// If an object is to be created, this specifies attributes that should be stored with the
    /// object at creation time. This requires the [`Rights.UPDATE_ATTRIBUTES`] right on the parent
    /// connection, but not the resulting connection. Requests will fail with `ZX_ERR_NOT_SUPPORTED`
    /// if any specified attributes are not supported.
    @available(added=18)
    6: create_attributes MutableNodeAttributes;
};
