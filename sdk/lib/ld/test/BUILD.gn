# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components/fuchsia_unittest_package.gni")
import("//build/dist/distribution_manifest.gni")
import("//build/test.gni")
import("//build/toolchain/zircon/user_basic_redirect.gni")
import("//build/zircon/c_utils.gni")
import("//sdk/lib/ld/testing/test_elf_object.gni")

group("tests") {
  testonly = true

  deps = [
    ":ld-tests",
    ":ld-unittests($host_toolchain)",
  ]
}

test("ld-unittests") {
  sources = [ "abi-tests.cc" ]
  deps = [
    "..:headers",
    "../testing",
    "//src/lib/elfldltl/testing",
    "//src/lib/fxl/test:gtest_main",
    "//src/lib/symbolizer-markup",
    "//third_party/googletest:gmock",
  ]

  if (is_elf) {
    deps += [ ":load-tests" ]
  }
  if (is_fuchsia) {
    sources += [
      "debugdata-tests.h",
      "fuchsia-debugdata-tests.cc",
      "mock-debugdata-tests.cc",
      "mock-loader-service-tests.cc",
    ]
    deps += [ "..:fuchsia-debugdata" ]
  }
}

fuchsia_unittest_package("ld-tests") {
  deps = [ ":ld-unittests" ]
  manifest = "meta/ld-tests.cml"

  # By default the packaging step will do checks that try to detect bugs in the
  # build system by verifying that ELF files in a package match a bunch of
  # hard-coded assumptions about the old dynamic linker and libc implementation
  # that don't hold true for the test binaries here.
  disable_elf_binaries_checks = true
}

# This collects the -DLD_TEST_LIBPREFIX=... flag in the response file.
generated_file("ld-test-switches.rsp") {
  visibility = [ ":*" ]
  testonly = true
  output_conversion = "list lines"
  data_keys = [ "ld_test_switches" ]
  outputs = [ "$target_gen_dir/$target_name" ]
  data_deps = [ ":load-test-data" ]
  metadata = {
    # Don't let manifests roll up ld.so.1 from here just because test code
    # depends on this target.
    distribution_entries_barrier = []
  }
}

# Depending on this plumbs through the response file into cflags.
group("ld-test-switches") {
  visibility = [
    ":*",
    "../testing:*",
    "//sdk/lib/dl/test:*",
  ]
  testonly = true

  public_deps = [ ":ld-test-switches.rsp" ]
  public_configs = [ ":ld-test-switches.config" ]
}

config("ld-test-switches.config") {
  visibility = [ ":*" ]

  inputs = get_target_outputs(":ld-test-switches.rsp")
  cflags = [ "@" + rebase_path(inputs[0], root_build_dir) ]
}

source_set("load-tests") {
  visibility = [ ":*" ]
  testonly = true

  sources = [
    "ld-load-tests-base.cc",
    "ld-load-tests-base.h",
    "load-tests-abi.cc",
    "load-tests-basic.cc",
    "load-tests-deps.cc",
    "load-tests-failure.cc",
    "load-tests-reloc.cc",
    "load-tests-symbolizer.cc",
    "load-tests-tls.cc",
    "load-tests.h",
  ]
  deps = [
    ":ld-test-switches",
    ":load-tests-load-sets",
    "..:abi-headers",
    "..:headers",
    "..:posix.headers",
    "../testing",
    "//src/lib/elfldltl",
    "//src/lib/elfldltl/testing",
    "//third_party/googletest:gtest",
    "//zircon/system/ulib/fbl",
  ]
  data_deps = [ ":load-test-data" ]
  if (is_fuchsia) {
    sources += [
      "ld-load-zircon-ldsvc-tests-base.h",
      "ld-load-zircon-process-tests-base.cc",
      "ld-load-zircon-process-tests-base.h",
      "ld-remote-process-tests.cc",
      "ld-remote-process-tests.h",
      "ld-startup-create-process-tests.cc",
      "ld-startup-create-process-tests.h",
      "ld-startup-in-process-tests-zircon.cc",
      "ld-startup-in-process-tests-zircon.h",
      "ld-startup-spawn-process-tests-zircon.cc",
      "ld-startup-spawn-process-tests-zircon.h",
      "load-tests-llvm-profdata.cc",
      "remote-tests.cc",
    ]
    deps += [
      "..:fuchsia-debugdata",
      "..:remote",
      "../testing",
      "//sdk/lib/fdio",
      "//zircon/system/ulib/zx",
    ]
  } else {
    sources += [
      "ld-startup-in-process-tests-posix.cc",
      "ld-startup-in-process-tests-posix.h",
      "ld-startup-spawn-process-tests-posix.cc",
      "ld-startup-spawn-process-tests-posix.h",
    ]
    deps += [ ":test-chdir-guard" ]
  }

  # Let gtest describe TYPED_TEST cases nicely.
  configs += [ "//build/config:no_rtti" ]
  configs -= [ "//build/config:no_rtti" ]
}

# This gets the ld::testing::TestElfLoadSet data used by the
# load-tests-symbolizer.cc test cases.
test_elf_source_set("load-tests-load-sets") {
  visibility = [ ":*" ]
  deps = [ ":load-tests-load-sets.basic" ]
}

user_basic_redirect("load-tests-load-sets.basic") {
  visibility = [ ":*" ]
  testonly = true
  exclude_toolchain_tags = [ "instrumentation-runtime" ]
  public_deps = [
    "modules:indirect-deps.in-process.load-set",
    "modules:indirect-deps.load-set",
  ]
}

source_set("test-chdir-guard") {
  testonly = true
  public = [ "test-chdir-guard.h" ]
  sources = [ "test-chdir-guard.cc" ]
  deps = [
    "//src/lib/elfldltl/testing",
    "//third_party/googletest:gtest",
  ]
}

if (!is_fuchsia) {
  # For host tests, the test binaries must be packaged in host_test_data() at
  # the expected path where elfldltl::testing::GetTestLib will find them.
  test_tc = ""
  if (is_linux) {
    # The linux_$cpu (vs host_$cpu) handles shared libraries.
    test_tc = "(//build/toolchain:linux_$current_cpu)"
  }

  group("load-test-data") {
    visibility = [
      "./*",
      "//sdk/lib/dl/test/*",
    ]
    testonly = true
    deps = [ "modules$test_tc" ]
  }

  # This is reached via data_deps from the test_executable() targets in
  # modules/ where they will be instantiated in the same toolchain via variant
  # selection as the test, so that ld.so.1 gets the right libprefix.
  if (current_toolchain != shlib_toolchain) {
    # host_test_data() adds a dep on $target_name(${toolchain_variant.base}),
    # which drops the shlib qualifier, so there is an extra dependency on this
    # target that shouldn't really exist.  It's crucial that the real target in
    # $shlib_toolchain be the one reached via data_deps in modules.
    group("ld-startup.test-data") {
      visibility = [ "./*" ]
      testonly = true
    }
  } else {
    host_out_dir = get_label_info(".($host_toolchain)", "root_out_dir")
    host_test_data("ld-startup.test-data") {
      visibility = [ "./*" ]
      deps = [ "..:ld-startup" ]
      sources = [ "$root_out_dir/libld-startup.so" ]
      outputs = [ "$host_out_dir/test_data/elfldltl/${toolchain_variant.libprefix}ld.so.1" ]
    }
  }
} else {
  # On Fuchsia these are just included in /pkg/... implicitly by dint of being
  # in data_deps of the test code.  But we want to repackage those deps to put
  # them into /pkg/lib/test/... instead so they can be fetched as executable
  # via fuchsia.ldsvc.

  distribution_manifest("load-test-data") {
    visibility = [
      "./*",
      "//sdk/lib/dl/test/*",
    ]
    testonly = true

    # This will collect the files from deps that would go into /pkg/... and
    # rewrite their manifest entries to use /pkg/lib/test/... instead.
    prefix = "lib/test"

    deps = [ ":modules.basic" ]

    # Make this manifest itself an input for collections via deps on this.
    outputs = [ "$target_gen_dir/$target_name.json" ]
    metadata = {
      distribution_entries_files = [
        {
          file = rebase_path(outputs[0], root_build_dir)
          label = get_label_info(":$target_name", "label_with_toolchain")
        },
      ]
    }
  }

  user_basic_redirect("modules.basic") {
    visibility = [ ":*" ]
    testonly = true
    public_deps = [ "modules" ]
  }

  # The dependency on this should already be in the user.basic environment
  # because it comes from modules:test-executable, which is reached via the
  # modules.basic redirect above.
  group("ld-startup.test-data") {
    testonly = true
    public_deps = [ "..:ld-startup" ]
  }
}
