// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <lib/fidl/txn_header.h>
#include <lib/ld/fuchsia-debugdata.h>
#include <zircon/fidl.h>

namespace ld {
namespace {

// TODO(https://fxbug.dev/42072760): This should be generated by Zither.
// TODO(https://fxbug.dev/324111518): Migrate this to fuchsia.unknown/Cloneable.Clone2.

constexpr uint64_t fuchsia_io_NodeClone_Ordinal = 0x5a61678f293ce16f;
constexpr uint32_t kOpenFlags_CloneSameRights = 0x04000000;

struct fuchsia_io_NodeCloneRequest {
  alignas(FIDL_ALIGNMENT) fidl_message_header_t hdr;
  uint32_t flags;
  zx_handle_t object;
};

zx::result<> fuchsia_io_NodeClone(zx::unowned_channel client_end, uint32_t flags,
                                  zx::channel object) {
  fuchsia_io_NodeCloneRequest request;
  fidl_init_txn_header(&request.hdr, 0, fuchsia_io_NodeClone_Ordinal, 0);
  request.flags = flags;
  request.object = FIDL_HANDLE_PRESENT;
  const zx_handle_t handles[] = {object.release()};
  return zx::make_result(client_end->write(0u, &request, sizeof(request), handles, 1));
}

}  // namespace

zx::result<> Debugdata::Forward(zx::unowned_channel svc_client_end, zx::channel svc_server_end) {
  return fuchsia_io_NodeClone(std::move(svc_client_end), kOpenFlags_CloneSameRights,
                              std::move(svc_server_end));
}

}  // namespace ld
